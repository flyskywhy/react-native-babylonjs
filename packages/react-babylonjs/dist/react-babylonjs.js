import {Dimensions, Platform} from 'react-native';
import 'react-native-match-media-polyfill';
import {GCanvasView} from '@flyskywhy/react-native-gcanvas';

import { Camera as Camera$1 } from '@babylonjs/core/Cameras/camera.js';
import { Ray } from '@babylonjs/core/Culling/ray.js';
import { Frustum } from '@babylonjs/core/Maths/math.frustum.js';
import { Vector3, Matrix, Vector2 } from '@babylonjs/core/Maths/math.vector.js';
import React, { createContext, useContext, useEffect, forwardRef, useState, useRef, useMemo, useLayoutEffect, version } from 'react';
import { unmountComponentAtNode, render } from 'react-dom';
import { SceneLoader } from '@babylonjs/core/Loading/sceneLoader.js';
import { AbstractMesh as AbstractMesh$1 } from '@babylonjs/core/Meshes/abstractMesh.js';
import { AbstractScene } from '@babylonjs/core/abstractScene.js';
import { AutoRotationBehavior as AutoRotationBehavior$1 } from '@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js';
import { BouncingBehavior as BouncingBehavior$1 } from '@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js';
import { FramingBehavior as FramingBehavior$1 } from '@babylonjs/core/Behaviors/Cameras/framingBehavior.js';
import { AttachToBoxBehavior as AttachToBoxBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/attachToBoxBehavior.js';
import { BaseSixDofDragBehavior as BaseSixDofDragBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js';
import { FadeInOutBehavior as FadeInOutBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js';
import { FollowBehavior as FollowBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/followBehavior.js';
import { HandConstraintBehavior as HandConstraintBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/handConstraintBehavior.js';
import { MultiPointerScaleBehavior as MultiPointerScaleBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/multiPointerScaleBehavior.js';
import { PointerDragBehavior as PointerDragBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js';
import { SixDofDragBehavior as SixDofDragBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js';
import { SurfaceMagnetismBehavior as SurfaceMagnetismBehavior$1 } from '@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js';
import { ArcRotateCamera as ArcRotateCamera$1 } from '@babylonjs/core/Cameras/arcRotateCamera.js';
import { DeviceOrientationCamera as DeviceOrientationCamera$1 } from '@babylonjs/core/Cameras/deviceOrientationCamera.js';
import { FlyCamera as FlyCamera$1 } from '@babylonjs/core/Cameras/flyCamera.js';
import { FollowCamera as FollowCamera$1, ArcFollowCamera as ArcFollowCamera$1 } from '@babylonjs/core/Cameras/followCamera.js';
import { FreeCamera as FreeCamera$1 } from '@babylonjs/core/Cameras/freeCamera.js';
import { GamepadCamera as GamepadCamera$1 } from '@babylonjs/core/Cameras/gamepadCamera.js';
import { AnaglyphArcRotateCamera as AnaglyphArcRotateCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/anaglyphArcRotateCamera.js';
import { AnaglyphFreeCamera as AnaglyphFreeCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/anaglyphFreeCamera.js';
import { AnaglyphGamepadCamera as AnaglyphGamepadCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/anaglyphGamepadCamera.js';
import { AnaglyphUniversalCamera as AnaglyphUniversalCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/anaglyphUniversalCamera.js';
import { StereoscopicArcRotateCamera as StereoscopicArcRotateCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/stereoscopicArcRotateCamera.js';
import { StereoscopicFreeCamera as StereoscopicFreeCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/stereoscopicFreeCamera.js';
import { StereoscopicGamepadCamera as StereoscopicGamepadCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/stereoscopicGamepadCamera.js';
import { StereoscopicScreenUniversalCamera as StereoscopicScreenUniversalCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/stereoscopicScreenUniversalCamera.js';
import { StereoscopicUniversalCamera as StereoscopicUniversalCamera$1 } from '@babylonjs/core/Cameras/Stereoscopic/stereoscopicUniversalCamera.js';
import { TargetCamera as TargetCamera$1 } from '@babylonjs/core/Cameras/targetCamera.js';
import { TouchCamera as TouchCamera$1 } from '@babylonjs/core/Cameras/touchCamera.js';
import { UniversalCamera as UniversalCamera$1 } from '@babylonjs/core/Cameras/universalCamera.js';
import { VirtualJoysticksCamera as VirtualJoysticksCamera$1 } from '@babylonjs/core/Cameras/virtualJoysticksCamera.js';
import { VRDeviceOrientationArcRotateCamera as VRDeviceOrientationArcRotateCamera$1 } from '@babylonjs/core/Cameras/VR/vrDeviceOrientationArcRotateCamera.js';
import { VRDeviceOrientationFreeCamera as VRDeviceOrientationFreeCamera$1 } from '@babylonjs/core/Cameras/VR/vrDeviceOrientationFreeCamera.js';
import { VRDeviceOrientationGamepadCamera as VRDeviceOrientationGamepadCamera$1 } from '@babylonjs/core/Cameras/VR/vrDeviceOrientationGamepadCamera.js';
import { VRExperienceHelper as VRExperienceHelper$1 } from '@babylonjs/core/Cameras/VR/vrExperienceHelper.js';
import { WebVRFreeCamera as WebVRFreeCamera$1 } from '@babylonjs/core/Cameras/VR/webVRCamera.js';
import { EngineView as EngineView$1 } from '@babylonjs/core/Engines/Extensions/engine.views.js';
import { AxisDragGizmo as AxisDragGizmo$1 } from '@babylonjs/core/Gizmos/axisDragGizmo.js';
import { AxisScaleGizmo as AxisScaleGizmo$1 } from '@babylonjs/core/Gizmos/axisScaleGizmo.js';
import { BoundingBoxGizmo as BoundingBoxGizmo$1 } from '@babylonjs/core/Gizmos/boundingBoxGizmo.js';
import { CameraGizmo as CameraGizmo$1 } from '@babylonjs/core/Gizmos/cameraGizmo.js';
import { Gizmo as Gizmo$1 } from '@babylonjs/core/Gizmos/gizmo.js';
import { GizmoManager as GizmoManager$1 } from '@babylonjs/core/Gizmos/gizmoManager.js';
import { LightGizmo as LightGizmo$1 } from '@babylonjs/core/Gizmos/lightGizmo.js';
import { PlaneDragGizmo as PlaneDragGizmo$1 } from '@babylonjs/core/Gizmos/planeDragGizmo.js';
import { PlaneRotationGizmo as PlaneRotationGizmo$1 } from '@babylonjs/core/Gizmos/planeRotationGizmo.js';
import { PositionGizmo as PositionGizmo$1 } from '@babylonjs/core/Gizmos/positionGizmo.js';
import { RotationGizmo as RotationGizmo$1 } from '@babylonjs/core/Gizmos/rotationGizmo.js';
import { ScaleGizmo as ScaleGizmo$1 } from '@babylonjs/core/Gizmos/scaleGizmo.js';
import { EnvironmentHelper as EnvironmentHelper$1 } from '@babylonjs/core/Helpers/environmentHelper.js';
import { EffectLayer as EffectLayer$1 } from '@babylonjs/core/Layers/effectLayer.js';
import { GlowLayer as GlowLayer$1 } from '@babylonjs/core/Layers/glowLayer.js';
import { HighlightLayer as HighlightLayer$1 } from '@babylonjs/core/Layers/highlightLayer.js';
import { Layer as Layer$1 } from '@babylonjs/core/Layers/layer.js';
import { DirectionalLight as DirectionalLight$1 } from '@babylonjs/core/Lights/directionalLight.js';
import { HemisphericLight as HemisphericLight$1 } from '@babylonjs/core/Lights/hemisphericLight.js';
import { Light as Light$1 } from '@babylonjs/core/Lights/light.js';
import { PointLight as PointLight$1 } from '@babylonjs/core/Lights/pointLight.js';
import { ShadowLight as ShadowLight$1 } from '@babylonjs/core/Lights/shadowLight.js';
import { CascadedShadowGenerator as CascadedShadowGenerator$1 } from '@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js';
import { ShadowGenerator as ShadowGenerator$1 } from '@babylonjs/core/Lights/Shadows/shadowGenerator.js';
import { SpotLight as SpotLight$1 } from '@babylonjs/core/Lights/spotLight.js';
import { BackgroundMaterial as BackgroundMaterial$1 } from '@babylonjs/core/Materials/Background/backgroundMaterial.js';
import { ImageProcessingConfiguration as ImageProcessingConfiguration$1 } from '@babylonjs/core/Materials/imageProcessingConfiguration.js';
import { DetailMapConfiguration as DetailMapConfiguration$1 } from '@babylonjs/core/Materials/material.detailMapConfiguration.js';
import { Material as Material$1 } from '@babylonjs/core/Materials/material.js';
import { MaterialPluginBase as MaterialPluginBase$1 } from '@babylonjs/core/Materials/materialPluginBase.js';
import { MultiMaterial as MultiMaterial$1 } from '@babylonjs/core/Materials/multiMaterial.js';
import { NodeMaterial as NodeMaterial$1 } from '@babylonjs/core/Materials/Node/nodeMaterial.js';
import { OcclusionMaterial as OcclusionMaterial$1 } from '@babylonjs/core/Materials/Occlusion/occlusionMaterial.js';
import { PBRAnisotropicConfiguration as PBRAnisotropicConfiguration$1 } from '@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js';
import { PBRBaseMaterial as PBRBaseMaterial$1 } from '@babylonjs/core/Materials/PBR/pbrBaseMaterial.js';
import { PBRBaseSimpleMaterial as PBRBaseSimpleMaterial$1 } from '@babylonjs/core/Materials/PBR/pbrBaseSimpleMaterial.js';
import { PBRBRDFConfiguration as PBRBRDFConfiguration$1 } from '@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js';
import { PBRClearCoatConfiguration as PBRClearCoatConfiguration$1 } from '@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js';
import { PBRMaterial as PBRMaterial$1 } from '@babylonjs/core/Materials/PBR/pbrMaterial.js';
import { PBRMetallicRoughnessMaterial as PBRMetallicRoughnessMaterial$1 } from '@babylonjs/core/Materials/PBR/pbrMetallicRoughnessMaterial.js';
import { PBRSheenConfiguration as PBRSheenConfiguration$1 } from '@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js';
import { PBRSpecularGlossinessMaterial as PBRSpecularGlossinessMaterial$1 } from '@babylonjs/core/Materials/PBR/pbrSpecularGlossinessMaterial.js';
import { PBRSubSurfaceConfiguration as PBRSubSurfaceConfiguration$1 } from '@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js';
import { PrePassConfiguration as PrePassConfiguration$1 } from '@babylonjs/core/Materials/prePassConfiguration.js';
import { PushMaterial as PushMaterial$1 } from '@babylonjs/core/Materials/pushMaterial.js';
import { ShaderMaterial as ShaderMaterial$1 } from '@babylonjs/core/Materials/shaderMaterial.js';
import { StandardMaterial as StandardMaterial$1 } from '@babylonjs/core/Materials/standardMaterial.js';
import { BaseTexture as BaseTexture$1 } from '@babylonjs/core/Materials/Textures/baseTexture.js';
import { ColorGradingTexture as ColorGradingTexture$1 } from '@babylonjs/core/Materials/Textures/colorGradingTexture.js';
import { CubeTexture as CubeTexture$1 } from '@babylonjs/core/Materials/Textures/cubeTexture.js';
import { DynamicTexture as DynamicTexture$1 } from '@babylonjs/core/Materials/Textures/dynamicTexture.js';
import { EquiRectangularCubeTexture as EquiRectangularCubeTexture$1 } from '@babylonjs/core/Materials/Textures/equiRectangularCubeTexture.js';
import { HDRCubeTexture as HDRCubeTexture$1 } from '@babylonjs/core/Materials/Textures/hdrCubeTexture.js';
import { HtmlElementTexture as HtmlElementTexture$1 } from '@babylonjs/core/Materials/Textures/htmlElementTexture.js';
import { MirrorTexture as MirrorTexture$1 } from '@babylonjs/core/Materials/Textures/mirrorTexture.js';
import { MultiRenderTarget as MultiRenderTarget$1 } from '@babylonjs/core/Materials/Textures/multiRenderTarget.js';
import { MultiviewRenderTarget as MultiviewRenderTarget$1 } from '@babylonjs/core/Materials/Textures/MultiviewRenderTarget.js';
import { PrePassRenderTarget as PrePassRenderTarget$1 } from '@babylonjs/core/Materials/Textures/prePassRenderTarget.js';
import { CustomProceduralTexture as CustomProceduralTexture$1 } from '@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js';
import { NoiseProceduralTexture as NoiseProceduralTexture$1 } from '@babylonjs/core/Materials/Textures/Procedurals/noiseProceduralTexture.js';
import { ProceduralTexture as ProceduralTexture$1 } from '@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js';
import { RawCubeTexture as RawCubeTexture$1 } from '@babylonjs/core/Materials/Textures/rawCubeTexture.js';
import { RawTexture as RawTexture$1 } from '@babylonjs/core/Materials/Textures/rawTexture.js';
import { RawTexture2DArray as RawTexture2DArray$1 } from '@babylonjs/core/Materials/Textures/rawTexture2DArray.js';
import { RawTexture3D as RawTexture3D$1 } from '@babylonjs/core/Materials/Textures/rawTexture3D.js';
import { RefractionTexture as RefractionTexture$1 } from '@babylonjs/core/Materials/Textures/refractionTexture.js';
import { RenderTargetTexture as RenderTargetTexture$1 } from '@babylonjs/core/Materials/Textures/renderTargetTexture.js';
import { Texture as Texture$1 } from '@babylonjs/core/Materials/Textures/texture.js';
import { ThinRenderTargetTexture as ThinRenderTargetTexture$1 } from '@babylonjs/core/Materials/Textures/thinRenderTargetTexture.js';
import { ThinTexture as ThinTexture$1 } from '@babylonjs/core/Materials/Textures/thinTexture.js';
import { VideoTexture as VideoTexture$1 } from '@babylonjs/core/Materials/Textures/videoTexture.js';
import { Viewport as Viewport$1 } from '@babylonjs/core/Maths/math.viewport.js';
import { GoldbergMesh as GoldbergMesh$1 } from '@babylonjs/core/Meshes/goldbergMesh.js';
import { GroundMesh as GroundMesh$1 } from '@babylonjs/core/Meshes/groundMesh.js';
import { InstancedMesh as InstancedMesh$1 } from '@babylonjs/core/Meshes/instancedMesh.js';
import { InstancedLinesMesh as InstancedLinesMesh$1, LinesMesh as LinesMesh$1 } from '@babylonjs/core/Meshes/linesMesh.js';
import { Mesh as Mesh$1 } from '@babylonjs/core/Meshes/mesh.js';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder.js';
import { TrailMesh as TrailMesh$1 } from '@babylonjs/core/Meshes/trailMesh.js';
import { TransformNode as TransformNode$1 } from '@babylonjs/core/Meshes/transformNode.js';
import { Node as Node$1 } from '@babylonjs/core/node.js';
import { PointsCloudSystem as PointsCloudSystem$1 } from '@babylonjs/core/Particles/pointsCloudSystem.js';
import { PhysicsImpostor as PhysicsImpostor$1 } from '@babylonjs/core/Physics/physicsImpostor.js';
import { AnaglyphPostProcess as AnaglyphPostProcess$1 } from '@babylonjs/core/PostProcesses/anaglyphPostProcess.js';
import { BlackAndWhitePostProcess as BlackAndWhitePostProcess$1 } from '@babylonjs/core/PostProcesses/blackAndWhitePostProcess.js';
import { BloomMergePostProcess as BloomMergePostProcess$1 } from '@babylonjs/core/PostProcesses/bloomMergePostProcess.js';
import { BlurPostProcess as BlurPostProcess$1 } from '@babylonjs/core/PostProcesses/blurPostProcess.js';
import { ChromaticAberrationPostProcess as ChromaticAberrationPostProcess$1 } from '@babylonjs/core/PostProcesses/chromaticAberrationPostProcess.js';
import { CircleOfConfusionPostProcess as CircleOfConfusionPostProcess$1 } from '@babylonjs/core/PostProcesses/circleOfConfusionPostProcess.js';
import { ColorCorrectionPostProcess as ColorCorrectionPostProcess$1 } from '@babylonjs/core/PostProcesses/colorCorrectionPostProcess.js';
import { ConvolutionPostProcess as ConvolutionPostProcess$1 } from '@babylonjs/core/PostProcesses/convolutionPostProcess.js';
import { DepthOfFieldBlurPostProcess as DepthOfFieldBlurPostProcess$1 } from '@babylonjs/core/PostProcesses/depthOfFieldBlurPostProcess.js';
import { DepthOfFieldMergePostProcess as DepthOfFieldMergePostProcess$1 } from '@babylonjs/core/PostProcesses/depthOfFieldMergePostProcess.js';
import { DisplayPassPostProcess as DisplayPassPostProcess$1 } from '@babylonjs/core/PostProcesses/displayPassPostProcess.js';
import { ExtractHighlightsPostProcess as ExtractHighlightsPostProcess$1 } from '@babylonjs/core/PostProcesses/extractHighlightsPostProcess.js';
import { FilterPostProcess as FilterPostProcess$1 } from '@babylonjs/core/PostProcesses/filterPostProcess.js';
import { FxaaPostProcess as FxaaPostProcess$1 } from '@babylonjs/core/PostProcesses/fxaaPostProcess.js';
import { GrainPostProcess as GrainPostProcess$1 } from '@babylonjs/core/PostProcesses/grainPostProcess.js';
import { HighlightsPostProcess as HighlightsPostProcess$1 } from '@babylonjs/core/PostProcesses/highlightsPostProcess.js';
import { ImageProcessingPostProcess as ImageProcessingPostProcess$1 } from '@babylonjs/core/PostProcesses/imageProcessingPostProcess.js';
import { MotionBlurPostProcess as MotionBlurPostProcess$1 } from '@babylonjs/core/PostProcesses/motionBlurPostProcess.js';
import { PassPostProcess as PassPostProcess$1, PassCubePostProcess as PassCubePostProcess$1 } from '@babylonjs/core/PostProcesses/passPostProcess.js';
import { PostProcess as PostProcess$1 } from '@babylonjs/core/PostProcesses/postProcess.js';
import { RefractionPostProcess as RefractionPostProcess$1 } from '@babylonjs/core/PostProcesses/refractionPostProcess.js';
import { DefaultRenderingPipeline as DefaultRenderingPipeline$1 } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.js';
import { LensRenderingPipeline as LensRenderingPipeline$1 } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js';
import { SSAO2RenderingPipeline as SSAO2RenderingPipeline$1 } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssao2RenderingPipeline.js';
import { SSAORenderingPipeline as SSAORenderingPipeline$1 } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssaoRenderingPipeline.js';
import { StandardRenderingPipeline as StandardRenderingPipeline$1 } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.js';
import { PostProcessRenderPipeline as PostProcessRenderPipeline$1 } from '@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.js';
import { ScreenSpaceCurvaturePostProcess as ScreenSpaceCurvaturePostProcess$1 } from '@babylonjs/core/PostProcesses/screenSpaceCurvaturePostProcess.js';
import { ScreenSpaceReflectionPostProcess as ScreenSpaceReflectionPostProcess$1 } from '@babylonjs/core/PostProcesses/screenSpaceReflectionPostProcess.js';
import { SharpenPostProcess as SharpenPostProcess$1 } from '@babylonjs/core/PostProcesses/sharpenPostProcess.js';
import { StereoscopicInterlacePostProcessI as StereoscopicInterlacePostProcessI$1, StereoscopicInterlacePostProcess as StereoscopicInterlacePostProcess$1 } from '@babylonjs/core/PostProcesses/stereoscopicInterlacePostProcess.js';
import { SubSurfaceScatteringPostProcess as SubSurfaceScatteringPostProcess$1 } from '@babylonjs/core/PostProcesses/subSurfaceScatteringPostProcess.js';
import { TonemapPostProcess as TonemapPostProcess$1 } from '@babylonjs/core/PostProcesses/tonemapPostProcess.js';
import { VolumetricLightScatteringPostProcess as VolumetricLightScatteringPostProcess$1 } from '@babylonjs/core/PostProcesses/volumetricLightScatteringPostProcess.js';
import { VRDistortionCorrectionPostProcess as VRDistortionCorrectionPostProcess$1 } from '@babylonjs/core/PostProcesses/vrDistortionCorrectionPostProcess.js';
import { VRMultiviewToSingleviewPostProcess as VRMultiviewToSingleviewPostProcess$1 } from '@babylonjs/core/PostProcesses/vrMultiviewToSingleviewPostProcess.js';
import { UtilityLayerRenderer as UtilityLayerRenderer$1 } from '@babylonjs/core/Rendering/utilityLayerRenderer.js';
import { Scene as Scene$2 } from '@babylonjs/core/scene.js';
import { WebXRCamera as WebXRCamera$1 } from '@babylonjs/core/XR/webXRCamera.js';
import { AdvancedDynamicTexture as AdvancedDynamicTexture$1 } from '@babylonjs/gui/2D/advancedDynamicTexture.js';
import { Button as Button$1 } from '@babylonjs/gui/2D/controls/button.js';
import { Checkbox as Checkbox$1 } from '@babylonjs/gui/2D/controls/checkbox.js';
import { ColorPicker as ColorPicker$1 } from '@babylonjs/gui/2D/controls/colorpicker.js';
import { Container as Container$1 } from '@babylonjs/gui/2D/controls/container.js';
import { Control as Control$1 } from '@babylonjs/gui/2D/controls/control.js';
import { DisplayGrid as DisplayGrid$1 } from '@babylonjs/gui/2D/controls/displayGrid.js';
import { Ellipse as Ellipse$1 } from '@babylonjs/gui/2D/controls/ellipse.js';
import { FocusableButton as FocusableButton$1 } from '@babylonjs/gui/2D/controls/focusableButton.js';
import { Grid as Grid$1 } from '@babylonjs/gui/2D/controls/grid.js';
import { Image as Image$1 } from '@babylonjs/gui/2D/controls/image.js';
import { InputPassword as InputPassword$1 } from '@babylonjs/gui/2D/controls/inputPassword.js';
import { InputText as InputText$1 } from '@babylonjs/gui/2D/controls/inputText.js';
import { Line as Line$1 } from '@babylonjs/gui/2D/controls/line.js';
import { MultiLine as MultiLine$1 } from '@babylonjs/gui/2D/controls/multiLine.js';
import { RadioButton as RadioButton$1 } from '@babylonjs/gui/2D/controls/radioButton.js';
import { Rectangle as Rectangle$1 } from '@babylonjs/gui/2D/controls/rectangle.js';
import { ScrollViewer as ScrollViewer$1 } from '@babylonjs/gui/2D/controls/scrollViewers/scrollViewer.js';
import { _ScrollViewerWindow as _ScrollViewerWindow$1 } from '@babylonjs/gui/2D/controls/scrollViewers/scrollViewerWindow.js';
import { SelectionPanel as SelectionPanel$1 } from '@babylonjs/gui/2D/controls/selector.js';
import { BaseSlider as BaseSlider$1 } from '@babylonjs/gui/2D/controls/sliders/baseSlider.js';
import { ImageBasedSlider as ImageBasedSlider$1 } from '@babylonjs/gui/2D/controls/sliders/imageBasedSlider.js';
import { ImageScrollBar as ImageScrollBar$1 } from '@babylonjs/gui/2D/controls/sliders/imageScrollBar.js';
import { ScrollBar as ScrollBar$1 } from '@babylonjs/gui/2D/controls/sliders/scrollBar.js';
import { Slider as Slider$1 } from '@babylonjs/gui/2D/controls/sliders/slider.js';
import { StackPanel as StackPanel$1 } from '@babylonjs/gui/2D/controls/stackPanel.js';
import { TextBlock as TextBlock$1 } from '@babylonjs/gui/2D/controls/textBlock.js';
import { ToggleButton as ToggleButton$1 } from '@babylonjs/gui/2D/controls/toggleButton.js';
import { VirtualKeyboard as VirtualKeyboard$1 } from '@babylonjs/gui/2D/controls/virtualKeyboard.js';
import { DefaultBehavior as DefaultBehavior$1 } from '@babylonjs/gui/3D/behaviors/defaultBehavior.js';
import { AbstractButton3D as AbstractButton3D$1 } from '@babylonjs/gui/3D/controls/abstractButton3D.js';
import { Button3D as Button3D$1 } from '@babylonjs/gui/3D/controls/button3D.js';
import { Container3D as Container3D$1 } from '@babylonjs/gui/3D/controls/container3D.js';
import { ContentDisplay3D as ContentDisplay3D$1 } from '@babylonjs/gui/3D/controls/contentDisplay3D.js';
import { Control3D as Control3D$1 } from '@babylonjs/gui/3D/controls/control3D.js';
import { CylinderPanel as CylinderPanel$1 } from '@babylonjs/gui/3D/controls/cylinderPanel.js';
import { HandMenu as HandMenu$1 } from '@babylonjs/gui/3D/controls/handMenu.js';
import { HolographicBackplate as HolographicBackplate$1 } from '@babylonjs/gui/3D/controls/holographicBackplate.js';
import { HolographicButton as HolographicButton$1 } from '@babylonjs/gui/3D/controls/holographicButton.js';
import { HolographicSlate as HolographicSlate$1 } from '@babylonjs/gui/3D/controls/holographicSlate.js';
import { MeshButton3D as MeshButton3D$1 } from '@babylonjs/gui/3D/controls/meshButton3D.js';
import { NearMenu as NearMenu$1 } from '@babylonjs/gui/3D/controls/nearMenu.js';
import { PlanePanel as PlanePanel$1 } from '@babylonjs/gui/3D/controls/planePanel.js';
import { ScatterPanel as ScatterPanel$1 } from '@babylonjs/gui/3D/controls/scatterPanel.js';
import { Slider3D as Slider3D$1 } from '@babylonjs/gui/3D/controls/slider3D.js';
import { SpherePanel as SpherePanel$1 } from '@babylonjs/gui/3D/controls/spherePanel.js';
import { StackPanel3D as StackPanel3D$1 } from '@babylonjs/gui/3D/controls/stackPanel3D.js';
import { TouchButton3D as TouchButton3D$1 } from '@babylonjs/gui/3D/controls/touchButton3D.js';
import { TouchHolographicButton as TouchHolographicButton$1 } from '@babylonjs/gui/3D/controls/touchHolographicButton.js';
import { TouchHolographicMenu as TouchHolographicMenu$1 } from '@babylonjs/gui/3D/controls/touchHolographicMenu.js';
import { TouchMeshButton3D as TouchMeshButton3D$1 } from '@babylonjs/gui/3D/controls/touchMeshButton3D.js';
import { VolumeBasedPanel as VolumeBasedPanel$1 } from '@babylonjs/gui/3D/controls/volumeBasedPanel.js';
import { SlateGizmo as SlateGizmo$1 } from '@babylonjs/gui/3D/gizmos/slateGizmo.js';
import { GUI3DManager as GUI3DManager$1 } from '@babylonjs/gui/3D/gui3DManager.js';
import { FluentMaterial as FluentMaterial$1 } from '@babylonjs/gui/3D/materials/fluent/fluentMaterial.js';
import { FluentBackplateMaterial as FluentBackplateMaterial$1 } from '@babylonjs/gui/3D/materials/fluentBackplate/fluentBackplateMaterial.js';
import { FluentButtonMaterial as FluentButtonMaterial$1 } from '@babylonjs/gui/3D/materials/fluentButton/fluentButtonMaterial.js';
import { HandleMaterial as HandleMaterial$1 } from '@babylonjs/gui/3D/materials/handle/handleMaterial.js';
import { MRDLBackplateMaterial as MRDLBackplateMaterial$1 } from '@babylonjs/gui/3D/materials/mrdl/mrdlBackplateMaterial.js';
import { MRDLSliderBarMaterial as MRDLSliderBarMaterial$1 } from '@babylonjs/gui/3D/materials/mrdl/mrdlSliderBarMaterial.js';
import { MRDLSliderThumbMaterial as MRDLSliderThumbMaterial$1 } from '@babylonjs/gui/3D/materials/mrdl/mrdlSliderThumbMaterial.js';
import { Color3, Color4 } from '@babylonjs/core/Maths/math.color.js';
import { VertexBuffer } from '@babylonjs/core/Meshes/buffer.js';
import { VertexData } from '@babylonjs/core/Meshes/mesh.vertexData.js';
import { Tools } from '@babylonjs/core/Misc/tools.js';
import { BoundingInfo } from '@babylonjs/core/Culling/boundingInfo.js';
import { Engine } from '@babylonjs/core/Engines/engine.js';
import { Observable } from '@babylonjs/core/Misc/observable.js';
import { AssetsManager } from '@babylonjs/core/Misc/assetsManager.js';
import { ActionManager } from '@babylonjs/core/Actions/actionManager.js';
import { ExecuteCodeAction } from '@babylonjs/core/Actions/directActions.js';
import Reconciler from 'react-reconciler';
import { InspectableType } from '@babylonjs/core/Misc/iInspectable.js';
import { ValueAndUnit } from '@babylonjs/gui/2D/valueAndUnit.js';
import { PointerEventTypes } from '@babylonjs/core/Events/pointerEvents.js';
import '@babylonjs/core/Physics/physicsEngineComponent.js';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var SceneContext = createContext({
    scene: null,
    sceneReady: false,
});
/**
 * Get the scene from the context.
 */
var useScene = function () { return useContext(SceneContext).scene; };

/**
 * Register a callback for before the scene renders.
 *
 * @param callback called using onBeforeRender functionality of scene
 * @param mask the mask used to filter observers
 * @param insertFirst if true will be inserted at first position, if false (default) will be last position.
 * @param callOnce only call the callback once
 */
var useBeforeRender = function (callback, mask, insertFirst, callOnce, deps) {
    if (deps === void 0) { deps = []; }
    var scene = useContext(SceneContext).scene;
    useEffect(function () {
        if (scene === null) {
            return;
        }
        var unregisterOnFirstCall = callOnce === true;
        var sceneObserver = scene.onBeforeRenderObservable.add(callback, mask, insertFirst, undefined, unregisterOnFirstCall);
        if (unregisterOnFirstCall !== true) {
            return function () {
                scene.onBeforeRenderObservable.remove(sceneObserver);
            };
        }
    }, __spreadArray([scene], deps, true));
};
/**
 * Register a callback for after the scene renders.
 *
 * @param callback called using onBeforeRender functionality of scene
 * @param mask the mask used to filter observers
 * @param insertFirst if true will be inserted at first position, if false (default) will be last position.
 * @param callOnce only call the callback once
 */
var useAfterRender = function (callback, mask, insertFirst, callOnce) {
    var scene = useContext(SceneContext).scene;
    useEffect(function () {
        if (scene === null) {
            return;
        }
        var unregisterOnFirstCall = callOnce === true;
        var sceneObserver = scene.onAfterRenderObservable.add(callback, mask, insertFirst, undefined, unregisterOnFirstCall);
        if (unregisterOnFirstCall !== true) {
            return function () {
                scene.onAfterRenderObservable.remove(sceneObserver);
            };
        }
    });
};

function defaultCalculatePosition(el, camera) {
    var objectPos = el.getAbsolutePosition();
    var engine = camera.getEngine();
    var viewport = camera.viewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
    var screenPos = Vector3.Project(objectPos, Matrix.Identity(), camera.getTransformationMatrix(), viewport);
    return [
        screenPos.x * engine.getHardwareScalingLevel(),
        screenPos.y * engine.getHardwareScalingLevel(),
    ];
}
function isObjectBehindCamera(el, camera) {
    var planes = Frustum.GetPlanes(camera.getTransformationMatrix());
    var center = el.absolutePosition;
    var outsideFrustum = planes.findIndex(function (x) { return x.dotCoordinate(center) < 0; }) === -1 ? false : true; // taken from : https://forum.babylonjs.com/t/check-if-vector3-is-in-frustum/8652/3
    return outsideFrustum;
}
function isObjectVisible(el, camera, occlude) {
    var _a, _b;
    var objectPos = el.getAbsolutePosition();
    var cameraPos = camera.globalPosition;
    var ray = new Ray(cameraPos, objectPos.subtract(cameraPos), undefined);
    var hit = camera
        .getScene()
        .pickWithRay(ray, function (m) {
        return (occlude.length > 0 ? occlude.indexOf(m) !== -1 : m !== el.parent) && m.name !== 'skybox';
    });
    // console.log(hit);
    return hit
        ? ((_a = hit.pickedMesh) === null || _a === void 0 ? void 0 : _a.name) === ((_b = el.parent) === null || _b === void 0 ? void 0 : _b.name) ||
            hit.distance * hit.distance >= Vector3.DistanceSquared(objectPos, cameraPos)
        : false;
}
function objectScale(el, camera) {
    if (camera.mode === Camera$1.ORTHOGRAPHIC_CAMERA) {
        return 1; //camera.zoom
    }
    else if (camera.mode === Camera$1.PERSPECTIVE_CAMERA) {
        var objectPos = el.getAbsolutePosition();
        var cameraPos = camera.globalPosition;
        var vFOV = (camera.fov * Math.PI) / 180;
        var dist = Vector3.Distance(objectPos, cameraPos);
        var scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
        return 1 / scaleFOV;
    }
    else {
        return 1;
    }
}
function objectZIndex(el, camera, zIndexRange) {
    if (camera.mode === Camera$1.PERSPECTIVE_CAMERA || camera.mode === Camera$1.ORTHOGRAPHIC_CAMERA) {
        var objectPos = el.getAbsolutePosition();
        var cameraPos = camera.globalPosition;
        var dist = Vector3.Distance(objectPos, cameraPos);
        var A = (zIndexRange[1] - zIndexRange[0]) / (camera.maxZ - camera.minZ);
        var B = zIndexRange[1] - A * camera.maxZ;
        return Math.round(A * dist + B);
    }
    return undefined;
}
var epsilon = function (value) { return (Math.abs(value) < 1e-10 ? 0 : value); };
function getCSSMatrix(matrix, multipliers, prepend) {
    if (prepend === void 0) { prepend = ''; }
    var matrix3d = 'matrix3d(';
    for (var i = 0; i !== 16; i++) {
        matrix3d += epsilon(multipliers[i] * matrix.m[i]) + (i !== 15 ? ',' : ')');
    }
    return prepend + matrix3d;
}
var getCameraCSSMatrix = (function (multipliers) {
    return function (matrix) { return getCSSMatrix(matrix, multipliers); };
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = (function (scaleMultipliers) {
    return function (matrix, factor) {
        return getCSSMatrix(matrix, scaleMultipliers(factor), 'translate(-50%,-50%)');
    };
})(function (f) { return [
    1 / f,
    1 / f,
    1 / f,
    1,
    -1 / f,
    -1 / f,
    -1 / f,
    -1,
    1 / f,
    1 / f,
    1 / f,
    1,
    1,
    1,
    1,
    1,
]; });
var Html = forwardRef(function (_a, ref) {
    var _b, _c, _d;
    var children = _a.children, babylonChildren = _a.babylonChildren, _e = _a.eps, eps = _e === void 0 ? 0.001 : _e, style = _a.style, className = _a.className, prepend = _a.prepend, center = _a.center, fullscreen = _a.fullscreen, portal = _a.portal, distanceFactor = _a.distanceFactor, _f = _a.sprite, sprite = _f === void 0 ? false : _f, _g = _a.transform, transform = _g === void 0 ? false : _g, occlude = _a.occlude, onOcclude = _a.onOcclude, _h = _a.zIndexRange, zIndexRange = _h === void 0 ? [16777271, 0] : _h, _j = _a.calculatePosition, calculatePosition = _j === void 0 ? defaultCalculatePosition : _j, _k = _a.as, as = _k === void 0 ? 'div' : _k, pointerEvents = _a.pointerEvents, props = __rest(_a, ["children", "babylonChildren", "eps", "style", "className", "prepend", "center", "fullscreen", "portal", "distanceFactor", "sprite", "transform", "occlude", "onOcclude", "zIndexRange", "calculatePosition", "as", "pointerEvents"]);
    var scene = useScene();
    var canvas = scene === null || scene === void 0 ? void 0 : scene.getEngine().getRenderingCanvas();
    var clientRect = scene === null || scene === void 0 ? void 0 : scene.getEngine().getRenderingCanvasClientRect();
    var size = { width: (_b = clientRect === null || clientRect === void 0 ? void 0 : clientRect.width) !== null && _b !== void 0 ? _b : 1, height: (_c = clientRect === null || clientRect === void 0 ? void 0 : clientRect.height) !== null && _c !== void 0 ? _c : 1 };
    var el = useState(function () { return document.createElement(as); })[0];
    var group = useRef(null);
    var oldZoom = useRef(0);
    var oldPosition = useRef([0, 0]);
    var transformOuterRef = useRef(null);
    var transformInnerRef = useRef(null);
    var target = (_d = portal === null || portal === void 0 ? void 0 : portal.current) !== null && _d !== void 0 ? _d : canvas === null || canvas === void 0 ? void 0 : canvas.parentNode;
    useEffect(function () {
        if (scene && group.current) {
            var node = group.current;
            var camera = scene === null || scene === void 0 ? void 0 : scene.activeCamera;
            if (camera && clientRect) {
                //scene.updateMatrixWorld()
                if (transform) {
                    el.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
                }
                else {
                    var vec = calculatePosition(node, camera);
                    el.style.cssText = "position:absolute;top:0;left:0;transform:translate3d(".concat(vec[0], "px,").concat(vec[1], "px,0);transform-origin:0 0;");
                }
                if (target) {
                    if (prepend)
                        target.prepend(el);
                    else
                        target.appendChild(el);
                }
            }
            return function () {
                if (target)
                    target.removeChild(el);
                unmountComponentAtNode(el);
            };
        }
    }, [target, transform, scene, group]);
    var styles = useMemo(function () {
        if (transform) {
            return {
                position: 'absolute',
                top: 0,
                left: 0,
                width: size.width,
                height: size.height,
                transformStyle: 'preserve-3d',
                pointerEvents: 'none',
            };
        }
        else {
            return __assign(__assign({ position: 'absolute', transform: center ? 'translate3d(-50%,-50%,0)' : 'none' }, (fullscreen && {
                top: -size.height / 2,
                left: -size.width / 2,
                width: size.width,
                height: size.height,
            })), style);
        }
    }, [style, center, fullscreen, size, transform]);
    var transformInnerStyles = useMemo(function () { return ({ position: 'absolute', pointerEvents: pointerEvents }); }, [pointerEvents]);
    useLayoutEffect(function () {
        if (transform) {
            render(React.createElement("div", { id: "html_babylon", ref: transformOuterRef, style: styles },
                React.createElement("div", { ref: transformInnerRef, style: transformInnerStyles },
                    React.createElement("div", { ref: ref, className: className, style: style, children: children }))), el);
        }
        else {
            render(React.createElement("div", { id: "html_babylon", ref: ref, style: styles, className: className, children: children }), el);
        }
    });
    var visible = useRef(true);
    useBeforeRender(function () {
        var camera = scene === null || scene === void 0 ? void 0 : scene.activeCamera;
        if (camera && group.current) {
            var node = group.current;
            node.computeWorldMatrix(true);
            var vec = transform ? oldPosition.current : calculatePosition(node, camera);
            el.style.display = visible.current && node.isEnabled(true) ? 'block' : 'none';
            if (isNaN(vec[0]) === false &&
                (transform ||
                    Math.abs(oldZoom.current - camera.fov) > eps ||
                    Math.abs(oldPosition.current[0] - vec[0]) > eps ||
                    Math.abs(oldPosition.current[1] - vec[1]) > eps)) {
                var isBehindCamera = isObjectBehindCamera(node, camera);
                var raytraceTarget = false;
                if (typeof occlude === 'boolean') {
                    if (occlude === true) {
                        raytraceTarget = scene === null || scene === void 0 ? void 0 : scene.meshes;
                    }
                }
                else if (Array.isArray(occlude)) {
                    raytraceTarget = occlude.map(function (item) { return item.current; });
                }
                var previouslyVisible = visible.current;
                if (raytraceTarget) {
                    var isvisible = isObjectVisible(node, camera, raytraceTarget);
                    visible.current = isvisible && !isBehindCamera;
                }
                else {
                    visible.current = !isBehindCamera;
                }
                if (previouslyVisible !== visible.current) {
                    if (onOcclude)
                        onOcclude(!visible.current);
                    else {
                        el.style.display = visible.current && node.isEnabled(true) ? 'block' : 'none';
                        group.current.isVisible = visible.current;
                    }
                }
                el.style.zIndex = "".concat(objectZIndex(node, camera, zIndexRange));
                if (transform) {
                    var _a = [size.width / 2, size.height / 2], widthHalf = _a[0], heightHalf = _a[1];
                    var fov = camera.getProjectionMatrix().m[5] * heightHalf;
                    var mode = camera.mode, orthoTop = camera.orthoTop, orthoLeft = camera.orthoLeft, orthoBottom = camera.orthoBottom, orthoRight = camera.orthoRight;
                    var cameraInvertMatrix = camera.getWorldMatrix().invert();
                    var cameraMatrix = getCameraCSSMatrix(cameraInvertMatrix);
                    var cameraTransform = mode === Camera$1.ORTHOGRAPHIC_CAMERA
                        ? "scale(".concat(fov, ")translate(").concat(epsilon(-(orthoRight + orthoLeft) / 2), "px,").concat(epsilon((orthoTop + orthoBottom) / 2), "px)")
                        : "translateZ(".concat(fov, "px)");
                    var matrix = node.getWorldMatrix();
                    if (sprite) {
                        matrix = camera.getViewMatrix().getRotationMatrix().invert().clone();
                        //   matrix = cameraInvertMatrix.clone().transpose().copy.copyPosition(matrix).scale(node.scale)
                        //   matrix.m[3] = matrix.m[7] = matrix.m[11] = 0
                        //   matrix.m[15] = 1
                    }
                    el.style.width = size.width + 'px';
                    el.style.height = size.height + 'px';
                    el.style.perspective = mode === Camera$1.ORTHOGRAPHIC_CAMERA ? '' : "".concat(fov, "px");
                    if (transformOuterRef.current && transformInnerRef.current) {
                        transformOuterRef.current.style.transform = "".concat(cameraTransform).concat(cameraMatrix, "translate(").concat(widthHalf, "px,").concat(heightHalf, "px)");
                        transformInnerRef.current.style.transform = getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400));
                    }
                }
                else {
                    var scale = distanceFactor === undefined ? 1 : objectScale(node, camera) * distanceFactor;
                    el.style.transform = "translate3d(".concat(vec[0], "px,").concat(vec[1], "px,0) scale(").concat(scale, ")");
                }
                oldPosition.current = vec;
                oldZoom.current = camera.fov;
            }
        }
    });
    return (React.createElement("abstractMesh", __assign({}, props, { ref: group }), babylonChildren));
});

// module Extensions {
var DynamicTerrain$1 = /** @class */ (function () {
    /**
     * constructor
     * @param name
     * @param options
     * @param scene
     * @param {*} mapData the array of the map 3D data : x, y, z successive float values
     * @param {*} mapSubX the data map number of x subdivisions : integer
     * @param {*} mapSubZ the data map number of z subdivisions : integer
     * @param {*} terrainSub the wanted terrain number of subdivisions : integer, multiple of 2.
     * @param {*} mapUVs the array of the map UV data (optional) : u,v successive values, each between 0 and 1.
     * @param {*} mapColors the array of the map Color data (optional) : x, y, z successive float values.
     * @param {*} mapNormals the array of the map normal data (optional) : r,g,b successive values, each between 0 and 1.
     * @param {*} invertSide boolean, to invert the terrain mesh upside down. Default false.
     * @param {*} camera the camera to link the terrain to. Optional, by default the scene active camera
     * @param {*} SPmapData an array of arrays or Float32Arrays (one per particle type) of object data (position, rotation, scaling) on the map. Optional.
     * @param {*} sps the Solid Particle System used to manage the particles. Required when used with SPmapData.
     * @param {*} SPcolorData an array of arrays or Float32Arrays (one per particle type) of object colors on the map. One series of r, g, b, a floats per object. Optional, requires a SPmapData and a sps to be passed.
     * @param {*} SPuvData an array of arrays or Float32Arrays (one per particle type) of object uvs on the map. One series of x, y, z, w floats per object. Optional, requires a SPmapData and a sps to be passed.
     */
    function DynamicTerrain(name, scene, options) {
        var _this = this;
        this._particleDataStride = 9; // data stride : position, rotation, scaling : 9 floats
        this._particleColorStride = 4; // color stride : color4 : r, g, b, a : 4 floats
        this._particleUVStride = 4; // uv stride : vector4 : x, y, z, w : 4 floats
        this._subToleranceX = 1 | 0; // hoSPcw many cells flought over thy the camera on the terrain x axis before update
        this._subToleranceZ = 1 | 0; // hoSPcw many cells flought over thy the camera on the terrain z axis before update
        this._LODLimits = []; // arSPcray of LOD limits
        this._initialLOD = 1 | 0; // inSPcitial LOD value (integer > 0)
        this._LODValue = 1 | 0; // cuSPcrrent LOD value : initial + camera correction
        this._cameraLODCorrection = 0 | 0; // LOSPcD correction (integer) according to the camera altitude
        this._LODPositiveX = true; // DoeSPcs LOD apply to the terrain right edge ?
        this._LODNegativeX = true; // DoeSPcs LOD apply to the terrain left edge ?
        this._LODPositiveZ = true; // DoeSPcs LOD apply to the terrain upper edge ?
        this._LODNegativeZ = true; // DoeSPcs LOD apply to the terrain lower edge ?
        this._inverted = false; // is the terrain mesh inverted upside down ?
        this.shiftFromCamera = {
            // terrain center shift from camera position
            x: 0.0,
            z: 0.0,
        };
        this._deltaSubX = 0 | 0; // map x subdivision delta : variation in number of map subdivisions
        this._deltaSubZ = 0 | 0; // map z subdivision delta
        this._refreshEveryFrame = false; // boolean : to force the terrain computation every frame
        this._useCustomVertexFunction = false; // boolean : to allow the call to updateVertex()
        this._computeNormals = false; // boolean : to skip or not the normal computation
        this._datamap = false; // boolean : true if an data map is passed as parameter
        this._uvmap = false; // boolean : true if an UV map is passed as parameter
        this._colormap = false; // boolean : true if an color map is passed as parameter
        this._mapSPData = false; // boolean : true if a SPmapData array is passed as parameter
        this._colorSPData = false; // boolean : true if a SPcolorData array is passed as parameter
        this._uvSPData = false; // boolean : true if a SPuvData array is passed as parameter
        this._averageSubSizeX = 0.0; // map cell average x size
        this._averageSubSizeZ = 0.0; // map cell average z size
        this._terrainSizeX = 0.0; // terrain x size
        this._terrainSizeZ = 0.0; // terrain y size
        this._terrainHalfSizeX = 0.0;
        this._terrainHalfSizeZ = 0.0;
        this._centerWorld = Vector3.Zero(); // terrain world center position
        this._centerLocal = Vector3.Zero(); // terrain local center position
        this._mapSizeX = 0.0; // map x size
        this._mapSizeZ = 0.0; // map z size
        this._isAlwaysVisible = false; // is the terrain mesh always selected for rendering
        this._precomputeNormalsFromMap = false; // if the normals must be precomputed from the map data when assigning a new map to the existing terrain
        this.name = name;
        options = options || {};
        this._terrainSub = options.terrainSub || 60;
        this._mapData = options.mapData;
        this._terrainIdx = this._terrainSub + 1;
        this._mapSubX = options.mapSubX || this._terrainIdx;
        this._mapSubZ = options.mapSubZ || this._terrainIdx;
        this._mapUVs = options.mapUVs; // if not defined, it will be still populated by default values
        this._mapColors = options.mapColors;
        this._scene = scene;
        this._terrainCamera = options.camera || scene.activeCamera;
        this._inverted = options.invertSide;
        this._SPmapData = options.SPmapData;
        this._SPcolorData = options.SPcolorData;
        this._SPuvData = options.SPuvData;
        this._sps = options.sps;
        // initialize the map arrays if not passed as parameters
        this._datamap = this._mapData ? true : false;
        this._uvmap = this._mapUVs ? true : false;
        this._colormap = this._mapColors ? true : false;
        this._mapSPData = this._SPmapData ? true : false;
        this._colorSPData = this._mapSPData && this._SPcolorData ? true : false;
        this._uvSPData = this._mapSPData && this._SPuvData ? true : false;
        this._mapData = this._datamap
            ? this._mapData
            : new Float32Array(this._terrainIdx * this._terrainIdx * 3);
        this._mapUVs = this._uvmap
            ? this._mapUVs
            : new Float32Array(this._terrainIdx * this._terrainIdx * 2);
        if (this._datamap) {
            this._mapNormals = options.mapNormals || new Float32Array(this._mapSubX * this._mapSubZ * 3);
        }
        else {
            this._mapNormals = new Float32Array(this._terrainIdx * this._terrainIdx * 3);
        }
        // Ribbon creation
        var index = 0; // current vertex index in the map array
        var posIndex = 0; // current position (coords) index in the map array
        var colIndex = 0; // current color index in the color array
        var uvIndex = 0; // current uv index in the uv array
        var color; // current color
        var uv; // current uv
        var terIndex = 0; // current index in the terrain array
        var y = 0.0; // current y coordinate
        var terrainPath; // current path
        var u = 0.0; // current u of UV
        var v = 0.0; // current v of UV
        var lg = this._terrainIdx + 1; // augmented length for the UV to finish before
        var terrainData = [];
        var terrainColor = [];
        var terrainUV = [];
        var mapData = this._mapData;
        var mapColors = this._mapColors;
        var mapUVs = this._mapUVs;
        for (var j = 0; j <= this._terrainSub; j++) {
            terrainPath = [];
            for (var i = 0; i <= this._terrainSub; i++) {
                index = this._mod(j * 3, this._mapSubZ) * this._mapSubX + this._mod(i * 3, this._mapSubX);
                posIndex = index * 3;
                colIndex = index * 3;
                uvIndex = index * 2;
                terIndex = j * this._terrainIdx + i;
                // geometry
                if (this._datamap) {
                    y = mapData[posIndex + 1];
                }
                else {
                    y = 0.0;
                    mapData[3 * terIndex] = i;
                    mapData[3 * terIndex + 1] = y;
                    mapData[3 * terIndex + 2] = j;
                }
                terrainPath.push(new Vector3(i, y, j));
                // color
                if (this._colormap) {
                    color = new Color4(mapColors[colIndex], mapColors[colIndex + 1], mapColors[colIndex + 2], 1.0);
                }
                else {
                    color = new Color4(1.0, 1.0, 1.0, 1.0);
                }
                terrainColor.push(color);
                // uvs
                if (this._uvmap) {
                    uv = new Vector2(mapUVs[uvIndex], mapUVs[uvIndex + 1]);
                }
                else {
                    u = 1.0 - Math.abs(1.0 - (2.0 * i) / lg);
                    v = 1.0 - Math.abs(1.0 - (2.0 * j) / lg);
                    mapUVs[2 * terIndex] = u;
                    mapUVs[2 * terIndex + 1] = v;
                    uv = new Vector2(u, v);
                }
                terrainUV.push(uv);
            }
            terrainData.push(terrainPath);
        }
        this._mapSizeX = Math.abs(mapData[(this._mapSubX - 1) * 3] - mapData[0]);
        this._mapSizeZ = Math.abs(mapData[(this._mapSubZ - 1) * this._mapSubX * 3 + 2] - mapData[2]);
        this._averageSubSizeX = this._mapSizeX / this._mapSubX;
        this._averageSubSizeZ = this._mapSizeZ / this._mapSubZ;
        var ribbonOptions = {
            pathArray: terrainData,
            sideOrientation: options.invertSide ? Mesh$1.FRONTSIDE : Mesh$1.BACKSIDE,
            colors: terrainColor,
            uvs: terrainUV,
            updatable: true,
        };
        this._terrain = MeshBuilder.CreateRibbon('terrain', ribbonOptions, this._scene);
        this._indices = this._terrain.getIndices();
        this._positions = this._terrain.getVerticesData(VertexBuffer.PositionKind);
        this._normals = this._terrain.getVerticesData(VertexBuffer.NormalKind);
        this._uvs = this._terrain.getVerticesData(VertexBuffer.UVKind);
        this._colors = this._terrain.getVerticesData(VertexBuffer.ColorKind);
        this.computeNormalsFromMap();
        // update it immediately and register the update callback function in the render loop
        this.update(true);
        this._terrain.position.x =
            this._terrainCamera.globalPosition.x - this._terrainHalfSizeX + this.shiftFromCamera.x;
        this._terrain.position.z =
            this._terrainCamera.globalPosition.z - this._terrainHalfSizeZ + this.shiftFromCamera.z;
        // initialize deltaSub to make on the map
        var deltaNbSubX = (this._terrain.position.x - mapData[0]) / this._averageSubSizeX;
        var deltaNbSubZ = (this._terrain.position.z - mapData[2]) / this._averageSubSizeZ;
        this._deltaSubX = deltaNbSubX > 0 ? Math.floor(deltaNbSubX) : Math.ceil(deltaNbSubX);
        this._deltaSubZ = deltaNbSubZ > 0 ? Math.floor(deltaNbSubZ) : Math.ceil(deltaNbSubZ);
        this._scene.onBeforeRenderObservable.add(function () {
            var refreshEveryFrame = _this._refreshEveryFrame;
            _this.beforeUpdate(refreshEveryFrame);
            _this.update(refreshEveryFrame);
            _this.afterUpdate(refreshEveryFrame);
        });
        // if SP data, populate the map quads
        // mapQuads[mapIndex][partType] = [partIdx1 , partIdx2 ...] partIdx are particle indexes in SPmapData
        var SPmapData = this._SPmapData;
        var dataStride = this._particleDataStride;
        if (this._mapSPData) {
            var mapSizeX = this._mapSizeX;
            var mapSizeZ = this._mapSizeZ;
            var mapSubX = this._mapSubX;
            var mapSubZ = this._mapSubZ;
            var quads = [];
            this._mapQuads = quads;
            var x0 = mapData[0];
            var z0 = mapData[2];
            for (var t = 0; t < SPmapData.length; t++) {
                var data = SPmapData[t];
                var nb = (data.length / dataStride) | 0;
                for (var pIdx = 0; pIdx < nb; pIdx++) {
                    // particle position x, z in the map
                    var dIdx = pIdx * dataStride;
                    var x = data[dIdx];
                    var z = data[dIdx + 2];
                    x = x - Math.floor((x - x0) / mapSizeX) * mapSizeX;
                    z = z - Math.floor((z - z0) / mapSizeZ) * mapSizeZ;
                    var col = Math.floor(((x - x0) * mapSubX) / mapSizeX);
                    var row = Math.floor(((z - z0) * mapSubZ) / mapSizeZ);
                    var quadIdx = row * mapSubX + col;
                    if (quads[quadIdx] === undefined) {
                        quads[quadIdx] = [];
                    }
                    if (quads[quadIdx][t] === undefined) {
                        quads[quadIdx][t] = [];
                    }
                    var quad = quads[quadIdx][t];
                    // push the particle index from the SPmapData array into the quads array
                    quad.push(pIdx);
                }
            }
            // update the sps
            var sps = this._sps;
            sps.computeBoundingBox = true;
            sps.isAlwaysVisible = true;
            if (this._colorSPData) {
                sps.computeParticleColor = true;
            }
            if (this._uvSPData) {
                sps.computeParticleTexture = true;
            }
            // store particle types
            var spsTypeStartIndexes = [];
            this._spsTypeStartIndexes = spsTypeStartIndexes;
            var spsNbPerType = [];
            this._spsNbPerType = spsNbPerType;
            var nbAvailablePerType = [];
            this._nbAvailablePerType = nbAvailablePerType;
            var nbParticles = sps.nbParticles;
            var particles = sps.particles;
            var type = 0;
            spsTypeStartIndexes.push(type);
            nbAvailablePerType.push(0);
            var count = 1;
            for (var p = 1; p < nbParticles; p++) {
                particles[p].isVisible = false;
                if (type != particles[p].shapeId) {
                    type++;
                    spsTypeStartIndexes.push(p);
                    spsNbPerType.push(count);
                    nbAvailablePerType.push(count);
                    count = 0;
                }
                count++;
            }
            spsNbPerType.push(count);
        }
        this.update(true); // recompute everything once the initial deltas are calculated
    }
    /**
     * Updates the terrain position and shape according to the camera position.
     * `force` : boolean, forces the terrain update even if no camera position change.
     * Returns the terrain.
     */
    DynamicTerrain.prototype.update = function (force) {
        var needsUpdate = false;
        var updateLOD = false;
        var updateForced = force ? true : false;
        var terrainPosition = this._terrain.position;
        var cameraPosition = this._terrainCamera.globalPosition;
        var shiftFromCamera = this.shiftFromCamera;
        var terrainHalfSizeX = this._terrainHalfSizeX;
        var terrainHalfSizeZ = this._terrainHalfSizeZ;
        var deltaX = terrainHalfSizeX + terrainPosition.x - cameraPosition.x - shiftFromCamera.x;
        var deltaZ = terrainHalfSizeZ + terrainPosition.z - cameraPosition.z - shiftFromCamera.z;
        var subToleranceX = this._subToleranceX;
        var subToleranceZ = this._subToleranceZ;
        var mod = this._mod;
        // current LOD
        var oldCorrection = this._cameraLODCorrection;
        this._cameraLODCorrection = this.updateCameraLOD(this._terrainCamera) | 0;
        updateLOD = oldCorrection == this._cameraLODCorrection ? false : true;
        var LODValue = this._initialLOD + this._cameraLODCorrection;
        LODValue = LODValue > 0 ? LODValue : 1;
        this._LODValue = LODValue;
        // threshold sizes on each axis to trigger the terrain update
        var mapShiftX = this._averageSubSizeX * subToleranceX * LODValue;
        var mapShiftZ = this._averageSubSizeZ * subToleranceZ * LODValue;
        var mapFlgtNb = 0 | 0; // number of map cells flought over by the camera in the delta shift
        var deltaSubX = this._deltaSubX;
        var deltaSubZ = this._deltaSubZ;
        if (Math.abs(deltaX) > mapShiftX) {
            var signX = deltaX > 0.0 ? -1 : 1;
            mapFlgtNb = Math.abs(deltaX / mapShiftX) | 0;
            terrainPosition.x += mapShiftX * signX * mapFlgtNb;
            deltaSubX += subToleranceX * signX * LODValue * mapFlgtNb;
            needsUpdate = true;
        }
        if (Math.abs(deltaZ) > mapShiftZ) {
            var signZ = deltaZ > 0.0 ? -1 : 1;
            mapFlgtNb = Math.abs(deltaZ / mapShiftZ) | 0;
            terrainPosition.z += mapShiftZ * signZ * mapFlgtNb;
            deltaSubZ += subToleranceZ * signZ * LODValue * mapFlgtNb;
            needsUpdate = true;
        }
        var updateSize = updateLOD || updateForced; // must the terrain size be updated ?
        if (needsUpdate || updateSize) {
            this._deltaSubX = mod(deltaSubX, this._mapSubX);
            this._deltaSubZ = mod(deltaSubZ, this._mapSubZ);
            this._updateTerrain(updateSize);
        }
        terrainHalfSizeX = this._terrainHalfSizeX;
        terrainHalfSizeZ = this._terrainHalfSizeZ;
        this.centerLocal.copyFromFloats(terrainHalfSizeX, 0.0, terrainHalfSizeZ);
        this._centerWorld.copyFromFloats(terrainPosition.x + terrainHalfSizeX, terrainPosition.y, terrainPosition.z + terrainHalfSizeZ);
        return this;
    };
    // private : updates the underlying ribbon
    DynamicTerrain.prototype._updateTerrain = function (updateSize) {
        var stepJ = 0 | 0;
        var stepI = 0 | 0;
        var LODLimitDown = 0 | 0;
        var LODLimitUp = 0 | 0;
        var LODValue = this._LODValue; // terrain LOD value
        var axisLODValue = LODValue; // current axis computed LOD value
        var lodI = LODValue; // LOD X
        var lodJ = LODValue; // LOD Z
        var bbMin = DynamicTerrain._bbMin;
        var bbMax = DynamicTerrain._bbMax;
        var terrain = this._terrain;
        var positions = this._positions;
        var normals = this._normals;
        var colors = this._colors;
        var uvs = this._uvs;
        var mapColors = this._mapColors;
        var mapNormals = this._mapNormals;
        var mapData = this._mapData;
        var mapUVs = this._mapUVs;
        var mapSPData = this._mapSPData;
        var quads = this._mapQuads;
        var nbPerType = this._spsNbPerType;
        var SPmapData = this._SPmapData;
        var SPcolorData = this._SPcolorData;
        var SPuvData = this._SPuvData;
        var dataStride = this._particleDataStride;
        var colorStride = this._particleColorStride;
        var uvStride = this._particleUVStride;
        var LODLimits = this._LODLimits;
        var terrainSub = this._terrainSub;
        var mod = this._mod;
        var terrainIdx = this._terrainIdx;
        var mapSubX = this._mapSubX;
        var mapSubZ = this._mapSubZ;
        var deltaSubX = this._deltaSubX;
        var deltaSubZ = this._deltaSubZ;
        var datamap = this._datamap;
        var uvmap = this._uvmap;
        var colormap = this._colormap;
        var useCustomVertexFunction = this._useCustomVertexFunction;
        var updateVertex = this.updateVertex;
        var dontComputeNormals = !this._computeNormals;
        var LODpstvX = this._LODPositiveX;
        var LODngtvX = this._LODNegativeX;
        var LODpstvZ = this._LODPositiveZ;
        var LODngtvZ = this._LODNegativeZ;
        var mapSizeX = this._mapSizeX;
        var mapSizeZ = this._mapSizeZ;
        var averageSubSizeX = this._averageSubSizeX;
        var averageSubSizeZ = this._averageSubSizeZ;
        var particleMap = mapSPData && quads;
        var particleColorMap = particleMap && this._colorSPData;
        var particleUVMap = particleMap && this._uvSPData;
        var l = 0 | 0;
        var index = 0 | 0; // current vertex index in the map data array
        var posIndex1 = 0 | 0; // current position index in the map data array
        var posIndex2 = 0 | 0;
        var posIndex3 = 0 | 0;
        var colIndex = 0 | 0; // current index in the map color array
        var uvIndex = 0 | 0; // current index in the map uv array
        var terIndex = 0 | 0; // current vertex index in the terrain map array when used as a data map
        var ribbonInd = 0 | 0; // current ribbon vertex index
        var ribbonPosInd = 0 | 0; // current ribbon position index (same than normal index)
        var ribbonUVInd = 0 | 0; // current ribbon UV index
        var ribbonColInd = 0 | 0; // current ribbon color index
        var ribbonColInd1 = 0 | 0;
        var ribbonColInd2 = 0 | 0;
        var ribbonColInd3 = 0 | 0;
        var ribbonColInd4 = 0 | 0;
        var ribbonPosInd1 = 0 | 0;
        var ribbonPosInd2 = 0 | 0;
        var ribbonPosInd3 = 0 | 0;
        // note : all the indexes are explicitly set as integers for the js optimizer (store them all in the stack)
        if (updateSize) {
            this.updateTerrainSize();
        }
        Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, bbMin);
        Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, bbMax);
        if (particleMap) {
            var sps = this._sps;
            var particles = sps.particles;
            var spsTypeStartIndexes = this._spsTypeStartIndexes;
            var nbAvailablePerType = this._nbAvailablePerType;
            var x0 = mapData[0];
            var z0 = mapData[2];
            var terrainPos = terrain.position;
            // reset all the particles to invisible
            var nbParticles = sps.nbParticles;
            for (var p = 0; p < nbParticles; p++) {
                particles[p].isVisible = false;
            }
        }
        for (var j = 0 | 0; j <= terrainSub; j++) {
            // LOD Z
            axisLODValue = LODValue;
            for (l = 0; l < LODLimits.length; l++) {
                LODLimitDown = LODLimits[l];
                LODLimitUp = terrainSub - LODLimitDown - 1;
                if ((LODngtvZ && j < LODLimitDown) || (LODpstvZ && j > LODLimitUp)) {
                    axisLODValue = l + 1 + LODValue;
                }
                lodJ = axisLODValue;
            }
            for (var i = 0 | 0; i <= terrainSub; i++) {
                // LOD X
                axisLODValue = LODValue;
                for (l = 0; l < LODLimits.length; l++) {
                    LODLimitDown = LODLimits[l];
                    LODLimitUp = terrainSub - LODLimitDown - 1;
                    if ((LODngtvX && i < LODLimitDown) || (LODpstvX && i > LODLimitUp)) {
                        axisLODValue = l + 1 + LODValue;
                    }
                    lodI = axisLODValue;
                }
                // map current index
                index = mod(deltaSubZ + stepJ, mapSubZ) * mapSubX + mod(deltaSubX + stepI, mapSubX);
                terIndex =
                    mod(deltaSubZ + stepJ, terrainIdx) * terrainIdx + mod(deltaSubX + stepI, terrainIdx);
                // related index in the array of positions (data map)
                if (datamap) {
                    posIndex1 = 3 * index;
                }
                else {
                    posIndex1 = 3 * terIndex;
                }
                // related index in the UV map
                if (uvmap) {
                    uvIndex = 2 * index;
                }
                else {
                    uvIndex = 2 * terIndex;
                }
                // related index in the color map
                if (colormap) {
                    colIndex = 3 * index;
                }
                else {
                    colIndex = 3 * terIndex;
                }
                //map indexes
                posIndex2 = posIndex1 + 1;
                posIndex3 = posIndex1 + 2;
                // ribbon indexes
                ribbonPosInd = 3 * ribbonInd;
                ribbonColInd = 4 * ribbonInd;
                ribbonUVInd = 2 * ribbonInd;
                ribbonPosInd1 = ribbonPosInd;
                ribbonPosInd2 = ribbonPosInd + 1;
                ribbonPosInd3 = ribbonPosInd + 2;
                ribbonColInd1 = ribbonColInd;
                ribbonColInd2 = ribbonColInd + 1;
                ribbonColInd3 = ribbonColInd + 2;
                ribbonColInd4 = ribbonColInd + 3;
                ribbonInd += 1;
                // geometry
                positions[ribbonPosInd1] = averageSubSizeX * stepI;
                positions[ribbonPosInd2] = mapData[posIndex2];
                positions[ribbonPosInd3] = averageSubSizeZ * stepJ;
                if (dontComputeNormals) {
                    normals[ribbonPosInd1] = mapNormals[posIndex1];
                    normals[ribbonPosInd2] = mapNormals[posIndex2];
                    normals[ribbonPosInd3] = mapNormals[posIndex3];
                }
                // bbox internal update
                if (positions[ribbonPosInd1] < bbMin.x) {
                    bbMin.x = positions[ribbonPosInd1];
                }
                if (positions[ribbonPosInd1] > bbMax.x) {
                    bbMax.x = positions[ribbonPosInd1];
                }
                if (positions[ribbonPosInd2] < bbMin.y) {
                    bbMin.y = positions[ribbonPosInd2];
                }
                if (positions[ribbonPosInd2] > bbMax.y) {
                    bbMax.y = positions[ribbonPosInd2];
                }
                if (positions[ribbonPosInd3] < bbMin.z) {
                    bbMin.z = positions[ribbonPosInd3];
                }
                if (positions[ribbonPosInd3] > bbMax.z) {
                    bbMax.z = positions[ribbonPosInd3];
                }
                // color
                if (colormap) {
                    colors[ribbonColInd1] = mapColors[colIndex];
                    colors[ribbonColInd2] = mapColors[colIndex + 1];
                    colors[ribbonColInd3] = mapColors[colIndex + 2];
                }
                // uv : the array _mapUVs is always populated
                uvs[ribbonUVInd] = mapUVs[uvIndex];
                uvs[ribbonUVInd + 1] = mapUVs[uvIndex + 1];
                // call to user custom function with the current updated vertex object
                if (useCustomVertexFunction) {
                    var vertex = DynamicTerrain._vertex;
                    var vertexPosition = vertex.position;
                    var vertexWorldPosition = vertex.worldPosition;
                    var vertexColor = vertex.color;
                    var vertexUvs = vertex.uvs;
                    vertexPosition.copyFromFloats(positions[ribbonPosInd1], positions[ribbonPosInd2], positions[ribbonPosInd3]);
                    vertexWorldPosition.copyFromFloats(mapData[posIndex1], vertexPosition.y, mapData[posIndex3]);
                    vertex.lodX = lodI;
                    vertex.lodZ = lodJ;
                    vertexColor.copyFromFloats(colors[ribbonColInd1], colors[ribbonColInd2], colors[ribbonColInd3], colors[ribbonColInd4]);
                    vertexUvs.copyFromFloats(uvs[ribbonUVInd], uvs[ribbonUVInd + 1]);
                    vertex.mapIndex = index;
                    updateVertex(vertex, i, j); // the user can modify the array values here
                    colors[ribbonColInd1] = vertexColor.r;
                    colors[ribbonColInd2] = vertexColor.g;
                    colors[ribbonColInd3] = vertexColor.b;
                    colors[ribbonColInd4] = vertexColor.a;
                    uvs[ribbonUVInd] = vertexUvs.x;
                    uvs[ribbonUVInd + 1] = vertexUvs.y;
                    positions[ribbonPosInd1] = vertexPosition.x;
                    positions[ribbonPosInd2] = vertexPosition.y;
                    positions[ribbonPosInd3] = vertexPosition.z;
                }
                // SPS management
                if (particleMap) {
                    var quad = quads[index];
                    if (quad) {
                        // if a quad contains some particles in the map
                        for (var t = 0; t < quad.length; t++) {
                            var data = SPmapData[t];
                            var partIndexes = quad[t];
                            if (particleColorMap) {
                                var sp_colorData = SPcolorData[t];
                            }
                            if (particleUVMap) {
                                var sp_uvData = SPuvData[t];
                            }
                            if (partIndexes) {
                                var typeStartIndex = spsTypeStartIndexes[t]; // particle start index for a given type in the SPS
                                var nbQuadParticles = partIndexes.length;
                                var nbInSPS = nbPerType[t];
                                var available = nbAvailablePerType[t];
                                var rem = nbInSPS - available;
                                var used = rem > 0 ? rem : 0;
                                var min = available < nbQuadParticles ? available : nbQuadParticles; // don't iterate beyond possible
                                for (var pIdx = 0; pIdx < min; pIdx++) {
                                    var px = partIndexes[pIdx];
                                    var idm = px * dataStride;
                                    // set successive available particles of this type
                                    var particle = particles[typeStartIndex + pIdx + used];
                                    var pos = particle.position;
                                    var rot = particle.rotation;
                                    var scl = particle.scaling;
                                    var x = data[idm];
                                    pos.x = x + Math.floor((terrainPos.x - x - x0) / mapSizeX) * mapSizeX;
                                    pos.y = data[idm + 1];
                                    var z = data[idm + 2];
                                    pos.z = z + Math.floor((terrainPos.z - z - z0) / mapSizeZ) * mapSizeZ;
                                    rot.x = data[idm + 3];
                                    rot.y = data[idm + 4];
                                    rot.z = data[idm + 5];
                                    scl.x = data[idm + 6];
                                    scl.y = data[idm + 7];
                                    scl.z = data[idm + 8];
                                    if (particleColorMap) {
                                        var idc = px * colorStride;
                                        var col = particle.color;
                                        col.r = sp_colorData[idc];
                                        col.g = sp_colorData[idc + 1];
                                        col.b = sp_colorData[idc + 2];
                                        col.a = sp_colorData[idc + 3];
                                    }
                                    if (particleUVMap) {
                                        var iduv = px * uvStride;
                                        var uvs_1 = particle.uvs;
                                        uvs_1.x = sp_uvData[iduv];
                                        uvs_1.y = sp_uvData[iduv + 1];
                                        uvs_1.z = sp_uvData[iduv + 2];
                                        uvs_1.w = sp_uvData[iduv + 3];
                                    }
                                    particle.isVisible = true;
                                    available = available - 1;
                                    used = used + 1;
                                    min = available < nbQuadParticles ? available : nbQuadParticles;
                                }
                                available = available > 0 ? available : 0;
                                nbAvailablePerType[t] = available;
                            }
                        }
                    }
                }
                stepI += lodI;
            }
            stepI = 0;
            stepJ += lodJ;
        }
        if (particleMap) {
            sps.setParticles();
            for (var c = 0; c < nbAvailablePerType.length; c++) {
                nbAvailablePerType[c] = nbPerType[c];
            }
        }
        // ribbon update
        terrain.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
        if (this._computeNormals) {
            VertexData.ComputeNormals(positions, this._indices, normals);
        }
        terrain.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
        terrain.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);
        terrain.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);
        terrain._boundingInfo.reConstruct(bbMin, bbMax, terrain._worldMatrix);
    };
    // private modulo, for dealing with negative indexes
    DynamicTerrain.prototype._mod = function (a, b) {
        return ((a % b) + b) % b;
    };
    /**
     * Updates the mesh terrain size according to the LOD limits and the camera position.
     * Returns the terrain.
     */
    DynamicTerrain.prototype.updateTerrainSize = function () {
        var remainder = this._terrainSub; // the remaining cells at the general current LOD value
        var nb = 0 | 0; // nb of cells in the current LOD limit interval
        var next = 0 | 0; // next cell index, if it exists
        var LODValue = this._LODValue;
        var lod = LODValue + 1; // lod value in the current LOD limit interval
        var tsx = 0.0; // current sum of cell sizes on x
        var tsz = 0.0; // current sum of cell sizes on z
        var LODLimits = this._LODLimits;
        var averageSubSizeX = this._averageSubSizeX;
        var averageSubSizeZ = this._averageSubSizeZ;
        for (var l = 0 | 0; l < LODLimits.length; l++) {
            lod = LODValue + l + 1;
            next = l >= LODLimits.length - 1 ? 0 : LODLimits[l + 1];
            nb = 2 * (LODLimits[l] - next);
            tsx += averageSubSizeX * lod * nb;
            tsz += averageSubSizeZ * lod * nb;
            remainder -= nb;
        }
        tsx += remainder * averageSubSizeX * LODValue;
        tsz += remainder * averageSubSizeZ * LODValue;
        this._terrainSizeX = tsx;
        this._terrainSizeZ = tsz;
        this._terrainHalfSizeX = tsx * 0.5;
        this._terrainHalfSizeZ = tsz * 0.5;
        return this;
    };
    /**
     * Returns the altitude (float) at the coordinates (x, z) of the map.
     * @param x
     * @param z
     * @param {normal: Vector3} (optional)
     * If the optional object {normal: Vector3} is passed, then its property "normal" is updated with the normal vector value at the coordinates (x, z).
     */
    DynamicTerrain.prototype.getHeightFromMap = function (x, z, options) {
        return DynamicTerrain._GetHeightFromMap(x, z, this._mapData, this._mapSubX, this._mapSubZ, this._mapSizeX, this._mapSizeZ, options, this._inverted);
    };
    /**
     * Static : Returns the altitude (float) at the coordinates (x, z) of the passed map.
     * @param x
     * @param z
     * @param mapSubX the number of points along the map width
     * @param mapSubX the number of points along the map height
     * @param {normal: Vector3} (optional)
     * @param inverted (optional boolean) is the terrain inverted
     * If the optional object {normal: Vector3} is passed, then its property "normal" is updated with the normal vector value at the coordinates (x, z).
     */
    DynamicTerrain.GetHeightFromMap = function (x, z, mapData, mapSubX, mapSubZ, options, inverted) {
        var mapSizeX = Math.abs(mapData[(mapSubX - 1) * 3] - mapData[0]);
        var mapSizeZ = Math.abs(mapData[(mapSubZ - 1) * mapSubX * 3 + 2] - mapData[2]);
        return DynamicTerrain._GetHeightFromMap(x, z, mapData, mapSubX, mapSubZ, mapSizeX, mapSizeZ, options, inverted);
    };
    // Computes the height and optionnally the normal at the coordinates (x ,z) from the passed map
    DynamicTerrain._GetHeightFromMap = function (x, z, mapData, mapSubX, mapSubZ, mapSizeX, mapSizeZ, options, inverted) {
        var x0 = mapData[0];
        var z0 = mapData[2];
        // reset x and z in the map space so they are between 0 and the map size
        x = x - Math.floor((x - x0) / mapSizeX) * mapSizeX;
        z = z - Math.floor((z - z0) / mapSizeZ) * mapSizeZ;
        var col1 = Math.floor(((x - x0) * mapSubX) / mapSizeX);
        var row1 = Math.floor(((z - z0) * mapSubZ) / mapSizeZ);
        var col2 = (col1 + 1) % mapSubX;
        var row2 = (row1 + 1) % mapSubZ;
        // starting indexes of the positions of 4 vertices defining a quad on the map
        var idx1 = 3 * (row1 * mapSubX + col1);
        var idx2 = 3 * (row1 * mapSubX + col2);
        var idx3 = 3 * (row2 * mapSubX + col1);
        var idx4 = 3 * (row2 * mapSubX + col2);
        var v1 = DynamicTerrain._v1;
        var v2 = DynamicTerrain._v2;
        var v3 = DynamicTerrain._v3;
        var v4 = DynamicTerrain._v4;
        v1.copyFromFloats(mapData[idx1], mapData[idx1 + 1], mapData[idx1 + 2]);
        v2.copyFromFloats(mapData[idx2], mapData[idx2 + 1], mapData[idx2 + 2]);
        v3.copyFromFloats(mapData[idx3], mapData[idx3 + 1], mapData[idx3 + 2]);
        v4.copyFromFloats(mapData[idx4], mapData[idx4 + 1], mapData[idx4 + 2]);
        var vAvB = DynamicTerrain._vAvB;
        var vAvC = DynamicTerrain._vAvC;
        var norm = DynamicTerrain._norm;
        var vA = v1;
        var vB;
        var vC;
        var v;
        var xv4v1 = v4.x - v1.x;
        var zv4v1 = v4.z - v1.z;
        if (xv4v1 == 0 || zv4v1 == 0) {
            return v1.y;
        }
        var cd = zv4v1 / xv4v1;
        var h = v1.z - cd * v1.x;
        if (z < cd * x + h) {
            vB = v4;
            vC = v2;
            v = vA;
        }
        else {
            vB = v3;
            vC = v4;
            v = vB;
        }
        vB.subtractToRef(vA, vAvB);
        vC.subtractToRef(vA, vAvC);
        Vector3.CrossToRef(vAvB, vAvC, norm);
        norm.normalize();
        if (inverted) {
            norm.scaleInPlace(-1.0);
        }
        if (options && options.normal) {
            options.normal.copyFrom(norm);
        }
        var d = -(norm.x * v.x + norm.y * v.y + norm.z * v.z);
        var y = v.y;
        if (norm.y != 0.0) {
            y = -(norm.x * x + norm.z * z + d) / norm.y;
        }
        return y;
    };
    /**
     * Static : Computes all the normals from the terrain data map  and stores them in the passed Float32Array reference.
     * This passed array must have the same size than the mapData array.
     */
    DynamicTerrain.ComputeNormalsFromMapToRef = function (mapData, mapSubX, mapSubZ, normals, inverted) {
        var mapIndices = [];
        var tmp1 = { normal: Vector3.Zero() };
        var tmp2 = { normal: Vector3.Zero() };
        var normal1 = tmp1.normal;
        var normal2 = tmp2.normal;
        var l = mapSubX * (mapSubZ - 1);
        var i = 0;
        for (i = 0; i < l; i++) {
            mapIndices.push(i + 1, i + mapSubX, i);
            mapIndices.push(i + mapSubX, i + 1, i + mapSubX + 1);
        }
        VertexData.ComputeNormals(mapData, mapIndices, normals);
        // seam process
        var lastIdx = (mapSubX - 1) * 3;
        var colStart = 0;
        var colEnd = 0;
        var getHeightFromMap = DynamicTerrain.GetHeightFromMap;
        for (i = 0; i < mapSubZ; i++) {
            colStart = i * mapSubX * 3;
            colEnd = colStart + lastIdx;
            getHeightFromMap(mapData[colStart], mapData[colStart + 2], mapData, mapSubX, mapSubZ, tmp1);
            getHeightFromMap(mapData[colEnd], mapData[colEnd + 2], mapData, mapSubX, mapSubZ, tmp2);
            normal1.addInPlace(normal2).scaleInPlace(0.5);
            normals[colStart] = normal1.x;
            normals[colStart + 1] = normal1.y;
            normals[colStart + 2] = normal1.z;
            normals[colEnd] = normal1.x;
            normals[colEnd + 1] = normal1.y;
            normals[colEnd + 2] = normal1.z;
        }
        // inverted terrain
        if (inverted) {
            for (i = 0; i < normals.length; i++) {
                normals[i] = -normals[i];
            }
        }
    };
    /**
     * Computes all the map normals from the current terrain data map and sets them to the terrain.
     * Returns the terrain.
     */
    DynamicTerrain.prototype.computeNormalsFromMap = function () {
        DynamicTerrain.ComputeNormalsFromMapToRef(this._mapData, this._mapSubX, this._mapSubZ, this._mapNormals, this._inverted);
        return this;
    };
    /**
     * Returns true if the World coordinates (x, z) are in the current terrain.
     * @param x
     * @param z
     */
    DynamicTerrain.prototype.contains = function (x, z) {
        var positions = this._positions;
        var meshPosition = this.mesh.position;
        var terrainIdx = this._terrainIdx;
        if (x < positions[0] + meshPosition.x || x > positions[3 * terrainIdx] + meshPosition.x) {
            return false;
        }
        if (z < positions[2] + meshPosition.z ||
            z > positions[3 * terrainIdx * terrainIdx + 2] + meshPosition.z) {
            return false;
        }
        return true;
    };
    /**
           * Static : Returns a new data map from the passed heightmap image file.
           The parameters `width` and `height` (positive floats, default 300) set the map width and height sizes.
          * `subX` is the wanted number of points along the map width (default 100).
          * `subZ` is the wanted number of points along the map height (default 100).
          * The parameter `minHeight` (float, default 0) is the minimum altitude of the map.
          * The parameter `maxHeight` (float, default 1) is the maximum altitude of the map.
          * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
          * `onReady` is an optional callback function, called once the map is computed. It's passed the computed map.
          * `scene` is the Scene object whose database will store the downloaded image.
          */
    DynamicTerrain.CreateMapFromHeightMap = function (heightmapURL, options, scene) {
        var subX = options.subX || 100;
        var subZ = options.subZ || 100;
        var data = new Float32Array(subX * subZ * 3);
        DynamicTerrain.CreateMapFromHeightMapToRef(heightmapURL, options, data, scene);
        return data;
    };
    /**
     * Static : Updates the passed array or Float32Array with a data map computed from the passed heightmap image file.
     *  The parameters `width` and `height` (positive floats, default 300) set the map width and height sizes.
     * `subX` is the wanted number of points along the map width (default 100).
     * `subZ` is the wanted number of points along the map height (default 100).
     * The parameter `minHeight` (float, default 0) is the minimum altitude of the map.
     * The parameter `maxHeight` (float, default 1) is the maximum altitude of the map.
     * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
     * `onReady` is an optional callback function, called once the map is computed. It's passed the computed map.
     * `scene` is the Scene object whose database will store the downloaded image.
     * The passed Float32Array must be the right size : 3 x subX x subZ.
     */
    DynamicTerrain.CreateMapFromHeightMapToRef = function (heightmapURL, options, data, scene) {
        var width = options.width || 300;
        var height = options.height || 300;
        var subX = options.subX || 100;
        var subZ = options.subZ || 100;
        var minHeight = options.minHeight || 0.0;
        var maxHeight = options.maxHeight || 10.0;
        var offsetX = options.offsetX || 0.0;
        var offsetZ = options.offsetZ || 0.0;
        var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
        var onReady = options.onReady;
        var onload = function (img) {
            // Getting height map data
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            var bufferWidth = img.width;
            var bufferHeight = img.height;
            canvas.width = bufferWidth;
            canvas.height = bufferHeight;
            context.drawImage(img, 0, 0);
            // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949
            var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
            var x = 0.0;
            var y = 0.0;
            var z = 0.0;
            for (var row = 0; row < subZ; row++) {
                for (var col = 0; col < subX; col++) {
                    x = (col * width) / subX - width * 0.5;
                    z = (row * height) / subZ - height * 0.5;
                    var heightmapX = (((x + width * 0.5) / width) * (bufferWidth - 1)) | 0;
                    var heightmapY = (bufferHeight - 1 - ((z + height * 0.5) / height) * (bufferHeight - 1)) | 0;
                    var pos = (heightmapX + heightmapY * bufferWidth) * 4;
                    var gradient = (buffer[pos] * filter.r + buffer[pos + 1] * filter.g + buffer[pos + 2] * filter.b) /
                        255.0;
                    y = minHeight + (maxHeight - minHeight) * gradient;
                    var idx = (row * subX + col) * 3;
                    data[idx] = x + offsetX;
                    data[idx + 1] = y;
                    data[idx + 2] = z + offsetZ;
                }
            }
            // callback function if any
            if (onReady) {
                onReady(data, subX, subZ);
            }
        };
        Tools.LoadImage(heightmapURL, onload, function () { }, scene.offlineProvider);
    };
    /**
     * Static : Updates the passed arrays with UVs values to fit the whole map with subX points along its width and subZ points along its height.
     * The passed array must be the right size : subX x subZ x 2.
     */
    DynamicTerrain.CreateUVMapToRef = function (subX, subZ, mapUVs) {
        for (var h = 0; h < subZ; h++) {
            for (var w = 0; w < subX; w++) {
                mapUVs[(h * subX + w) * 2] = w / subX;
                mapUVs[(h * subX + w) * 2 + 1] = h / subZ;
            }
        }
    };
    /**
     * Static : Returns a new UV array with values to fit the whole map with subX points along its width and subZ points along its height.
     */
    DynamicTerrain.CreateUVMap = function (subX, subZ) {
        var mapUVs = new Float32Array(subX * subZ * 2);
        DynamicTerrain.CreateUVMapToRef(subX, subZ, mapUVs);
        return mapUVs;
    };
    /**
     * Computes and sets the terrain UV map with values to fit the whole map.
     * Returns the terrain.
     */
    DynamicTerrain.prototype.createUVMap = function () {
        this.mapUVs = DynamicTerrain.CreateUVMap(this._mapSubX, this._mapSubZ);
        return this;
    };
    Object.defineProperty(DynamicTerrain.prototype, "refreshEveryFrame", {
        // Getters / Setters
        /**
         * boolean : if the terrain must be recomputed every frame.
         */
        get: function () {
            return this._refreshEveryFrame;
        },
        set: function (val) {
            this._refreshEveryFrame = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mesh", {
        /**
         * Mesh : the logical terrain underlying mesh
         */
        get: function () {
            return this._terrain;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "camera", {
        /**
         * The camera the terrain is linked to
         */
        get: function () {
            return this._terrainCamera;
        },
        set: function (val) {
            this._terrainCamera = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "subToleranceX", {
        /**
         * Number of cells flought over by the cam on the X axis before the terrain is updated.
         * Integer greater or equal to 1.
         */
        get: function () {
            return this._subToleranceX;
        },
        set: function (val) {
            this._subToleranceX = val > 0 ? val : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "subToleranceZ", {
        /**
         * Number of cells flought over by the cam on the Z axis before the terrain is updated.
         * Integer greater or equal to 1. Default 1.
         */
        get: function () {
            return this._subToleranceZ;
        },
        set: function (val) {
            this._subToleranceZ = val > 0 ? val : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "initialLOD", {
        /**
         * Initial LOD factor value.
         * Integer greater or equal to 1. Default 1.
         */
        get: function () {
            return this._initialLOD;
        },
        set: function (val) {
            this._initialLOD = val > 0 ? val : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "LODValue", {
        /**
         * Current LOD factor value : the lower factor in the terrain.
         * The LOD value is the sum of the initialLOD and the current cameraLODCorrection.
         * Integer greater or equal to 1. Default 1.
         */
        get: function () {
            return this._LODValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "cameraLODCorrection", {
        /**
         * Camera LOD correction : the factor to add to the initial LOD according to the camera position, movement, etc.
         * Positive integer (default 0)
         */
        get: function () {
            return this._cameraLODCorrection;
        },
        set: function (val) {
            this._cameraLODCorrection = val >= 0 ? val : 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "LODPositiveX", {
        /**
         * Boolean : Does the LOD apply only to the terrain right edge ?
         * Default : true
         */
        get: function () {
            return this._LODPositiveX;
        },
        set: function (val) {
            this._LODPositiveX = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "LODNegativeX", {
        /**
         * Boolean : Does the LOD apply only to the terrain left edge ?
         * Default : true
         */
        get: function () {
            return this._LODNegativeX;
        },
        set: function (val) {
            this._LODNegativeX = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "LODPositiveZ", {
        /**
         * Boolean : Does the LOD apply only to the terrain upper edge ?
         * Default : true
         */
        get: function () {
            return this._LODPositiveZ;
        },
        set: function (val) {
            this._LODPositiveZ = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "LODNegativeZ", {
        /**
         * Boolean : Does the LOD apply only to the terrain lower edge ?
         * Default : true
         */
        get: function () {
            return this._LODNegativeZ;
        },
        set: function (val) {
            this._LODNegativeZ = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "averageSubSizeX", {
        /**
         * Average map and terrain subdivision size on X axis.
         * Returns a float.
         */
        get: function () {
            return this._averageSubSizeX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "averageSubSizeZ", {
        /**
         * Average map and terrain subdivision size on Z axis.
         * Returns a float.
         */
        get: function () {
            return this._averageSubSizeZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "terrainSizeX", {
        /**
         * Current terrain size on the X axis.
         * Returns a float.
         */
        get: function () {
            return this._terrainSizeX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "terrainHalfSizeX", {
        /**
         * Current terrain half size on the X axis.
         * Returns a float.
         */
        get: function () {
            return this._terrainHalfSizeX;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "terrainSizeZ", {
        /**
         * Current terrain size on the Z axis.
         * Returns a float.
         */
        get: function () {
            return this._terrainSizeZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "terrainHalfSizeZ", {
        /**
         * Current terrain half size on the Z axis.
         * Returns a float.
         */
        get: function () {
            return this._terrainHalfSizeZ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "centerLocal", {
        /**
         * Current position of terrain center in its local space.
         * Returns a Vector3.
         */
        get: function () {
            return this._centerLocal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "centerWorld", {
        /**
         * Current position of terrain center in the World space.
         * Returns a Vector3.
         */
        get: function () {
            return this._centerWorld;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "LODLimits", {
        /**
         * The array of the limit values to change the LOD factor.
         * Returns an array of integers or an empty array.
         * This array is always sorted in the descending order once set.
         */
        get: function () {
            return this._LODLimits;
        },
        set: function (ar) {
            ar.sort(function (a, b) {
                return b - a;
            });
            this._LODLimits = ar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mapData", {
        /**
         * The data of the map.
         * A flat array (Float32Array recommeded) of successive 3D float coordinates (x, y, z).
         * This property can be set only if a mapData array was passed at construction time.
         */
        get: function () {
            return this._mapData;
        },
        set: function (val) {
            this._mapData = val;
            this._datamap = true;
            var mapSubX = this._mapSubX;
            var mapSubZ = this._mapSubZ;
            this._mapSizeX = Math.abs(val[(mapSubX - 1) * 3] - val[0]);
            this._mapSizeZ = Math.abs(val[(mapSubZ - 1) * mapSubX * 3 + 2] - val[2]);
            this._averageSubSizeX = this._mapSizeX / mapSubX;
            this._averageSubSizeZ = this._mapSizeZ / mapSubZ;
            if (this._precomputeNormalsFromMap) {
                this.computeNormalsFromMap();
            }
            this.update(true);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mapSubX", {
        /**
         * The number of points on the map width.
         * Positive Integer.
         */
        get: function () {
            return this._mapSubX;
        },
        set: function (val) {
            this._mapSubX = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mapSubZ", {
        /**
         * The number of points on the map height .
         * Positive Integer.
         */
        get: function () {
            return this._mapSubZ;
        },
        set: function (val) {
            this._mapSubZ = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mapColors", {
        /**
         * The map of colors.
         * A flat array of successive floats between 0 and 1 as r,g,b values.
         * This property can be set only if a mapColors array was passed at construction time.
         */
        get: function () {
            return this._mapColors;
        },
        set: function (val) {
            this._colormap = true;
            this._mapColors = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mapUVs", {
        /**
         * The map of UVs.
         * A flat array of successive floats between 0 and 1 as (u, v) values.
         * This property can be set only if a mapUVs array was passed at construction time.
         */
        get: function () {
            return this._mapUVs;
        },
        set: function (val) {
            this._uvmap = true;
            this._mapUVs = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "mapNormals", {
        /**
         * The map of normals.
         * A flat array of successive floats as normal vector coordinates (x, y, z) on each map point.
         */
        get: function () {
            return this._mapNormals;
        },
        set: function (val) {
            this._mapNormals = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "computeNormals", {
        /**
         * Boolean : must the normals be recomputed on each terrain update (default : false).
         * By default, all the map normals are pre-computed on terrain creation.
         */
        get: function () {
            return this._computeNormals;
        },
        set: function (val) {
            this._computeNormals = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "useCustomVertexFunction", {
        /**
         * Boolean : will the custom function updateVertex() be called on each terrain update ?
         * Default false
         */
        get: function () {
            return this._useCustomVertexFunction;
        },
        set: function (val) {
            this._useCustomVertexFunction = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "isAlwaysVisible", {
        /**
         * Boolean : is the terrain always directly selected for rendering ?
         */
        get: function () {
            return this._isAlwaysVisible;
        },
        set: function (val) {
            this.mesh.alwaysSelectAsActiveMesh = val;
            this._isAlwaysVisible = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DynamicTerrain.prototype, "precomputeNormalsFromMap", {
        /**
         * Boolean : when assigning a new data map to the existing, shall the normals be automatically precomputed once ?
         * Default false.
         */
        get: function () {
            return this._precomputeNormalsFromMap;
        },
        set: function (val) {
            this._precomputeNormalsFromMap = val;
        },
        enumerable: false,
        configurable: true
    });
    // ===============================================================
    // User custom functions.
    // These following can be overwritten bu the user to fit his needs.
    /**
     * Custom function called for each terrain vertex and passed the :
     * - current vertex {position: Vector3, uvs: Vector2, color: Color4, lodX: integer, lodZ: integer, worldPosition: Vector3, mapIndex: integer}
     * - i : the vertex index on the terrain x axis
     * - j : the vertex index on the terrain x axis
     * This function is called only if the property useCustomVertexFunction is set to true.
     */
    DynamicTerrain.prototype.updateVertex = function (vertex, i, j) {
        return;
    };
    /**
     * Custom function called each frame and passed the terrain camera reference.
     * This should return a positive integer or zero.
     * Returns zero by default.
     */
    DynamicTerrain.prototype.updateCameraLOD = function (terrainCamera) {
        // LOD value increases with camera altitude
        var camLOD = 0;
        return camLOD;
    };
    /**
     * Custom function called before each terrain update.
     * The value of reference is passed.
     * Does nothing by default.
     */
    DynamicTerrain.prototype.beforeUpdate = function (refreshEveryFrame) {
        return;
    };
    /**
     * Custom function called after each terrain update.
     * The value of refreshEveryFrame is passed.
     * Does nothing by default.
     */
    DynamicTerrain.prototype.afterUpdate = function (refreshEveryFrame) {
        return;
    };
    DynamicTerrain._vertex = {
        // current vertex object passed to the user custom function
        position: Vector3.Zero(),
        uvs: Vector2.Zero(),
        color: new Color4(1.0, 1.0, 1.0, 1.0),
        lodX: 1 | 0,
        lodZ: 1 | 0,
        worldPosition: Vector3.Zero(),
        mapIndex: 0 | 0, // current map index
    };
    // tmp vectors
    DynamicTerrain._v1 = Vector3.Zero();
    DynamicTerrain._v2 = Vector3.Zero();
    DynamicTerrain._v3 = Vector3.Zero();
    DynamicTerrain._v4 = Vector3.Zero();
    DynamicTerrain._vAvB = Vector3.Zero();
    DynamicTerrain._vAvC = Vector3.Zero();
    DynamicTerrain._norm = Vector3.Zero();
    DynamicTerrain._bbMin = Vector3.Zero();
    DynamicTerrain._bbMax = Vector3.Zero();
    return DynamicTerrain;
}());
// }

var CustomPropsHandler = /** @class */ (function () {
    function CustomPropsHandler() {
    }
    /**
     * Register a new props handler
     *
     * @param handler to register for props (a handler can only be registered once per )
     * @returns a reference that can be used to unregister.
     */
    CustomPropsHandler.RegisterPropsHandler = function (propsHandler) {
        var propsChangeType = propsHandler.propChangeType;
        if (!Array.isArray(CustomPropsHandler._registeredPropsHandlers[propsChangeType])) {
            CustomPropsHandler._registeredPropsHandlers[propsChangeType] = [];
        }
        var registeredHandlers = CustomPropsHandler._registeredPropsHandlers[propsChangeType];
        var match = registeredHandlers.find(function (h) { return h === propsHandler || h.name === propsHandler.name; });
        if (match !== undefined) {
            // console.warn(`Handler can only be registered once per type [${propsChangeType}] name[${propsHandler.name}]`);
            return match;
        }
        registeredHandlers.push(propsHandler);
        return propsHandler;
    };
    /**
     * Unregister a props handler that was previously registered.
     *
     * @param propsHandler
     *
     * @returns if the props handler was found and unregistered
     */
    CustomPropsHandler.UnregisterPropsHandler = function (propsHandlerToUnregister) {
        var propsChangeType = propsHandlerToUnregister.propChangeType;
        if (!Array.isArray(CustomPropsHandler._registeredPropsHandlers[propsChangeType])) {
            console.warn("cannot find ".concat(propsHandlerToUnregister.name, " to unregister."));
            return false;
        }
        var registeredHandlers = CustomPropsHandler._registeredPropsHandlers[propsChangeType];
        var index = registeredHandlers.indexOf(propsHandlerToUnregister);
        if (index === -1) {
            console.warn("cannot find ".concat(propsHandlerToUnregister.name, " to unregister."));
            return false;
        }
        CustomPropsHandler._registeredPropsHandlers[propsChangeType] = registeredHandlers.slice(index, 1);
        return true;
    };
    CustomPropsHandler.HandlePropsChange = function (propsChangeType, oldProp, newProp) {
        var registeredHandlers = CustomPropsHandler._registeredPropsHandlers[propsChangeType];
        if (registeredHandlers === undefined) {
            return CustomPropsHandler.NOT_ACCEPTED;
        }
        var accepted = false;
        for (var _i = 0, registeredHandlers_1 = registeredHandlers; _i < registeredHandlers_1.length; _i++) {
            var handler = registeredHandlers_1[_i];
            if (handler.accept(newProp)) {
                accepted = true;
                var propertyUpdatedProcessResult = handler.process(oldProp, newProp);
                // console.log(`handler '${handler.name}'custom prop processing result:`, oldProp, newProp, propertyUpdatedProcessResult);
                // give other custom handlers (if any) the opportunity to handle
                if (propertyUpdatedProcessResult.processed) {
                    return {
                        accepted: true,
                        processed: true,
                        value: propertyUpdatedProcessResult.value,
                    };
                }
            }
        }
        return accepted ? CustomPropsHandler.ACCEPTED_NOT_PROCESSED : CustomPropsHandler.NOT_ACCEPTED;
    };
    CustomPropsHandler._registeredPropsHandlers = {};
    CustomPropsHandler.NOT_ACCEPTED = Object.freeze({
        accepted: false,
        processed: false,
        value: null,
    });
    CustomPropsHandler.ACCEPTED_NOT_PROCESSED = Object.freeze({
        accepted: true,
        processed: false,
        value: null,
    });
    return CustomPropsHandler;
}());
var PropChangeType;
(function (PropChangeType) {
    PropChangeType["Color3"] = "Color3";
    PropChangeType["Color4"] = "Color4";
    PropChangeType["Control"] = "Control";
    PropChangeType["FresnelParameters"] = "FresnelParameters";
    PropChangeType["LambdaExpression"] = "LambdaExpression";
    PropChangeType["Method"] = "Method";
    PropChangeType["NumericArray"] = "NumericArray";
    PropChangeType["Observable"] = "Observable";
    PropChangeType["Primitive"] = "Primitive";
    PropChangeType["Quaternion"] = "Quaternion";
    PropChangeType["Texture"] = "Texture";
    PropChangeType["Vector3"] = "Vector3";
})(PropChangeType || (PropChangeType = {}));
/**
 * Encapsulates common error handling and handling of registered custom prop handlers.
 */
function propertyCheck(oldProp, newProp, propertyName, propChangeType, changedProps, templateMethod) {
    try {
        var processedResult = CustomPropsHandler.HandlePropsChange(propChangeType, oldProp, newProp);
        if (processedResult.accepted) {
            if (processedResult.processed) {
                // console.log(`handled ${propChangeType} on ${propertyName} by custom handler - new Value: ${JSON.stringify(processedResult.value ?? {})}`);
                changedProps.push({
                    propertyName: propertyName,
                    changeType: propChangeType,
                    value: processedResult.value,
                });
            }
            // we assume any custom handler that 'accepts' a property does not want to pass
            // down to built-in handler.  ie: [] -> Vector3 would fail.
            return;
        }
        templateMethod(oldProp, newProp, changedProps);
    }
    catch (e) {
        console.error("Unable to update '".concat(propertyName, "' with ").concat(propChangeType, ":"), newProp);
        console.error(e);
    }
}
var checkQuaternionDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Quaternion, changedProps, function (oldProp, newProp, changedProps) {
        // going with equals (also has method equalsWithEpsilon)
        if (newProp && (!oldProp || !newProp.equals(oldProp))) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Quaternion,
                value: newProp,
            });
        }
    });
};
var checkVector3Diff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Vector3, changedProps, function (oldProp, newProp, changedProps) {
        if (newProp && (!oldProp || !newProp.equals(oldProp))) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Vector3,
                value: newProp,
            });
        }
    });
};
var checkColor3Diff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Color3, changedProps, function (oldProp, newProp, changedProps) {
        if (newProp && (!oldProp || !newProp.equals(oldProp))) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Color3,
                value: newProp,
            });
        }
    });
};
var checkColor4Diff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Color4, changedProps, function (oldProp, newProp, changedProps) {
        // Color4.equals() not added until PR #5517
        if (newProp &&
            (!oldProp ||
                oldProp.r !== newProp.r ||
                oldProp.g !== newProp.g ||
                oldProp.b !== newProp.b ||
                oldProp.a !== newProp.a)) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Color4,
                value: newProp,
            });
        }
    });
};
var checkFresnelParametersDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.FresnelParameters, changedProps, function (oldProp, newProp, changedProps) {
        // FresnelParameters.equals() not added until PR #7818 (https://github.com/BabylonJS/Babylon.js/pull/7818)
        if (newProp /* won't clear the property value */ &&
            (!oldProp ||
                oldProp.bias !== newProp.bias ||
                oldProp.power !== newProp.power ||
                !oldProp.leftColor ||
                !oldProp.leftColor.equals(newProp.leftColor) ||
                !oldProp.rightColor ||
                !oldProp.rightColor.equals(newProp.rightColor) ||
                oldProp.isEnabled !== newProp.isEnabled)) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.FresnelParameters,
                value: newProp,
            });
        }
    });
};
var checkLambdaDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.LambdaExpression, changedProps, function (oldProp, newProp, changedProps) {
        if (newProp !== oldProp) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.LambdaExpression,
                value: newProp,
            });
        }
    });
};
var checkControlDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Control, changedProps, function (oldProp, newProp, changedProps) {
        // only sets once
        if (newProp && !oldProp) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Control,
                value: newProp,
            });
        }
    });
};
var checkObjectDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Primitive, changedProps, function (oldProp, newProp, changedProps) {
        if (newProp !== oldProp) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Primitive,
                value: newProp,
            });
        }
    });
};
var checkPrimitiveDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Primitive, changedProps, function (oldProp, newProp, changedProps) {
        if (newProp !== oldProp) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Primitive,
                value: newProp,
            });
        }
    });
};
var checkTextureDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Texture, changedProps, function (oldProp, newProp, changedProps) {
        if (newProp !== oldProp) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Texture,
                value: newProp,
            });
        }
    });
};
var checkNumericArrayDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.NumericArray, changedProps, function (oldProp, newProp, changedProps) {
        // just length - missing loop + indexOf comparison (or deepEquals())
        if (newProp && (!oldProp || oldProp.length !== newProp.length)) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.NumericArray,
                value: newProp,
            });
        }
    });
};
var checkObservableDiff = function (oldProp, newProp, propertyName, changedProps) {
    propertyCheck(oldProp, newProp, propertyName, PropChangeType.Observable, changedProps, function (oldProp, newProp, changedProps) {
        if (oldProp !== newProp) {
            changedProps.push({
                propertyName: propertyName,
                changeType: PropChangeType.Observable,
                value: newProp,
            });
        }
    });
};
/**
 * This method differs from the rest in that we need to pass in a list of arguments.  Can be done by using:
 * 1. an array to signify each parameter (or Object.values(...)).
 *
 * @param oldProp value of method (array, object, primitive, etc.)
 * @param newProp value of method (array, object, primitive, etc.)
 * @param propertyName name of property for diff
 * @param changedProps list to append to when a diff is found
 */
var checkMethodDiff = function (oldProp, newProp, propertyName, changedProps) {
    if (oldProp !== newProp) {
        changedProps.push({
            propertyName: propertyName,
            changeType: PropChangeType.Method,
            value: newProp,
        });
    }
};

var FiberNodePropsHandler = /** @class */ (function () {
    function FiberNodePropsHandler() {
    }
    FiberNodePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAnimationPropertiesOverride' property (not coded) BabylonjsCoreNode.animationPropertiesOverride.
        // type: 'BabylonjsCoreAnimation[]' property (not coded) BabylonjsCoreNode.animations.
        checkPrimitiveDiff(oldProps.doNotSerialize, newProps.doNotSerialize, 'doNotSerialize', changedProps);
        checkPrimitiveDiff(oldProps.id, newProps.id, 'id', changedProps);
        // type: 'BabylonjsCoreIInspectable[]' property (not coded) BabylonjsCoreNode.inspectableCustomProperties.
        // type: 'any' property (not coded) BabylonjsCoreNode.metadata.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkLambdaDiff(oldProps.onDispose, newProps.onDispose, 'onDispose', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        checkLambdaDiff(oldProps.onReady, newProps.onReady, 'onReady', changedProps);
        // type: 'BabylonjsCoreNode' property (not coded) BabylonjsCoreNode.parent.
        // type: 'any' property (not coded) BabylonjsCoreNode.reservedDataStore.
        checkPrimitiveDiff(oldProps.state, newProps.state, 'state', changedProps);
        checkPrimitiveDiff(oldProps.uniqueId, newProps.uniqueId, 'uniqueId', changedProps);
        checkMethodDiff(oldProps.addBehavior, newProps.addBehavior, 'addBehavior', changedProps);
        checkMethodDiff(oldProps.setEnabled, newProps.setEnabled, 'setEnabled', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberNodePropsHandler;
}());
/**
 * Node is the basic class for all scene objects (Mesh, Light, Camera.)
 *
 * This code has been generated
 */
var FiberNode = /** @class */ (function () {
    function FiberNode() {
        this.propsHandlers = [new FiberNodePropsHandler()];
    }
    FiberNode.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberNode.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberNode.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Node',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberNode.Metadata = {
        isNode: true,
        className: 'FiberNode',
    };
    return FiberNode;
}());
var FiberTransformNodePropsHandler = /** @class */ (function () {
    function FiberTransformNodePropsHandler() {
    }
    FiberTransformNodePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.billboardMode, newProps.billboardMode, 'billboardMode', changedProps);
        checkPrimitiveDiff(oldProps.ignoreNonUniformScaling, newProps.ignoreNonUniformScaling, 'ignoreNonUniformScaling', changedProps);
        checkPrimitiveDiff(oldProps.infiniteDistance, newProps.infiniteDistance, 'infiniteDistance', changedProps);
        checkObservableDiff(oldProps.onAfterWorldMatrixUpdateObservable, newProps.onAfterWorldMatrixUpdateObservable, 'onAfterWorldMatrixUpdateObservable', changedProps);
        checkVector3Diff(oldProps.position, newProps.position, 'position', changedProps);
        checkPrimitiveDiff(oldProps['position-x'], newProps['position-x'], 'position.x', changedProps);
        checkPrimitiveDiff(oldProps['position-y'], newProps['position-y'], 'position.y', changedProps);
        checkPrimitiveDiff(oldProps['position-z'], newProps['position-z'], 'position.z', changedProps);
        checkPrimitiveDiff(oldProps.preserveParentRotationForBillboard, newProps.preserveParentRotationForBillboard, 'preserveParentRotationForBillboard', changedProps);
        checkPrimitiveDiff(oldProps.reIntegrateRotationIntoRotationQuaternion, newProps.reIntegrateRotationIntoRotationQuaternion, 'reIntegrateRotationIntoRotationQuaternion', changedProps);
        checkVector3Diff(oldProps.rotation, newProps.rotation, 'rotation', changedProps);
        checkPrimitiveDiff(oldProps['rotation-x'], newProps['rotation-x'], 'rotation.x', changedProps);
        checkPrimitiveDiff(oldProps['rotation-y'], newProps['rotation-y'], 'rotation.y', changedProps);
        checkPrimitiveDiff(oldProps['rotation-z'], newProps['rotation-z'], 'rotation.z', changedProps);
        checkQuaternionDiff(oldProps.rotationQuaternion, newProps.rotationQuaternion, 'rotationQuaternion', changedProps);
        checkVector3Diff(oldProps.scaling, newProps.scaling, 'scaling', changedProps);
        checkPrimitiveDiff(oldProps['scaling-x'], newProps['scaling-x'], 'scaling.x', changedProps);
        checkPrimitiveDiff(oldProps['scaling-y'], newProps['scaling-y'], 'scaling.y', changedProps);
        checkPrimitiveDiff(oldProps['scaling-z'], newProps['scaling-z'], 'scaling.z', changedProps);
        checkPrimitiveDiff(oldProps.scalingDeterminant, newProps.scalingDeterminant, 'scalingDeterminant', changedProps);
        checkMethodDiff(oldProps.addRotation, newProps.addRotation, 'addRotation', changedProps);
        checkMethodDiff(oldProps.setAbsolutePosition, newProps.setAbsolutePosition, 'setAbsolutePosition', changedProps);
        checkMethodDiff(oldProps.setDirection, newProps.setDirection, 'setDirection', changedProps);
        checkMethodDiff(oldProps.setParent, newProps.setParent, 'setParent', changedProps);
        checkMethodDiff(oldProps.setPivotMatrix, newProps.setPivotMatrix, 'setPivotMatrix', changedProps);
        checkMethodDiff(oldProps.setPivotPoint, newProps.setPivotPoint, 'setPivotPoint', changedProps);
        checkMethodDiff(oldProps.setPositionWithLocalVector, newProps.setPositionWithLocalVector, 'setPositionWithLocalVector', changedProps);
        checkMethodDiff(oldProps.setPreTransformMatrix, newProps.setPreTransformMatrix, 'setPreTransformMatrix', changedProps);
        checkMethodDiff(oldProps.translate, newProps.translate, 'translate', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTransformNodePropsHandler;
}());
/**
 * A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.
 *
 * This code has been generated
 */
var FiberTransformNode = /** @class */ (function () {
    function FiberTransformNode() {
        this.propsHandlers = [new FiberTransformNodePropsHandler(), new FiberNodePropsHandler()];
    }
    FiberTransformNode.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTransformNode.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTransformNode.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TransformNode',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'isPure',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberTransformNode.Metadata = {
        isNode: true,
        className: 'FiberTransformNode',
    };
    return FiberTransformNode;
}());
var FiberAbstractMeshPropsHandler = /** @class */ (function () {
    function FiberAbstractMeshPropsHandler() {
    }
    FiberAbstractMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractActionManager' property (not coded) BabylonjsCoreAbstractMesh.actionManager.
        checkPrimitiveDiff(oldProps.alphaIndex, newProps.alphaIndex, 'alphaIndex', changedProps);
        checkPrimitiveDiff(oldProps.alwaysSelectAsActiveMesh, newProps.alwaysSelectAsActiveMesh, 'alwaysSelectAsActiveMesh', changedProps);
        checkPrimitiveDiff(oldProps.applyFog, newProps.applyFog, 'applyFog', changedProps);
        // type: 'BabylonjsCoreIBakedVertexAnimationManager' property (not coded) BabylonjsCoreAbstractMesh.bakedVertexAnimationManager.
        checkPrimitiveDiff(oldProps.checkCollisions, newProps.checkCollisions, 'checkCollisions', changedProps);
        checkPrimitiveDiff(oldProps.collisionGroup, newProps.collisionGroup, 'collisionGroup', changedProps);
        checkPrimitiveDiff(oldProps.collisionMask, newProps.collisionMask, 'collisionMask', changedProps);
        checkPrimitiveDiff(oldProps.collisionResponse, newProps.collisionResponse, 'collisionResponse', changedProps);
        checkPrimitiveDiff(oldProps.collisionRetryCount, newProps.collisionRetryCount, 'collisionRetryCount', changedProps);
        checkPrimitiveDiff(oldProps.computeBonesUsingShaders, newProps.computeBonesUsingShaders, 'computeBonesUsingShaders', changedProps);
        checkPrimitiveDiff(oldProps.cullingStrategy, newProps.cullingStrategy, 'cullingStrategy', changedProps);
        checkPrimitiveDiff(oldProps.definedFacingForward, newProps.definedFacingForward, 'definedFacingForward', changedProps);
        checkPrimitiveDiff(oldProps.doNotSyncBoundingInfo, newProps.doNotSyncBoundingInfo, 'doNotSyncBoundingInfo', changedProps);
        checkColor4Diff(oldProps.edgesColor, newProps.edgesColor, 'edgesColor', changedProps);
        checkPrimitiveDiff(oldProps.edgesWidth, newProps.edgesWidth, 'edgesWidth', changedProps);
        checkVector3Diff(oldProps.ellipsoid, newProps.ellipsoid, 'ellipsoid', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-x'], newProps['ellipsoid-x'], 'ellipsoid.x', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-y'], newProps['ellipsoid-y'], 'ellipsoid.y', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-z'], newProps['ellipsoid-z'], 'ellipsoid.z', changedProps);
        checkVector3Diff(oldProps.ellipsoidOffset, newProps.ellipsoidOffset, 'ellipsoidOffset', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-x'], newProps['ellipsoidOffset-x'], 'ellipsoidOffset.x', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-y'], newProps['ellipsoidOffset-y'], 'ellipsoidOffset.y', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-z'], newProps['ellipsoidOffset-z'], 'ellipsoidOffset.z', changedProps);
        checkPrimitiveDiff(oldProps.enableDistantPicking, newProps.enableDistantPicking, 'enableDistantPicking', changedProps);
        checkPrimitiveDiff(oldProps.enablePointerMoveEvents, newProps.enablePointerMoveEvents, 'enablePointerMoveEvents', changedProps);
        checkVector3Diff(oldProps.facetDepthSortFrom, newProps.facetDepthSortFrom, 'facetDepthSortFrom', changedProps);
        checkPrimitiveDiff(oldProps['facetDepthSortFrom-x'], newProps['facetDepthSortFrom-x'], 'facetDepthSortFrom.x', changedProps);
        checkPrimitiveDiff(oldProps['facetDepthSortFrom-y'], newProps['facetDepthSortFrom-y'], 'facetDepthSortFrom.y', changedProps);
        checkPrimitiveDiff(oldProps['facetDepthSortFrom-z'], newProps['facetDepthSortFrom-z'], 'facetDepthSortFrom.z', changedProps);
        checkPrimitiveDiff(oldProps.hasVertexAlpha, newProps.hasVertexAlpha, 'hasVertexAlpha', changedProps);
        checkObjectDiff(oldProps.instancedBuffers, newProps.instancedBuffers, 'instancedBuffers', changedProps);
        checkPrimitiveDiff(oldProps.isBlocker, newProps.isBlocker, 'isBlocker', changedProps);
        checkPrimitiveDiff(oldProps.isNearGrabbable, newProps.isNearGrabbable, 'isNearGrabbable', changedProps);
        checkPrimitiveDiff(oldProps.isNearPickable, newProps.isNearPickable, 'isNearPickable', changedProps);
        checkPrimitiveDiff(oldProps.isPickable, newProps.isPickable, 'isPickable', changedProps);
        checkPrimitiveDiff(oldProps.isVisible, newProps.isVisible, 'isVisible', changedProps);
        checkPrimitiveDiff(oldProps.layerMask, newProps.layerMask, 'layerMask', changedProps);
        // type: 'BabylonjsCoreMaterial' property (not coded) BabylonjsCoreAbstractMesh.material.
        // type: 'BabylonjsCoreMorphTargetManager' property (not coded) BabylonjsCoreAbstractMesh.morphTargetManager.
        checkPrimitiveDiff(oldProps.mustDepthSortFacets, newProps.mustDepthSortFacets, 'mustDepthSortFacets', changedProps);
        checkPrimitiveDiff(oldProps.numBoneInfluencers, newProps.numBoneInfluencers, 'numBoneInfluencers', changedProps);
        checkLambdaDiff(oldProps.onCollide, newProps.onCollide, 'onCollide', changedProps);
        checkObservableDiff(oldProps.onCollideObservable, newProps.onCollideObservable, 'onCollideObservable', changedProps);
        checkLambdaDiff(oldProps.onCollisionPositionChange, newProps.onCollisionPositionChange, 'onCollisionPositionChange', changedProps);
        checkObservableDiff(oldProps.onCollisionPositionChangeObservable, newProps.onCollisionPositionChangeObservable, 'onCollisionPositionChangeObservable', changedProps);
        checkObservableDiff(oldProps.onMaterialChangedObservable, newProps.onMaterialChangedObservable, 'onMaterialChangedObservable', changedProps);
        checkObservableDiff(oldProps.onRebuildObservable, newProps.onRebuildObservable, 'onRebuildObservable', changedProps);
        checkColor3Diff(oldProps.outlineColor, newProps.outlineColor, 'outlineColor', changedProps);
        checkPrimitiveDiff(oldProps.outlineWidth, newProps.outlineWidth, 'outlineWidth', changedProps);
        checkPrimitiveDiff(oldProps.overlayAlpha, newProps.overlayAlpha, 'overlayAlpha', changedProps);
        checkColor3Diff(oldProps.overlayColor, newProps.overlayColor, 'overlayColor', changedProps);
        checkPrimitiveDiff(oldProps.partitioningBBoxRatio, newProps.partitioningBBoxRatio, 'partitioningBBoxRatio', changedProps);
        checkPrimitiveDiff(oldProps.partitioningSubdivisions, newProps.partitioningSubdivisions, 'partitioningSubdivisions', changedProps);
        checkPrimitiveDiff(oldProps.receiveShadows, newProps.receiveShadows, 'receiveShadows', changedProps);
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        checkVector3Diff(oldProps.scaling, newProps.scaling, 'scaling', changedProps);
        checkPrimitiveDiff(oldProps['scaling-x'], newProps['scaling-x'], 'scaling.x', changedProps);
        checkPrimitiveDiff(oldProps['scaling-y'], newProps['scaling-y'], 'scaling.y', changedProps);
        checkPrimitiveDiff(oldProps['scaling-z'], newProps['scaling-z'], 'scaling.z', changedProps);
        checkPrimitiveDiff(oldProps.showSubMeshesBoundingBox, newProps.showSubMeshesBoundingBox, 'showSubMeshesBoundingBox', changedProps);
        // type: 'BabylonjsCoreSkeleton' property (not coded) BabylonjsCoreAbstractMesh.skeleton.
        // type: 'BabylonjsCoreSubMesh[]' property (not coded) BabylonjsCoreAbstractMesh.subMeshes.
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreAbstractMesh.surroundingMeshes.
        checkPrimitiveDiff(oldProps.useOctreeForCollisions, newProps.useOctreeForCollisions, 'useOctreeForCollisions', changedProps);
        checkPrimitiveDiff(oldProps.useOctreeForPicking, newProps.useOctreeForPicking, 'useOctreeForPicking', changedProps);
        checkPrimitiveDiff(oldProps.useOctreeForRenderingSelection, newProps.useOctreeForRenderingSelection, 'useOctreeForRenderingSelection', changedProps);
        checkPrimitiveDiff(oldProps.useVertexColors, newProps.useVertexColors, 'useVertexColors', changedProps);
        checkPrimitiveDiff(oldProps.visibility, newProps.visibility, 'visibility', changedProps);
        checkMethodDiff(oldProps.addChild, newProps.addChild, 'addChild', changedProps);
        checkMethodDiff(oldProps.enableEdgesRendering, newProps.enableEdgesRendering, 'enableEdgesRendering', changedProps);
        checkMethodDiff(oldProps.setBoundingInfo, newProps.setBoundingInfo, 'setBoundingInfo', changedProps);
        checkMethodDiff(oldProps.setIndices, newProps.setIndices, 'setIndices', changedProps);
        checkMethodDiff(oldProps.setMaterialForRenderPass, newProps.setMaterialForRenderPass, 'setMaterialForRenderPass', changedProps);
        checkMethodDiff(oldProps.setVerticesData, newProps.setVerticesData, 'setVerticesData', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberAbstractMeshPropsHandler;
}());
/**
 * Class used to store all common mesh properties
 *
 * This code has been generated
 */
var FiberAbstractMesh = /** @class */ (function () {
    function FiberAbstractMesh() {
        this.propsHandlers = [
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberAbstractMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAbstractMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAbstractMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AbstractMesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberAbstractMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberAbstractMesh',
    };
    return FiberAbstractMesh;
}());
var FiberInstancedMeshPropsHandler = /** @class */ (function () {
    function FiberInstancedMeshPropsHandler() {
    }
    FiberInstancedMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        checkMethodDiff(oldProps.setIndices, newProps.setIndices, 'setIndices', changedProps);
        checkMethodDiff(oldProps.setVerticesData, newProps.setVerticesData, 'setVerticesData', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberInstancedMeshPropsHandler;
}());
/**
 * Creates an instance based on a source mesh.
 *
 * This code has been generated
 */
var FiberInstancedMesh = /** @class */ (function () {
    function FiberInstancedMesh() {
        this.propsHandlers = [
            new FiberInstancedMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberInstancedMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberInstancedMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberInstancedMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'InstancedMesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'source',
                type: 'BabylonjsCoreMesh',
                optional: false,
            },
        ],
    };
    FiberInstancedMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberInstancedMesh',
    };
    return FiberInstancedMesh;
}());
var FiberInstancedLinesMeshPropsHandler = /** @class */ (function () {
    function FiberInstancedLinesMeshPropsHandler() {
    }
    FiberInstancedLinesMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.intersectionThreshold, newProps.intersectionThreshold, 'intersectionThreshold', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberInstancedLinesMeshPropsHandler;
}());
/**
 * Creates an instance based on a source LinesMesh
 *
 * This code has been generated
 */
var FiberInstancedLinesMesh = /** @class */ (function () {
    function FiberInstancedLinesMesh() {
        this.propsHandlers = [
            new FiberInstancedLinesMeshPropsHandler(),
            new FiberInstancedMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberInstancedLinesMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberInstancedLinesMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberInstancedLinesMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'InstancedLinesMesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'source',
                type: 'BabylonjsCoreLinesMesh',
                optional: false,
            },
        ],
    };
    FiberInstancedLinesMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberInstancedLinesMesh',
    };
    return FiberInstancedLinesMesh;
}());
var FiberMeshPropsHandler = /** @class */ (function () {
    function FiberMeshPropsHandler() {
    }
    FiberMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.computeBonesUsingShaders, newProps.computeBonesUsingShaders, 'computeBonesUsingShaders', changedProps);
        checkPrimitiveDiff(oldProps.delayLoadingFile, newProps.delayLoadingFile, 'delayLoadingFile', changedProps);
        checkPrimitiveDiff(oldProps.delayLoadState, newProps.delayLoadState, 'delayLoadState', changedProps);
        checkPrimitiveDiff(oldProps.forcedInstanceCount, newProps.forcedInstanceCount, 'forcedInstanceCount', changedProps);
        checkPrimitiveDiff(oldProps.ignoreCameraMaxZ, newProps.ignoreCameraMaxZ, 'ignoreCameraMaxZ', changedProps);
        // type: 'BabylonjsCoreInstancedMesh[]' property (not coded) BabylonjsCoreMesh.instances.
        checkPrimitiveDiff(oldProps.isUnIndexed, newProps.isUnIndexed, 'isUnIndexed', changedProps);
        checkPrimitiveDiff(oldProps.manualUpdateOfPreviousWorldMatrixInstancedBuffer, newProps.manualUpdateOfPreviousWorldMatrixInstancedBuffer, 'manualUpdateOfPreviousWorldMatrixInstancedBuffer', changedProps);
        checkPrimitiveDiff(oldProps.manualUpdateOfWorldMatrixInstancedBuffer, newProps.manualUpdateOfWorldMatrixInstancedBuffer, 'manualUpdateOfWorldMatrixInstancedBuffer', changedProps);
        checkLambdaDiff(oldProps.onBeforeDraw, newProps.onBeforeDraw, 'onBeforeDraw', changedProps);
        checkLambdaDiff(oldProps.onLODLevelSelection, newProps.onLODLevelSelection, 'onLODLevelSelection', changedProps);
        checkObservableDiff(oldProps.onMeshReadyObservable, newProps.onMeshReadyObservable, 'onMeshReadyObservable', changedProps);
        checkPrimitiveDiff(oldProps.overrideMaterialSideOrientation, newProps.overrideMaterialSideOrientation, 'overrideMaterialSideOrientation', changedProps);
        checkPrimitiveDiff(oldProps.overridenInstanceCount, newProps.overridenInstanceCount, 'overridenInstanceCount', changedProps);
        checkPrimitiveDiff(oldProps.useLODScreenCoverage, newProps.useLODScreenCoverage, 'useLODScreenCoverage', changedProps);
        checkMethodDiff(oldProps.addInstance, newProps.addInstance, 'addInstance', changedProps);
        checkMethodDiff(oldProps.addLODLevel, newProps.addLODLevel, 'addLODLevel', changedProps);
        checkMethodDiff(oldProps.setIndices, newProps.setIndices, 'setIndices', changedProps);
        checkMethodDiff(oldProps.setMaterialById, newProps.setMaterialById, 'setMaterialById', changedProps);
        checkMethodDiff(oldProps.setVerticesBuffer, newProps.setVerticesBuffer, 'setVerticesBuffer', changedProps);
        checkMethodDiff(oldProps.setVerticesData, newProps.setVerticesData, 'setVerticesData', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMeshPropsHandler;
}());
/**
 * Class used to represent renderable models
 *
 * This code has been generated
 */
var FiberMesh = /** @class */ (function () {
    function FiberMesh() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Mesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'parent',
                type: 'BabylonjsCoreNode',
                optional: true,
            },
            {
                name: 'source',
                type: 'BabylonjsCoreMesh',
                optional: true,
            },
            {
                name: 'doNotCloneChildren',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'clonePhysicsImpostor',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberMesh',
    };
    return FiberMesh;
}());
var FiberGroundMeshPropsHandler = /** @class */ (function () {
    function FiberGroundMeshPropsHandler() {
    }
    FiberGroundMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.generateOctree, newProps.generateOctree, 'generateOctree', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGroundMeshPropsHandler;
}());
/**
 * Mesh representing the ground
 *
 * This code has been generated
 */
var FiberGroundMesh = /** @class */ (function () {
    function FiberGroundMesh() {
        this.propsHandlers = [
            new FiberGroundMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGroundMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGroundMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGroundMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GroundMesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGroundMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberGroundMesh',
    };
    return FiberGroundMesh;
}());
var FiberLinesMeshPropsHandler = /** @class */ (function () {
    function FiberLinesMeshPropsHandler() {
    }
    FiberLinesMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.alpha, newProps.alpha, 'alpha', changedProps);
        checkPrimitiveDiff(oldProps.checkCollisions, newProps.checkCollisions, 'checkCollisions', changedProps);
        checkColor3Diff(oldProps.color, newProps.color, 'color', changedProps);
        checkPrimitiveDiff(oldProps.intersectionThreshold, newProps.intersectionThreshold, 'intersectionThreshold', changedProps);
        // type: 'BabylonjsCoreMaterial' property (not coded) BabylonjsCoreLinesMesh.material.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberLinesMeshPropsHandler;
}());
/**
 * Line mesh
 *
 * This code has been generated
 */
var FiberLinesMesh = /** @class */ (function () {
    function FiberLinesMesh() {
        this.propsHandlers = [
            new FiberLinesMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberLinesMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLinesMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLinesMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'LinesMesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'parent',
                type: 'BabylonjsCoreNode',
                optional: true,
            },
            {
                name: 'source',
                type: 'BabylonjsCoreLinesMesh',
                optional: true,
            },
            {
                name: 'doNotCloneChildren',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'useVertexColor',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'useVertexAlpha',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'material',
                type: 'BabylonjsCoreMaterial',
                optional: true,
            },
        ],
    };
    FiberLinesMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberLinesMesh',
    };
    return FiberLinesMesh;
}());
var FiberGoldbergMeshPropsHandler = /** @class */ (function () {
    function FiberGoldbergMeshPropsHandler() {
    }
    FiberGoldbergMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreGoldbergData' property (not coded) BabylonjsCoreGoldbergMesh.goldbergData.
        checkMethodDiff(oldProps.setGoldbergFaceColors, newProps.setGoldbergFaceColors, 'setGoldbergFaceColors', changedProps);
        checkMethodDiff(oldProps.setGoldbergFaceUVs, newProps.setGoldbergFaceUVs, 'setGoldbergFaceUVs', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGoldbergMeshPropsHandler;
}());
/**
 * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces
 *
 * This code has been generated
 */
var FiberGoldbergMesh = /** @class */ (function () {
    function FiberGoldbergMesh() {
        this.propsHandlers = [
            new FiberGoldbergMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGoldbergMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGoldbergMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGoldbergMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GoldbergMesh',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberGoldbergMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberGoldbergMesh',
    };
    return FiberGoldbergMesh;
}());
var FiberTrailMeshPropsHandler = /** @class */ (function () {
    function FiberTrailMeshPropsHandler() {
    }
    FiberTrailMeshPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberTrailMeshPropsHandler;
}());
/**
 * Class used to create a trail following a mesh
 *
 * This code has been generated
 */
var FiberTrailMesh = /** @class */ (function () {
    function FiberTrailMesh() {
        this.propsHandlers = [
            new FiberTrailMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTrailMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTrailMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTrailMesh.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TrailMesh',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'generator',
                type: 'BabylonjsCoreTransformNode',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'diameter',
                type: 'number',
                optional: true,
            },
            {
                name: 'length',
                type: 'number',
                optional: true,
            },
            {
                name: 'autoStart',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberTrailMesh.Metadata = {
        isNode: true,
        acceptsMaterials: true,
        isMesh: true,
        className: 'FiberTrailMesh',
    };
    return FiberTrailMesh;
}());
var FiberCameraPropsHandler = /** @class */ (function () {
    function FiberCameraPropsHandler() {
    }
    FiberCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.cameraRigMode, newProps.cameraRigMode, 'cameraRigMode', changedProps);
        // type: 'BabylonjsCoreRenderTargetTexture[]' property (not coded) BabylonjsCoreCamera.customRenderTargets.
        checkPrimitiveDiff(oldProps.fov, newProps.fov, 'fov', changedProps);
        checkPrimitiveDiff(oldProps.fovMode, newProps.fovMode, 'fovMode', changedProps);
        checkPrimitiveDiff(oldProps.inertia, newProps.inertia, 'inertia', changedProps);
        // type: 'BabylonjsCoreCameraInputsManager<BabylonjsCoreCamera>' property (not coded) BabylonjsCoreCamera.inputs.
        checkPrimitiveDiff(oldProps.interaxialDistance, newProps.interaxialDistance, 'interaxialDistance', changedProps);
        checkPrimitiveDiff(oldProps.isIntermediate, newProps.isIntermediate, 'isIntermediate', changedProps);
        checkPrimitiveDiff(oldProps.isRigCamera, newProps.isRigCamera, 'isRigCamera', changedProps);
        checkPrimitiveDiff(oldProps.isStereoscopicSideBySide, newProps.isStereoscopicSideBySide, 'isStereoscopicSideBySide', changedProps);
        checkPrimitiveDiff(oldProps.layerMask, newProps.layerMask, 'layerMask', changedProps);
        checkPrimitiveDiff(oldProps.maxZ, newProps.maxZ, 'maxZ', changedProps);
        checkPrimitiveDiff(oldProps.minZ, newProps.minZ, 'minZ', changedProps);
        checkPrimitiveDiff(oldProps.mode, newProps.mode, 'mode', changedProps);
        checkObservableDiff(oldProps.onAfterCheckInputsObservable, newProps.onAfterCheckInputsObservable, 'onAfterCheckInputsObservable', changedProps);
        checkObservableDiff(oldProps.onProjectionMatrixChangedObservable, newProps.onProjectionMatrixChangedObservable, 'onProjectionMatrixChangedObservable', changedProps);
        checkObservableDiff(oldProps.onRestoreStateObservable, newProps.onRestoreStateObservable, 'onRestoreStateObservable', changedProps);
        checkObservableDiff(oldProps.onViewMatrixChangedObservable, newProps.onViewMatrixChangedObservable, 'onViewMatrixChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.orthoBottom, newProps.orthoBottom, 'orthoBottom', changedProps);
        checkPrimitiveDiff(oldProps.orthoLeft, newProps.orthoLeft, 'orthoLeft', changedProps);
        checkPrimitiveDiff(oldProps.orthoRight, newProps.orthoRight, 'orthoRight', changedProps);
        checkPrimitiveDiff(oldProps.orthoTop, newProps.orthoTop, 'orthoTop', changedProps);
        // type: 'BabylonjsCoreRenderTargetTexture' property (not coded) BabylonjsCoreCamera.outputRenderTarget.
        checkVector3Diff(oldProps.position, newProps.position, 'position', changedProps);
        checkPrimitiveDiff(oldProps['position-x'], newProps['position-x'], 'position.x', changedProps);
        checkPrimitiveDiff(oldProps['position-y'], newProps['position-y'], 'position.y', changedProps);
        checkPrimitiveDiff(oldProps['position-z'], newProps['position-z'], 'position.z', changedProps);
        checkPrimitiveDiff(oldProps.projectionPlaneTilt, newProps.projectionPlaneTilt, 'projectionPlaneTilt', changedProps);
        checkPrimitiveDiff(oldProps.renderPassId, newProps.renderPassId, 'renderPassId', changedProps);
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreCamera.rigParent.
        checkVector3Diff(oldProps.upVector, newProps.upVector, 'upVector', changedProps);
        checkPrimitiveDiff(oldProps['upVector-x'], newProps['upVector-x'], 'upVector.x', changedProps);
        checkPrimitiveDiff(oldProps['upVector-y'], newProps['upVector-y'], 'upVector.y', changedProps);
        checkPrimitiveDiff(oldProps['upVector-z'], newProps['upVector-z'], 'upVector.z', changedProps);
        // type: 'BabylonjsCoreViewport' property (not coded) BabylonjsCoreCamera.viewport.
        checkMethodDiff(oldProps.setCameraRigMode, newProps.setCameraRigMode, 'setCameraRigMode', changedProps);
        checkMethodDiff(oldProps.setCameraRigParameter, newProps.setCameraRigParameter, 'setCameraRigParameter', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCameraPropsHandler;
}());
/**
 * This is the base class of all the camera used in the application.
 *
 * This code has been generated
 */
var FiberCamera = /** @class */ (function () {
    function FiberCamera() {
        this.isTargetable = false;
        this.propsHandlers = [new FiberCameraPropsHandler(), new FiberNodePropsHandler()];
    }
    FiberCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Camera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'setActiveOnSceneIfNoneActive',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberCamera',
    };
    return FiberCamera;
}());
var FiberTargetCameraPropsHandler = /** @class */ (function () {
    function FiberTargetCameraPropsHandler() {
    }
    FiberTargetCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.cameraDirection, newProps.cameraDirection, 'cameraDirection', changedProps);
        checkPrimitiveDiff(oldProps['cameraDirection-x'], newProps['cameraDirection-x'], 'cameraDirection.x', changedProps);
        checkPrimitiveDiff(oldProps['cameraDirection-y'], newProps['cameraDirection-y'], 'cameraDirection.y', changedProps);
        checkPrimitiveDiff(oldProps['cameraDirection-z'], newProps['cameraDirection-z'], 'cameraDirection.z', changedProps);
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreTargetCamera.cameraRotation.
        checkPrimitiveDiff(oldProps.ignoreParentScaling, newProps.ignoreParentScaling, 'ignoreParentScaling', changedProps);
        checkPrimitiveDiff(oldProps.inverseRotationSpeed, newProps.inverseRotationSpeed, 'inverseRotationSpeed', changedProps);
        checkPrimitiveDiff(oldProps.invertRotation, newProps.invertRotation, 'invertRotation', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreTargetCamera.lockedTarget.
        checkPrimitiveDiff(oldProps.noRotationConstraint, newProps.noRotationConstraint, 'noRotationConstraint', changedProps);
        checkVector3Diff(oldProps.rotation, newProps.rotation, 'rotation', changedProps);
        checkPrimitiveDiff(oldProps['rotation-x'], newProps['rotation-x'], 'rotation.x', changedProps);
        checkPrimitiveDiff(oldProps['rotation-y'], newProps['rotation-y'], 'rotation.y', changedProps);
        checkPrimitiveDiff(oldProps['rotation-z'], newProps['rotation-z'], 'rotation.z', changedProps);
        checkQuaternionDiff(oldProps.rotationQuaternion, newProps.rotationQuaternion, 'rotationQuaternion', changedProps);
        checkPrimitiveDiff(oldProps.speed, newProps.speed, 'speed', changedProps);
        checkVector3Diff(oldProps.target, newProps.target, 'target', changedProps);
        checkPrimitiveDiff(oldProps['target-x'], newProps['target-x'], 'target.x', changedProps);
        checkPrimitiveDiff(oldProps['target-y'], newProps['target-y'], 'target.y', changedProps);
        checkPrimitiveDiff(oldProps['target-z'], newProps['target-z'], 'target.z', changedProps);
        checkPrimitiveDiff(oldProps.updateUpVectorFromRotation, newProps.updateUpVectorFromRotation, 'updateUpVectorFromRotation', changedProps);
        checkMethodDiff(oldProps.setTarget, newProps.setTarget, 'setTarget', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTargetCameraPropsHandler;
}());
/**
 * A target camera takes a mesh or position as a target and continues to look at it while it moves.
 * This is the base of the follow, arc rotate cameras and Free camera
 *
 * This code has been generated
 */
var FiberTargetCamera = /** @class */ (function () {
    function FiberTargetCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTargetCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTargetCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTargetCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TargetCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'setActiveOnSceneIfNoneActive',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberTargetCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberTargetCamera',
    };
    return FiberTargetCamera;
}());
var FiberFreeCameraPropsHandler = /** @class */ (function () {
    function FiberFreeCameraPropsHandler() {
    }
    FiberFreeCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.angularSensibility, newProps.angularSensibility, 'angularSensibility', changedProps);
        checkPrimitiveDiff(oldProps.applyGravity, newProps.applyGravity, 'applyGravity', changedProps);
        checkPrimitiveDiff(oldProps.checkCollisions, newProps.checkCollisions, 'checkCollisions', changedProps);
        checkPrimitiveDiff(oldProps.collisionMask, newProps.collisionMask, 'collisionMask', changedProps);
        checkVector3Diff(oldProps.ellipsoid, newProps.ellipsoid, 'ellipsoid', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-x'], newProps['ellipsoid-x'], 'ellipsoid.x', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-y'], newProps['ellipsoid-y'], 'ellipsoid.y', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-z'], newProps['ellipsoid-z'], 'ellipsoid.z', changedProps);
        checkVector3Diff(oldProps.ellipsoidOffset, newProps.ellipsoidOffset, 'ellipsoidOffset', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-x'], newProps['ellipsoidOffset-x'], 'ellipsoidOffset.x', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-y'], newProps['ellipsoidOffset-y'], 'ellipsoidOffset.y', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-z'], newProps['ellipsoidOffset-z'], 'ellipsoidOffset.z', changedProps);
        // type: 'BabylonjsCoreFreeCameraInputsManager' property (not coded) BabylonjsCoreFreeCamera.inputs.
        checkNumericArrayDiff(oldProps.keysDown, newProps.keysDown, 'keysDown', changedProps);
        checkNumericArrayDiff(oldProps.keysDownward, newProps.keysDownward, 'keysDownward', changedProps);
        checkNumericArrayDiff(oldProps.keysLeft, newProps.keysLeft, 'keysLeft', changedProps);
        checkNumericArrayDiff(oldProps.keysRight, newProps.keysRight, 'keysRight', changedProps);
        checkNumericArrayDiff(oldProps.keysRotateLeft, newProps.keysRotateLeft, 'keysRotateLeft', changedProps);
        checkNumericArrayDiff(oldProps.keysRotateRight, newProps.keysRotateRight, 'keysRotateRight', changedProps);
        checkNumericArrayDiff(oldProps.keysUp, newProps.keysUp, 'keysUp', changedProps);
        checkNumericArrayDiff(oldProps.keysUpward, newProps.keysUpward, 'keysUpward', changedProps);
        checkLambdaDiff(oldProps.onCollide, newProps.onCollide, 'onCollide', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFreeCameraPropsHandler;
}());
/**
 * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
 * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.
 *
 * This code has been generated
 */
var FiberFreeCamera = /** @class */ (function () {
    function FiberFreeCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberFreeCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFreeCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFreeCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FreeCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'setActiveOnSceneIfNoneActive',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberFreeCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberFreeCamera',
    };
    return FiberFreeCamera;
}());
var FiberWebXRCameraPropsHandler = /** @class */ (function () {
    function FiberWebXRCameraPropsHandler() {
    }
    FiberWebXRCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.compensateOnFirstFrame, newProps.compensateOnFirstFrame, 'compensateOnFirstFrame', changedProps);
        checkObservableDiff(oldProps.onAfterCameraTeleport, newProps.onAfterCameraTeleport, 'onAfterCameraTeleport', changedProps);
        checkObservableDiff(oldProps.onBeforeCameraTeleport, newProps.onBeforeCameraTeleport, 'onBeforeCameraTeleport', changedProps);
        checkObservableDiff(oldProps.onTrackingStateChanged, newProps.onTrackingStateChanged, 'onTrackingStateChanged', changedProps);
        checkMethodDiff(oldProps.setTransformationFromNonVRCamera, newProps.setTransformationFromNonVRCamera, 'setTransformationFromNonVRCamera', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberWebXRCameraPropsHandler;
}());
/**
 * WebXR Camera which holds the views for the xrSession
 *
 * This code has been generated
 */
var FiberWebXRCamera = /** @class */ (function () {
    function FiberWebXRCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberWebXRCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberWebXRCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberWebXRCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberWebXRCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'WebXRCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: '_xrSessionManager',
                type: 'BabylonjsCoreWebXRSessionManager',
                optional: false,
            },
        ],
    };
    FiberWebXRCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberWebXRCamera',
    };
    return FiberWebXRCamera;
}());
var FiberTouchCameraPropsHandler = /** @class */ (function () {
    function FiberTouchCameraPropsHandler() {
    }
    FiberTouchCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.touchAngularSensibility, newProps.touchAngularSensibility, 'touchAngularSensibility', changedProps);
        checkPrimitiveDiff(oldProps.touchMoveSensibility, newProps.touchMoveSensibility, 'touchMoveSensibility', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTouchCameraPropsHandler;
}());
/**
 * This represents a FPS type of camera controlled by touch.
 * This is like a universal camera minus the Gamepad controls.
 *
 * This code has been generated
 */
var FiberTouchCamera = /** @class */ (function () {
    function FiberTouchCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTouchCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTouchCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTouchCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TouchCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTouchCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberTouchCamera',
    };
    return FiberTouchCamera;
}());
var FiberUniversalCameraPropsHandler = /** @class */ (function () {
    function FiberUniversalCameraPropsHandler() {
    }
    FiberUniversalCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.gamepadAngularSensibility, newProps.gamepadAngularSensibility, 'gamepadAngularSensibility', changedProps);
        checkPrimitiveDiff(oldProps.gamepadMoveSensibility, newProps.gamepadMoveSensibility, 'gamepadMoveSensibility', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberUniversalCameraPropsHandler;
}());
/**
 * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
 * which still works and will still be found in many Playgrounds.
 *
 * This code has been generated
 */
var FiberUniversalCamera = /** @class */ (function () {
    function FiberUniversalCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberUniversalCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberUniversalCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberUniversalCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'UniversalCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberUniversalCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberUniversalCamera',
    };
    return FiberUniversalCamera;
}());
var FiberGamepadCameraPropsHandler = /** @class */ (function () {
    function FiberGamepadCameraPropsHandler() {
    }
    FiberGamepadCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberGamepadCameraPropsHandler;
}());
/**
 * This represents a FPS type of camera. This is only here for back compat purpose.
 * Please use the UniversalCamera instead as both are identical.
 *
 * This code has been generated
 */
var FiberGamepadCamera = /** @class */ (function () {
    function FiberGamepadCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberGamepadCameraPropsHandler(),
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGamepadCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGamepadCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGamepadCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GamepadCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGamepadCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberGamepadCamera',
    };
    return FiberGamepadCamera;
}());
var FiberAnaglyphGamepadCameraPropsHandler = /** @class */ (function () {
    function FiberAnaglyphGamepadCameraPropsHandler() {
    }
    FiberAnaglyphGamepadCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberAnaglyphGamepadCameraPropsHandler;
}());
/**
 * Camera used to simulate anaglyphic rendering (based on GamepadCamera)
 *
 * This code has been generated
 */
var FiberAnaglyphGamepadCamera = /** @class */ (function () {
    function FiberAnaglyphGamepadCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberAnaglyphGamepadCameraPropsHandler(),
            new FiberGamepadCameraPropsHandler(),
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberAnaglyphGamepadCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAnaglyphGamepadCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAnaglyphGamepadCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AnaglyphGamepadCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberAnaglyphGamepadCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberAnaglyphGamepadCamera',
    };
    return FiberAnaglyphGamepadCamera;
}());
var FiberStereoscopicGamepadCameraPropsHandler = /** @class */ (function () {
    function FiberStereoscopicGamepadCameraPropsHandler() {
    }
    FiberStereoscopicGamepadCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberStereoscopicGamepadCameraPropsHandler;
}());
/**
 * Camera used to simulate stereoscopic rendering (based on GamepadCamera)
 *
 * This code has been generated
 */
var FiberStereoscopicGamepadCamera = /** @class */ (function () {
    function FiberStereoscopicGamepadCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberStereoscopicGamepadCameraPropsHandler(),
            new FiberGamepadCameraPropsHandler(),
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberStereoscopicGamepadCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicGamepadCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicGamepadCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicGamepadCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'isStereoscopicSideBySide',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberStereoscopicGamepadCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberStereoscopicGamepadCamera',
    };
    return FiberStereoscopicGamepadCamera;
}());
var FiberAnaglyphUniversalCameraPropsHandler = /** @class */ (function () {
    function FiberAnaglyphUniversalCameraPropsHandler() {
    }
    FiberAnaglyphUniversalCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberAnaglyphUniversalCameraPropsHandler;
}());
/**
 * Camera used to simulate anaglyphic rendering (based on UniversalCamera)
 *
 * This code has been generated
 */
var FiberAnaglyphUniversalCamera = /** @class */ (function () {
    function FiberAnaglyphUniversalCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberAnaglyphUniversalCameraPropsHandler(),
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberAnaglyphUniversalCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAnaglyphUniversalCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAnaglyphUniversalCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AnaglyphUniversalCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberAnaglyphUniversalCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberAnaglyphUniversalCamera',
    };
    return FiberAnaglyphUniversalCamera;
}());
var FiberStereoscopicUniversalCameraPropsHandler = /** @class */ (function () {
    function FiberStereoscopicUniversalCameraPropsHandler() {
    }
    FiberStereoscopicUniversalCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberStereoscopicUniversalCameraPropsHandler;
}());
/**
 * Camera used to simulate stereoscopic rendering (based on UniversalCamera)
 *
 * This code has been generated
 */
var FiberStereoscopicUniversalCamera = /** @class */ (function () {
    function FiberStereoscopicUniversalCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberStereoscopicUniversalCameraPropsHandler(),
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberStereoscopicUniversalCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicUniversalCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicUniversalCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicUniversalCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'isStereoscopicSideBySide',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberStereoscopicUniversalCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberStereoscopicUniversalCamera',
    };
    return FiberStereoscopicUniversalCamera;
}());
var FiberStereoscopicScreenUniversalCameraPropsHandler = /** @class */ (function () {
    function FiberStereoscopicScreenUniversalCameraPropsHandler() {
    }
    FiberStereoscopicScreenUniversalCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.distanceBetweenEyes, newProps.distanceBetweenEyes, 'distanceBetweenEyes', changedProps);
        checkPrimitiveDiff(oldProps.distanceToProjectionPlane, newProps.distanceToProjectionPlane, 'distanceToProjectionPlane', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberStereoscopicScreenUniversalCameraPropsHandler;
}());
/**
 * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)
 *
 * This code has been generated
 */
var FiberStereoscopicScreenUniversalCamera = /** @class */ (function () {
    function FiberStereoscopicScreenUniversalCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberStereoscopicScreenUniversalCameraPropsHandler(),
            new FiberUniversalCameraPropsHandler(),
            new FiberTouchCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberStereoscopicScreenUniversalCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicScreenUniversalCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicScreenUniversalCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicScreenUniversalCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'distanceToProjectionPlane',
                type: 'number',
                optional: true,
            },
            {
                name: 'distanceBetweenEyes',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberStereoscopicScreenUniversalCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberStereoscopicScreenUniversalCamera',
    };
    return FiberStereoscopicScreenUniversalCamera;
}());
var FiberDeviceOrientationCameraPropsHandler = /** @class */ (function () {
    function FiberDeviceOrientationCameraPropsHandler() {
    }
    FiberDeviceOrientationCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.disablePointerInputWhenUsingDeviceOrientation, newProps.disablePointerInputWhenUsingDeviceOrientation, 'disablePointerInputWhenUsingDeviceOrientation', changedProps);
        checkMethodDiff(oldProps.enableHorizontalDragging, newProps.enableHorizontalDragging, 'enableHorizontalDragging', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDeviceOrientationCameraPropsHandler;
}());
/**
 * This is a camera specifically designed to react to device orientation events such as a modern mobile device
 * being tilted forward or back and left or right.
 *
 * This code has been generated
 */
var FiberDeviceOrientationCamera = /** @class */ (function () {
    function FiberDeviceOrientationCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberDeviceOrientationCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberDeviceOrientationCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDeviceOrientationCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDeviceOrientationCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DeviceOrientationCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberDeviceOrientationCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberDeviceOrientationCamera',
    };
    return FiberDeviceOrientationCamera;
}());
var FiberVRDeviceOrientationFreeCameraPropsHandler = /** @class */ (function () {
    function FiberVRDeviceOrientationFreeCameraPropsHandler() {
    }
    FiberVRDeviceOrientationFreeCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVRDeviceOrientationFreeCameraPropsHandler;
}());
/**
 * Camera used to simulate VR rendering (based on FreeCamera)
 *
 * This code has been generated
 */
var FiberVRDeviceOrientationFreeCamera = /** @class */ (function () {
    function FiberVRDeviceOrientationFreeCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberVRDeviceOrientationFreeCameraPropsHandler(),
            new FiberDeviceOrientationCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberVRDeviceOrientationFreeCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVRDeviceOrientationFreeCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVRDeviceOrientationFreeCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VRDeviceOrientationFreeCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'compensateDistortion',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'vrCameraMetrics',
                type: 'BabylonjsCoreVRCameraMetrics',
                optional: true,
            },
        ],
    };
    FiberVRDeviceOrientationFreeCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberVRDeviceOrientationFreeCamera',
    };
    return FiberVRDeviceOrientationFreeCamera;
}());
var FiberVRDeviceOrientationGamepadCameraPropsHandler = /** @class */ (function () {
    function FiberVRDeviceOrientationGamepadCameraPropsHandler() {
    }
    FiberVRDeviceOrientationGamepadCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVRDeviceOrientationGamepadCameraPropsHandler;
}());
/**
 * Camera used to simulate VR rendering (based on VRDeviceOrientationFreeCamera)
 *
 * This code has been generated
 */
var FiberVRDeviceOrientationGamepadCamera = /** @class */ (function () {
    function FiberVRDeviceOrientationGamepadCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberVRDeviceOrientationGamepadCameraPropsHandler(),
            new FiberVRDeviceOrientationFreeCameraPropsHandler(),
            new FiberDeviceOrientationCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberVRDeviceOrientationGamepadCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVRDeviceOrientationGamepadCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVRDeviceOrientationGamepadCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VRDeviceOrientationGamepadCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'compensateDistortion',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'vrCameraMetrics',
                type: 'BabylonjsCoreVRCameraMetrics',
                optional: true,
            },
        ],
    };
    FiberVRDeviceOrientationGamepadCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberVRDeviceOrientationGamepadCamera',
    };
    return FiberVRDeviceOrientationGamepadCamera;
}());
var FiberAnaglyphFreeCameraPropsHandler = /** @class */ (function () {
    function FiberAnaglyphFreeCameraPropsHandler() {
    }
    FiberAnaglyphFreeCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberAnaglyphFreeCameraPropsHandler;
}());
/**
 * Camera used to simulate anaglyphic rendering (based on FreeCamera)
 *
 * This code has been generated
 */
var FiberAnaglyphFreeCamera = /** @class */ (function () {
    function FiberAnaglyphFreeCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberAnaglyphFreeCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberAnaglyphFreeCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAnaglyphFreeCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAnaglyphFreeCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AnaglyphFreeCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberAnaglyphFreeCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberAnaglyphFreeCamera',
    };
    return FiberAnaglyphFreeCamera;
}());
var FiberStereoscopicFreeCameraPropsHandler = /** @class */ (function () {
    function FiberStereoscopicFreeCameraPropsHandler() {
    }
    FiberStereoscopicFreeCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberStereoscopicFreeCameraPropsHandler;
}());
/**
 * Camera used to simulate stereoscopic rendering (based on FreeCamera)
 *
 * This code has been generated
 */
var FiberStereoscopicFreeCamera = /** @class */ (function () {
    function FiberStereoscopicFreeCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberStereoscopicFreeCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberStereoscopicFreeCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicFreeCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicFreeCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicFreeCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'isStereoscopicSideBySide',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberStereoscopicFreeCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberStereoscopicFreeCamera',
    };
    return FiberStereoscopicFreeCamera;
}());
var FiberVirtualJoysticksCameraPropsHandler = /** @class */ (function () {
    function FiberVirtualJoysticksCameraPropsHandler() {
    }
    FiberVirtualJoysticksCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVirtualJoysticksCameraPropsHandler;
}());
/**
 * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
 * It is identical to the Free Camera and simply adds by default a virtual joystick.
 * Virtual Joysticks are on-screen 2D graphics that are used to control the camera or other scene items.
 *
 * This code has been generated
 */
var FiberVirtualJoysticksCamera = /** @class */ (function () {
    function FiberVirtualJoysticksCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberVirtualJoysticksCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberVirtualJoysticksCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVirtualJoysticksCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVirtualJoysticksCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VirtualJoysticksCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberVirtualJoysticksCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberVirtualJoysticksCamera',
    };
    return FiberVirtualJoysticksCamera;
}());
var FiberWebVRFreeCameraPropsHandler = /** @class */ (function () {
    function FiberWebVRFreeCameraPropsHandler() {
    }
    FiberWebVRFreeCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreWebVRController[]' property (not coded) BabylonjsCoreWebVRFreeCamera.controllers.
        checkVector3Diff(oldProps.devicePosition, newProps.devicePosition, 'devicePosition', changedProps);
        checkPrimitiveDiff(oldProps['devicePosition-x'], newProps['devicePosition-x'], 'devicePosition.x', changedProps);
        checkPrimitiveDiff(oldProps['devicePosition-y'], newProps['devicePosition-y'], 'devicePosition.y', changedProps);
        checkPrimitiveDiff(oldProps['devicePosition-z'], newProps['devicePosition-z'], 'devicePosition.z', changedProps);
        checkQuaternionDiff(oldProps.deviceRotationQuaternion, newProps.deviceRotationQuaternion, 'deviceRotationQuaternion', changedProps);
        checkPrimitiveDiff(oldProps.deviceScaleFactor, newProps.deviceScaleFactor, 'deviceScaleFactor', changedProps);
        checkObservableDiff(oldProps.onControllerMeshLoadedObservable, newProps.onControllerMeshLoadedObservable, 'onControllerMeshLoadedObservable', changedProps);
        checkObservableDiff(oldProps.onControllersAttachedObservable, newProps.onControllersAttachedObservable, 'onControllersAttachedObservable', changedProps);
        checkObservableDiff(oldProps.onPoseUpdatedFromDeviceObservable, newProps.onPoseUpdatedFromDeviceObservable, 'onPoseUpdatedFromDeviceObservable', changedProps);
        // type: 'BabylonjsCoreDevicePose' property (not coded) BabylonjsCoreWebVRFreeCamera.rawPose.
        checkPrimitiveDiff(oldProps.rigParenting, newProps.rigParenting, 'rigParenting', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberWebVRFreeCameraPropsHandler;
}());
/**
 * This represents a WebVR camera.
 * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
 *
 * This code has been generated
 */
var FiberWebVRFreeCamera = /** @class */ (function () {
    function FiberWebVRFreeCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberWebVRFreeCameraPropsHandler(),
            new FiberFreeCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberWebVRFreeCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberWebVRFreeCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberWebVRFreeCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'WebVRFreeCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: '_webVROptions',
                type: 'BabylonjsCoreWebVROptions',
                optional: true,
            },
        ],
    };
    FiberWebVRFreeCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberWebVRFreeCamera',
    };
    return FiberWebVRFreeCamera;
}());
var FiberArcRotateCameraPropsHandler = /** @class */ (function () {
    function FiberArcRotateCameraPropsHandler() {
    }
    FiberArcRotateCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.allowUpsideDown, newProps.allowUpsideDown, 'allowUpsideDown', changedProps);
        checkPrimitiveDiff(oldProps.alpha, newProps.alpha, 'alpha', changedProps);
        checkPrimitiveDiff(oldProps.angularSensibilityX, newProps.angularSensibilityX, 'angularSensibilityX', changedProps);
        checkPrimitiveDiff(oldProps.angularSensibilityY, newProps.angularSensibilityY, 'angularSensibilityY', changedProps);
        checkPrimitiveDiff(oldProps.beta, newProps.beta, 'beta', changedProps);
        checkPrimitiveDiff(oldProps.checkCollisions, newProps.checkCollisions, 'checkCollisions', changedProps);
        checkVector3Diff(oldProps.collisionRadius, newProps.collisionRadius, 'collisionRadius', changedProps);
        checkPrimitiveDiff(oldProps['collisionRadius-x'], newProps['collisionRadius-x'], 'collisionRadius.x', changedProps);
        checkPrimitiveDiff(oldProps['collisionRadius-y'], newProps['collisionRadius-y'], 'collisionRadius.y', changedProps);
        checkPrimitiveDiff(oldProps['collisionRadius-z'], newProps['collisionRadius-z'], 'collisionRadius.z', changedProps);
        checkPrimitiveDiff(oldProps.inertialAlphaOffset, newProps.inertialAlphaOffset, 'inertialAlphaOffset', changedProps);
        checkPrimitiveDiff(oldProps.inertialBetaOffset, newProps.inertialBetaOffset, 'inertialBetaOffset', changedProps);
        checkPrimitiveDiff(oldProps.inertialPanningX, newProps.inertialPanningX, 'inertialPanningX', changedProps);
        checkPrimitiveDiff(oldProps.inertialPanningY, newProps.inertialPanningY, 'inertialPanningY', changedProps);
        checkPrimitiveDiff(oldProps.inertialRadiusOffset, newProps.inertialRadiusOffset, 'inertialRadiusOffset', changedProps);
        // type: 'BabylonjsCoreArcRotateCameraInputsManager' property (not coded) BabylonjsCoreArcRotateCamera.inputs.
        checkNumericArrayDiff(oldProps.keysDown, newProps.keysDown, 'keysDown', changedProps);
        checkNumericArrayDiff(oldProps.keysLeft, newProps.keysLeft, 'keysLeft', changedProps);
        checkNumericArrayDiff(oldProps.keysRight, newProps.keysRight, 'keysRight', changedProps);
        checkNumericArrayDiff(oldProps.keysUp, newProps.keysUp, 'keysUp', changedProps);
        checkPrimitiveDiff(oldProps.lowerAlphaLimit, newProps.lowerAlphaLimit, 'lowerAlphaLimit', changedProps);
        checkPrimitiveDiff(oldProps.lowerBetaLimit, newProps.lowerBetaLimit, 'lowerBetaLimit', changedProps);
        checkPrimitiveDiff(oldProps.lowerRadiusLimit, newProps.lowerRadiusLimit, 'lowerRadiusLimit', changedProps);
        checkPrimitiveDiff(oldProps.mapPanning, newProps.mapPanning, 'mapPanning', changedProps);
        checkLambdaDiff(oldProps.onCollide, newProps.onCollide, 'onCollide', changedProps);
        checkObservableDiff(oldProps.onMeshTargetChangedObservable, newProps.onMeshTargetChangedObservable, 'onMeshTargetChangedObservable', changedProps);
        checkVector3Diff(oldProps.panningAxis, newProps.panningAxis, 'panningAxis', changedProps);
        checkPrimitiveDiff(oldProps['panningAxis-x'], newProps['panningAxis-x'], 'panningAxis.x', changedProps);
        checkPrimitiveDiff(oldProps['panningAxis-y'], newProps['panningAxis-y'], 'panningAxis.y', changedProps);
        checkPrimitiveDiff(oldProps['panningAxis-z'], newProps['panningAxis-z'], 'panningAxis.z', changedProps);
        checkPrimitiveDiff(oldProps.panningDistanceLimit, newProps.panningDistanceLimit, 'panningDistanceLimit', changedProps);
        checkPrimitiveDiff(oldProps.panningInertia, newProps.panningInertia, 'panningInertia', changedProps);
        checkVector3Diff(oldProps.panningOriginTarget, newProps.panningOriginTarget, 'panningOriginTarget', changedProps);
        checkPrimitiveDiff(oldProps['panningOriginTarget-x'], newProps['panningOriginTarget-x'], 'panningOriginTarget.x', changedProps);
        checkPrimitiveDiff(oldProps['panningOriginTarget-y'], newProps['panningOriginTarget-y'], 'panningOriginTarget.y', changedProps);
        checkPrimitiveDiff(oldProps['panningOriginTarget-z'], newProps['panningOriginTarget-z'], 'panningOriginTarget.z', changedProps);
        checkPrimitiveDiff(oldProps.panningSensibility, newProps.panningSensibility, 'panningSensibility', changedProps);
        checkPrimitiveDiff(oldProps.pinchDeltaPercentage, newProps.pinchDeltaPercentage, 'pinchDeltaPercentage', changedProps);
        checkPrimitiveDiff(oldProps.pinchPrecision, newProps.pinchPrecision, 'pinchPrecision', changedProps);
        checkPrimitiveDiff(oldProps.pinchToPanMaxDistance, newProps.pinchToPanMaxDistance, 'pinchToPanMaxDistance', changedProps);
        checkVector3Diff(oldProps.position, newProps.position, 'position', changedProps);
        checkPrimitiveDiff(oldProps['position-x'], newProps['position-x'], 'position.x', changedProps);
        checkPrimitiveDiff(oldProps['position-y'], newProps['position-y'], 'position.y', changedProps);
        checkPrimitiveDiff(oldProps['position-z'], newProps['position-z'], 'position.z', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkVector3Diff(oldProps.target, newProps.target, 'target', changedProps);
        checkPrimitiveDiff(oldProps['target-x'], newProps['target-x'], 'target.x', changedProps);
        checkPrimitiveDiff(oldProps['target-y'], newProps['target-y'], 'target.y', changedProps);
        checkPrimitiveDiff(oldProps['target-z'], newProps['target-z'], 'target.z', changedProps);
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCoreArcRotateCamera.targetHost.
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreArcRotateCamera.targetScreenOffset.
        checkPrimitiveDiff(oldProps.upperAlphaLimit, newProps.upperAlphaLimit, 'upperAlphaLimit', changedProps);
        checkPrimitiveDiff(oldProps.upperBetaLimit, newProps.upperBetaLimit, 'upperBetaLimit', changedProps);
        checkPrimitiveDiff(oldProps.upperRadiusLimit, newProps.upperRadiusLimit, 'upperRadiusLimit', changedProps);
        checkVector3Diff(oldProps.upVector, newProps.upVector, 'upVector', changedProps);
        checkPrimitiveDiff(oldProps['upVector-x'], newProps['upVector-x'], 'upVector.x', changedProps);
        checkPrimitiveDiff(oldProps['upVector-y'], newProps['upVector-y'], 'upVector.y', changedProps);
        checkPrimitiveDiff(oldProps['upVector-z'], newProps['upVector-z'], 'upVector.z', changedProps);
        checkPrimitiveDiff(oldProps.useAutoRotationBehavior, newProps.useAutoRotationBehavior, 'useAutoRotationBehavior', changedProps);
        checkPrimitiveDiff(oldProps.useBouncingBehavior, newProps.useBouncingBehavior, 'useBouncingBehavior', changedProps);
        checkPrimitiveDiff(oldProps.useFramingBehavior, newProps.useFramingBehavior, 'useFramingBehavior', changedProps);
        checkPrimitiveDiff(oldProps.useInputToRestoreState, newProps.useInputToRestoreState, 'useInputToRestoreState', changedProps);
        checkPrimitiveDiff(oldProps.useNaturalPinchZoom, newProps.useNaturalPinchZoom, 'useNaturalPinchZoom', changedProps);
        checkPrimitiveDiff(oldProps.wheelDeltaPercentage, newProps.wheelDeltaPercentage, 'wheelDeltaPercentage', changedProps);
        checkPrimitiveDiff(oldProps.wheelPrecision, newProps.wheelPrecision, 'wheelPrecision', changedProps);
        checkPrimitiveDiff(oldProps.zoomOnFactor, newProps.zoomOnFactor, 'zoomOnFactor', changedProps);
        checkPrimitiveDiff(oldProps.zoomToMouseLocation, newProps.zoomToMouseLocation, 'zoomToMouseLocation', changedProps);
        checkMethodDiff(oldProps.setPosition, newProps.setPosition, 'setPosition', changedProps);
        checkMethodDiff(oldProps.setTarget, newProps.setTarget, 'setTarget', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberArcRotateCameraPropsHandler;
}());
/**
 * This represents an orbital type of camera.
 *
 * This camera always points towards a given target position and can be rotated around that target with the target as the centre of rotation. It can be controlled with cursors and mouse, or with touch events.
 * Think of this camera as one orbiting its target position, or more imaginatively as a spy satellite orbiting the earth. Its position relative to the target (earth) can be set by three parameters, alpha (radians) the longitudinal rotation, beta (radians) the latitudinal rotation and radius the distance from the target position.
 *
 * This code has been generated
 */
var FiberArcRotateCamera = /** @class */ (function () {
    function FiberArcRotateCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberArcRotateCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberArcRotateCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberArcRotateCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberArcRotateCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ArcRotateCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'alpha',
                type: 'number',
                optional: false,
            },
            {
                name: 'beta',
                type: 'number',
                optional: false,
            },
            {
                name: 'radius',
                type: 'number',
                optional: false,
            },
            {
                name: 'target',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'setActiveOnSceneIfNoneActive',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberArcRotateCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberArcRotateCamera',
    };
    return FiberArcRotateCamera;
}());
var FiberAnaglyphArcRotateCameraPropsHandler = /** @class */ (function () {
    function FiberAnaglyphArcRotateCameraPropsHandler() {
    }
    FiberAnaglyphArcRotateCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberAnaglyphArcRotateCameraPropsHandler;
}());
/**
 * Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
 *
 * This code has been generated
 */
var FiberAnaglyphArcRotateCamera = /** @class */ (function () {
    function FiberAnaglyphArcRotateCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberAnaglyphArcRotateCameraPropsHandler(),
            new FiberArcRotateCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberAnaglyphArcRotateCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAnaglyphArcRotateCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAnaglyphArcRotateCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AnaglyphArcRotateCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'alpha',
                type: 'number',
                optional: false,
            },
            {
                name: 'beta',
                type: 'number',
                optional: false,
            },
            {
                name: 'radius',
                type: 'number',
                optional: false,
            },
            {
                name: 'target',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberAnaglyphArcRotateCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberAnaglyphArcRotateCamera',
    };
    return FiberAnaglyphArcRotateCamera;
}());
var FiberStereoscopicArcRotateCameraPropsHandler = /** @class */ (function () {
    function FiberStereoscopicArcRotateCameraPropsHandler() {
    }
    FiberStereoscopicArcRotateCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberStereoscopicArcRotateCameraPropsHandler;
}());
/**
 * Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
 *
 * This code has been generated
 */
var FiberStereoscopicArcRotateCamera = /** @class */ (function () {
    function FiberStereoscopicArcRotateCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberStereoscopicArcRotateCameraPropsHandler(),
            new FiberArcRotateCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberStereoscopicArcRotateCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicArcRotateCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicArcRotateCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicArcRotateCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'alpha',
                type: 'number',
                optional: false,
            },
            {
                name: 'beta',
                type: 'number',
                optional: false,
            },
            {
                name: 'radius',
                type: 'number',
                optional: false,
            },
            {
                name: 'target',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'interaxialDistance',
                type: 'number',
                optional: false,
            },
            {
                name: 'isStereoscopicSideBySide',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberStereoscopicArcRotateCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberStereoscopicArcRotateCamera',
    };
    return FiberStereoscopicArcRotateCamera;
}());
var FiberVRDeviceOrientationArcRotateCameraPropsHandler = /** @class */ (function () {
    function FiberVRDeviceOrientationArcRotateCameraPropsHandler() {
    }
    FiberVRDeviceOrientationArcRotateCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVRDeviceOrientationArcRotateCameraPropsHandler;
}());
/**
 * Camera used to simulate VR rendering (based on ArcRotateCamera)
 *
 * This code has been generated
 */
var FiberVRDeviceOrientationArcRotateCamera = /** @class */ (function () {
    function FiberVRDeviceOrientationArcRotateCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberVRDeviceOrientationArcRotateCameraPropsHandler(),
            new FiberArcRotateCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberVRDeviceOrientationArcRotateCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVRDeviceOrientationArcRotateCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVRDeviceOrientationArcRotateCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VRDeviceOrientationArcRotateCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'alpha',
                type: 'number',
                optional: false,
            },
            {
                name: 'beta',
                type: 'number',
                optional: false,
            },
            {
                name: 'radius',
                type: 'number',
                optional: false,
            },
            {
                name: 'target',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'compensateDistortion',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'vrCameraMetrics',
                type: 'BabylonjsCoreVRCameraMetrics',
                optional: true,
            },
        ],
    };
    FiberVRDeviceOrientationArcRotateCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberVRDeviceOrientationArcRotateCamera',
    };
    return FiberVRDeviceOrientationArcRotateCamera;
}());
var FiberFlyCameraPropsHandler = /** @class */ (function () {
    function FiberFlyCameraPropsHandler() {
    }
    FiberFlyCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.angularSensibility, newProps.angularSensibility, 'angularSensibility', changedProps);
        checkPrimitiveDiff(oldProps.applyGravity, newProps.applyGravity, 'applyGravity', changedProps);
        checkPrimitiveDiff(oldProps.bankedTurn, newProps.bankedTurn, 'bankedTurn', changedProps);
        checkPrimitiveDiff(oldProps.bankedTurnLimit, newProps.bankedTurnLimit, 'bankedTurnLimit', changedProps);
        checkPrimitiveDiff(oldProps.bankedTurnMultiplier, newProps.bankedTurnMultiplier, 'bankedTurnMultiplier', changedProps);
        checkVector3Diff(oldProps.cameraDirection, newProps.cameraDirection, 'cameraDirection', changedProps);
        checkPrimitiveDiff(oldProps['cameraDirection-x'], newProps['cameraDirection-x'], 'cameraDirection.x', changedProps);
        checkPrimitiveDiff(oldProps['cameraDirection-y'], newProps['cameraDirection-y'], 'cameraDirection.y', changedProps);
        checkPrimitiveDiff(oldProps['cameraDirection-z'], newProps['cameraDirection-z'], 'cameraDirection.z', changedProps);
        checkPrimitiveDiff(oldProps.checkCollisions, newProps.checkCollisions, 'checkCollisions', changedProps);
        checkPrimitiveDiff(oldProps.collisionMask, newProps.collisionMask, 'collisionMask', changedProps);
        checkVector3Diff(oldProps.ellipsoid, newProps.ellipsoid, 'ellipsoid', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-x'], newProps['ellipsoid-x'], 'ellipsoid.x', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-y'], newProps['ellipsoid-y'], 'ellipsoid.y', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoid-z'], newProps['ellipsoid-z'], 'ellipsoid.z', changedProps);
        checkVector3Diff(oldProps.ellipsoidOffset, newProps.ellipsoidOffset, 'ellipsoidOffset', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-x'], newProps['ellipsoidOffset-x'], 'ellipsoidOffset.x', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-y'], newProps['ellipsoidOffset-y'], 'ellipsoidOffset.y', changedProps);
        checkPrimitiveDiff(oldProps['ellipsoidOffset-z'], newProps['ellipsoidOffset-z'], 'ellipsoidOffset.z', changedProps);
        // type: 'BabylonjsCoreFlyCameraInputsManager' property (not coded) BabylonjsCoreFlyCamera.inputs.
        checkNumericArrayDiff(oldProps.keysBackward, newProps.keysBackward, 'keysBackward', changedProps);
        checkNumericArrayDiff(oldProps.keysDown, newProps.keysDown, 'keysDown', changedProps);
        checkNumericArrayDiff(oldProps.keysForward, newProps.keysForward, 'keysForward', changedProps);
        checkNumericArrayDiff(oldProps.keysLeft, newProps.keysLeft, 'keysLeft', changedProps);
        checkNumericArrayDiff(oldProps.keysRight, newProps.keysRight, 'keysRight', changedProps);
        checkNumericArrayDiff(oldProps.keysUp, newProps.keysUp, 'keysUp', changedProps);
        checkLambdaDiff(oldProps.onCollide, newProps.onCollide, 'onCollide', changedProps);
        checkPrimitiveDiff(oldProps.rollCorrect, newProps.rollCorrect, 'rollCorrect', changedProps);
        checkQuaternionDiff(oldProps.rotationQuaternion, newProps.rotationQuaternion, 'rotationQuaternion', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFlyCameraPropsHandler;
}());
/**
 * This is a flying camera, designed for 3D movement and rotation in all directions,
 * such as in a 3D Space Shooter or a Flight Simulator.
 *
 * This code has been generated
 */
var FiberFlyCamera = /** @class */ (function () {
    function FiberFlyCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberFlyCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberFlyCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFlyCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFlyCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FlyCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'setActiveOnSceneIfNoneActive',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberFlyCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberFlyCamera',
    };
    return FiberFlyCamera;
}());
var FiberFollowCameraPropsHandler = /** @class */ (function () {
    function FiberFollowCameraPropsHandler() {
    }
    FiberFollowCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.cameraAcceleration, newProps.cameraAcceleration, 'cameraAcceleration', changedProps);
        checkPrimitiveDiff(oldProps.heightOffset, newProps.heightOffset, 'heightOffset', changedProps);
        // type: 'BabylonjsCoreFollowCameraInputsManager' property (not coded) BabylonjsCoreFollowCamera.inputs.
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCoreFollowCamera.lockedTarget.
        checkPrimitiveDiff(oldProps.lowerHeightOffsetLimit, newProps.lowerHeightOffsetLimit, 'lowerHeightOffsetLimit', changedProps);
        checkPrimitiveDiff(oldProps.lowerRadiusLimit, newProps.lowerRadiusLimit, 'lowerRadiusLimit', changedProps);
        checkPrimitiveDiff(oldProps.lowerRotationOffsetLimit, newProps.lowerRotationOffsetLimit, 'lowerRotationOffsetLimit', changedProps);
        checkPrimitiveDiff(oldProps.maxCameraSpeed, newProps.maxCameraSpeed, 'maxCameraSpeed', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.rotationOffset, newProps.rotationOffset, 'rotationOffset', changedProps);
        checkPrimitiveDiff(oldProps.upperHeightOffsetLimit, newProps.upperHeightOffsetLimit, 'upperHeightOffsetLimit', changedProps);
        checkPrimitiveDiff(oldProps.upperRadiusLimit, newProps.upperRadiusLimit, 'upperRadiusLimit', changedProps);
        checkPrimitiveDiff(oldProps.upperRotationOffsetLimit, newProps.upperRotationOffsetLimit, 'upperRotationOffsetLimit', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFollowCameraPropsHandler;
}());
/**
 * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and
 * an arc rotate version arcFollowCamera are available.
 *
 * This code has been generated
 */
var FiberFollowCamera = /** @class */ (function () {
    function FiberFollowCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberFollowCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberFollowCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFollowCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFollowCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FollowCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'lockedTarget',
                type: 'BabylonjsCoreAbstractMesh',
                optional: true,
            },
        ],
    };
    FiberFollowCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberFollowCamera',
    };
    return FiberFollowCamera;
}());
var FiberArcFollowCameraPropsHandler = /** @class */ (function () {
    function FiberArcFollowCameraPropsHandler() {
    }
    FiberArcFollowCameraPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.alpha, newProps.alpha, 'alpha', changedProps);
        checkPrimitiveDiff(oldProps.beta, newProps.beta, 'beta', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkMethodDiff(oldProps.setMeshTarget, newProps.setMeshTarget, 'setMeshTarget', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberArcFollowCameraPropsHandler;
}());
/**
 * Arc Rotate version of the follow camera.
 * It still follows a Defined mesh but in an Arc Rotate Camera fashion.
 *
 * This code has been generated
 */
var FiberArcFollowCamera = /** @class */ (function () {
    function FiberArcFollowCamera() {
        this.isTargetable = true;
        this.propsHandlers = [
            new FiberArcFollowCameraPropsHandler(),
            new FiberTargetCameraPropsHandler(),
            new FiberCameraPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberArcFollowCamera.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberArcFollowCamera.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberArcFollowCamera.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ArcFollowCamera',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'alpha',
                type: 'number',
                optional: false,
            },
            {
                name: 'beta',
                type: 'number',
                optional: false,
            },
            {
                name: 'radius',
                type: 'number',
                optional: false,
            },
            {
                name: 'target',
                type: 'BabylonjsCoreAbstractMesh',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberArcFollowCamera.Metadata = {
        isCamera: true,
        isNode: true,
        className: 'FiberArcFollowCamera',
    };
    return FiberArcFollowCamera;
}());
/**
 * Creates a box mesh
 * * The parameter `size` sets the size (float) of each box side (default 1)
 * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)
 * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
 * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberBox = /** @class */ (function () {
    function FiberBox() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberBox.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBox.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBox.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateBox',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'size',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'width',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'depth',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'wrap',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'topBaseAt',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'bottomBaseAt',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberBox.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberBox',
    };
    return FiberBox;
}());
/**
 * Creates a tiled box mesh
 *
 * This code has been generated
 */
var FiberTiledBox = /** @class */ (function () {
    function FiberTiledBox() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTiledBox.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTiledBox.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTiledBox.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateTiledBox',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'pattern',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'width',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'depth',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tileSize',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tileWidth',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tileHeight',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'alignHorizontal',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'alignVertical',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTiledBox.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberTiledBox',
    };
    return FiberTiledBox;
}());
/**
 * Creates a sphere mesh
 * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
 * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)
 * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
 * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
 * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberSphere = /** @class */ (function () {
    function FiberSphere() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberSphere.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSphere.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSphere.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateSphere',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'segments',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameter',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameterX',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameterY',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameterZ',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'arc',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'slice',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberSphere.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberSphere',
    };
    return FiberSphere;
}());
/**
 * Creates a plane polygonal mesh.  By default, this is a disc
 * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
 * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
 * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberDisc = /** @class */ (function () {
    function FiberDisc() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberDisc.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDisc.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDisc.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateDisc',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'radius',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tessellation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'arc',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberDisc.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberDisc',
    };
    return FiberDisc;
}());
/**
 * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
 * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
 * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)
 * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
 * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberIcoSphere = /** @class */ (function () {
    function FiberIcoSphere() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberIcoSphere.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberIcoSphere.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberIcoSphere.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateIcoSphere',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'radius',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'radiusX',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'radiusY',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'radiusZ',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'flat',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'subdivisions',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberIcoSphere.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberIcoSphere',
    };
    return FiberIcoSphere;
}());
/**
 * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
 * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
 * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
 * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
 * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
 * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
 * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
 * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
 * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
 * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberRibbon = /** @class */ (function () {
    function FiberRibbon() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberRibbon.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRibbon.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRibbon.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateRibbon',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'pathArray',
                        type: 'BabylonjsCoreVector3[][]',
                        optional: false,
                    },
                    {
                        name: 'closeArray',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'closePath',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'offset',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreMesh',
                        optional: true,
                    },
                    {
                        name: 'invertUV',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'uvs',
                        type: 'BabylonjsCoreVector2[]',
                        optional: true,
                    },
                    {
                        name: 'colors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberRibbon.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberRibbon',
    };
    return FiberRibbon;
}());
/**
 * Creates a cylinder or a cone mesh
 * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
 * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
 * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
 * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
 * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
 * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
 * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
 * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).
 * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
 * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
 * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
 * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
 * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
 * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
 * * If `enclose` is false, a ring surface is one element.
 * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
 * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 *
 * This code has been generated
 */
var FiberCylinder = /** @class */ (function () {
    function FiberCylinder() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberCylinder.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCylinder.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCylinder.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateCylinder',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameterTop',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameterBottom',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'diameter',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tessellation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'subdivisions',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'arc',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'hasRings',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'enclose',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'cap',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberCylinder.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberCylinder',
    };
    return FiberCylinder;
}());
/**
 * Creates a torus mesh
 * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
 * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
 * * The parameter `tessellation` sets the number of torus sides (positive integer, default 16)
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 *
 * This code has been generated
 */
var FiberTorus = /** @class */ (function () {
    function FiberTorus() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTorus.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTorus.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTorus.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateTorus',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'diameter',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'thickness',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tessellation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTorus.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberTorus',
    };
    return FiberTorus;
}());
/**
 * Creates a torus knot mesh
 * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
 * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
 * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
 * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 *
 * This code has been generated
 */
var FiberTorusKnot = /** @class */ (function () {
    function FiberTorusKnot() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTorusKnot.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTorusKnot.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTorusKnot.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateTorusKnot',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'radius',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tube',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'radialSegments',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tubularSegments',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'p',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'q',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTorusKnot.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberTorusKnot',
    };
    return FiberTorusKnot;
}());
/**
 * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
 * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
 * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
 * * The parameter `lines` is an array of lines, each line being an array of successive Vector3
 * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
 * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
 * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
 * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created
 * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
 * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberLineSystem = /** @class */ (function () {
    function FiberLineSystem() {
        this.propsHandlers = [
            new FiberLinesMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberLineSystem.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLineSystem.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLineSystem.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateLineSystem',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'lines',
                        type: 'BabylonjsCoreVector3[][]',
                        optional: false,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreLinesMesh',
                        optional: true,
                    },
                    {
                        name: 'colors',
                        type: 'BabylonjsCoreColor4[][]',
                        optional: true,
                    },
                    {
                        name: 'useVertexAlpha',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'material',
                        type: 'BabylonjsCoreMaterial',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberLineSystem.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberLineSystem',
    };
    return FiberLineSystem;
}());
/**
 * Creates a line mesh
 * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
 * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
 * * The parameter `points` is an array successive Vector3
 * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
 * * The optional parameter `colors` is an array of successive Color4, one per line point
 * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
 * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created
 * * When updating an instance, remember that only point positions can change, not the number of points
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberLines = /** @class */ (function () {
    function FiberLines() {
        this.propsHandlers = [
            new FiberLinesMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberLines.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLines.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLines.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateLines',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'points',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreLinesMesh',
                        optional: true,
                    },
                    {
                        name: 'colors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'useVertexAlpha',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'material',
                        type: 'BabylonjsCoreMaterial',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberLines.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberLines',
    };
    return FiberLines;
}());
/**
 * Creates a dashed line mesh
 * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
 * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
 * * The parameter `points` is an array successive Vector3
 * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
 * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
 * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
 * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines
 * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
 * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created
 * * When updating an instance, remember that only point positions can change, not the number of points
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberDashedLines = /** @class */ (function () {
    function FiberDashedLines() {
        this.propsHandlers = [
            new FiberLinesMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberDashedLines.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDashedLines.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDashedLines.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateDashedLines',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'points',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'dashSize',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'gapSize',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'dashNb',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreLinesMesh',
                        optional: true,
                    },
                    {
                        name: 'useVertexAlpha',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'material',
                        type: 'BabylonjsCoreMaterial',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberDashedLines.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberDashedLines',
    };
    return FiberDashedLines;
}());
/**
 * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
 * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
 * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
 * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
 * * The parameter `scale` (float, default 1) is the value to scale the shape.
 * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.
 * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.
 * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
 * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 *
 * This code has been generated
 */
var FiberExtrudeShape = /** @class */ (function () {
    function FiberExtrudeShape() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberExtrudeShape.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberExtrudeShape.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberExtrudeShape.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'ExtrudeShape',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'shape',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'path',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'scale',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'rotation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'closeShape',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'closePath',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'cap',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreMesh',
                        optional: true,
                    },
                    {
                        name: 'invertUV',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberExtrudeShape.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberExtrudeShape',
    };
    return FiberExtrudeShape;
}());
/**
 * Creates an custom extruded shape mesh.
 * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
 * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
 * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
 * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path
 * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
 * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the beginning of the path
 * * It must returns a float value that will be the scale value applied to the shape on each path point
 * * The parameter `closeShape` (boolean, default false) closes the shape when true, since v5.0.0.
 * * The parameter `closePath` (boolean, default false) closes the path when true and no caps, since v5.0.0.
 * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray` - depreciated in favor of closeShape
 * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray` - depreciated in favor of closePath
 * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape
 * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberExtrudeShapeCustom = /** @class */ (function () {
    function FiberExtrudeShapeCustom() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberExtrudeShapeCustom.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberExtrudeShapeCustom.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberExtrudeShapeCustom.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'ExtrudeShapeCustom',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'shape',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'path',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'scaleFunction',
                        type: '(i: number, distance: number) => number',
                        optional: true,
                    },
                    {
                        name: 'rotationFunction',
                        type: '(i: number, distance: number) => number',
                        optional: true,
                    },
                    {
                        name: 'ribbonCloseArray',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'ribbonClosePath',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'closeShape',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'closePath',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'cap',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreMesh',
                        optional: true,
                    },
                    {
                        name: 'invertUV',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberExtrudeShapeCustom.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberExtrudeShapeCustom',
    };
    return FiberExtrudeShapeCustom;
}());
/**
 * Creates lathe mesh.
 * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe
 * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
 * * The parameter `radius` (positive float, default 1) is the radius value of the lathe
 * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
 * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides
 * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
 * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
 * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberLathe = /** @class */ (function () {
    function FiberLathe() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberLathe.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLathe.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLathe.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateLathe',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'shape',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'radius',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tessellation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'clip',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'arc',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'closed',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'cap',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'invertUV',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberLathe.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberLathe',
    };
    return FiberLathe;
}());
/**
 * Creates a tiled plane mesh
 *
 * This code has been generated
 */
var FiberTiledPlane = /** @class */ (function () {
    function FiberTiledPlane() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTiledPlane.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTiledPlane.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTiledPlane.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateTiledPlane',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'pattern',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tileSize',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tileWidth',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tileHeight',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'size',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'width',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'alignHorizontal',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'alignVertical',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTiledPlane.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberTiledPlane',
    };
    return FiberTiledPlane;
}());
/**
 * Creates a plane mesh
 * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
 * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)
 * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberPlane = /** @class */ (function () {
    function FiberPlane() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberPlane.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPlane.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPlane.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreatePlane',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'size',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'width',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sourcePlane',
                        type: 'BabylonjsCorePlane',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPlane.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberPlane',
    };
    return FiberPlane;
}());
/**
 * Creates a ground mesh
 * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
 * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberGround = /** @class */ (function () {
    function FiberGround() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGround.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGround.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGround.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateGround',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'width',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'subdivisions',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'subdivisionsX',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'subdivisionsY',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGround.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberGround',
    };
    return FiberGround;
}());
/**
 * Creates a tiled ground mesh
 * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
 * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
 * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
 * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 *
 * This code has been generated
 */
var FiberTiledGround = /** @class */ (function () {
    function FiberTiledGround() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTiledGround.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTiledGround.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTiledGround.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateTiledGround',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'xmin',
                        type: 'number',
                        optional: false,
                    },
                    {
                        name: 'zmin',
                        type: 'number',
                        optional: false,
                    },
                    {
                        name: 'xmax',
                        type: 'number',
                        optional: false,
                    },
                    {
                        name: 'zmax',
                        type: 'number',
                        optional: false,
                    },
                    {
                        name: 'subdivisions',
                        type: '{ w: number; h: number; }',
                        optional: true,
                    },
                    {
                        name: 'precision',
                        type: '{ w: number; h: number; }',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTiledGround.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberTiledGround',
    };
    return FiberTiledGround;
}());
/**
 * Creates a ground mesh from a height map
 * * The parameter `url` sets the URL of the height map image resource.
 * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
 * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
 * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
 * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
 * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
 * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
 * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 *
 * This code has been generated
 */
var FiberGroundFromHeightMap = /** @class */ (function () {
    function FiberGroundFromHeightMap() {
        this.propsHandlers = [
            new FiberGroundMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGroundFromHeightMap.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGroundFromHeightMap.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGroundFromHeightMap.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateGroundFromHeightMap',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'url',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'width',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'height',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'subdivisions',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'minHeight',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'maxHeight',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'colorFilter',
                        type: 'BabylonjsCoreColor3',
                        optional: true,
                    },
                    {
                        name: 'alphaFilter',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'onReady',
                        type: '(mesh: BabylonjsCoreGroundMesh) => void',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGroundFromHeightMap.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberGroundFromHeightMap',
    };
    return FiberGroundFromHeightMap;
}());
/**
 * Creates a polygon mesh
 * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
 * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
 * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
 * * Remember you can only change the shape positions, not their number when updating a polygon
 *
 * This code has been generated
 */
var FiberPolygon = /** @class */ (function () {
    function FiberPolygon() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberPolygon.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPolygon.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPolygon.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreatePolygon',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'shape',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'holes',
                        type: 'BabylonjsCoreVector3[][]',
                        optional: true,
                    },
                    {
                        name: 'depth',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'smoothingThreshold',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'wrap',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'earcutInjection',
                type: 'any',
                optional: true,
            },
        ],
    };
    FiberPolygon.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberPolygon',
    };
    return FiberPolygon;
}());
/**
 * Creates an extruded polygon mesh, with depth in the Y direction.
 * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
 *
 * This code has been generated
 */
var FiberExtrudePolygon = /** @class */ (function () {
    function FiberExtrudePolygon() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberExtrudePolygon.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberExtrudePolygon.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberExtrudePolygon.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'ExtrudePolygon',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'shape',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'holes',
                        type: 'BabylonjsCoreVector3[][]',
                        optional: true,
                    },
                    {
                        name: 'depth',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'wrap',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'earcutInjection',
                type: 'any',
                optional: true,
            },
        ],
    };
    FiberExtrudePolygon.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberExtrudePolygon',
    };
    return FiberExtrudePolygon;
}());
/**
 * Creates a tube mesh.
 * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
 * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
 * * The parameter `radius` (positive float, default 1) sets the tube radius size
 * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
 * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`
 * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
 * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
 * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberTube = /** @class */ (function () {
    function FiberTube() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberTube.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTube.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTube.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateTube',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'path',
                        type: 'BabylonjsCoreVector3[]',
                        optional: false,
                    },
                    {
                        name: 'radius',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'tessellation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'radiusFunction',
                        type: '(i: number, distance: number) => number',
                        optional: true,
                    },
                    {
                        name: 'cap',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'arc',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'instance',
                        type: 'BabylonjsCoreMesh',
                        optional: true,
                    },
                    {
                        name: 'invertUV',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberTube.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberTube',
    };
    return FiberTube;
}());
/**
 * Creates a polyhedron mesh
 * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
 * * The parameter `size` (positive float, default 1) sets the polygon size
 * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
 * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overrides the parameter `type`
 * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
 * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
 * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors
 * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
 * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 *
 * This code has been generated
 */
var FiberPolyhedron = /** @class */ (function () {
    function FiberPolyhedron() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberPolyhedron.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPolyhedron.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPolyhedron.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreatePolyhedron',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'type',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'size',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sizeX',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sizeY',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sizeZ',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'custom',
                        type: 'any',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'flat',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                ],
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPolyhedron.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberPolyhedron',
    };
    return FiberPolyhedron;
}());
/**
 * Creates the Mesh for a Geodesic Polyhedron
 *
 * This code has been generated
 */
var FiberGeodesic = /** @class */ (function () {
    function FiberGeodesic() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGeodesic.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGeodesic.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGeodesic.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateGeodesic',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'm',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'n',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'size',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sizeX',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sizeY',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'sizeZ',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'faceUV',
                        type: 'BabylonjsCoreVector4[]',
                        optional: true,
                    },
                    {
                        name: 'faceColors',
                        type: 'BabylonjsCoreColor4[]',
                        optional: true,
                    },
                    {
                        name: 'flat',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'sideOrientation',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'frontUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                    {
                        name: 'backUVs',
                        type: 'BabylonjsCoreVector4',
                        optional: true,
                    },
                ],
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGeodesic.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberGeodesic',
    };
    return FiberGeodesic;
}());
/**
 * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces
 *
 * This code has been generated
 */
var FiberGoldberg = /** @class */ (function () {
    function FiberGoldberg() {
        this.propsHandlers = [
            new FiberGoldbergMeshPropsHandler(),
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberGoldberg.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGoldberg.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGoldberg.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateGoldberg',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreGoldbergCreationOption',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGoldberg.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberGoldberg',
    };
    return FiberGoldberg;
}());
/**
 * Creates a decal mesh.
 * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
 * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
 * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
 * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
 * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
 * * The parameter `captureUVS` defines if we need to capture the uvs or compute them
 *
 * This code has been generated
 */
var FiberDecal = /** @class */ (function () {
    function FiberDecal() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberDecal.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDecal.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDecal.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateDecal',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'sourceMesh',
                type: 'BabylonjsCoreAbstractMesh',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'position',
                        type: 'BabylonjsCoreVector3',
                        optional: true,
                    },
                    {
                        name: 'normal',
                        type: 'BabylonjsCoreVector3',
                        optional: true,
                    },
                    {
                        name: 'size',
                        type: 'BabylonjsCoreVector3',
                        optional: true,
                    },
                    {
                        name: 'angle',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'captureUVS',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: false,
            },
        ],
    };
    FiberDecal.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberDecal',
    };
    return FiberDecal;
}());
/**
 * Creates a capsule or a pill mesh
 *
 * This code has been generated
 */
var FiberCapsule = /** @class */ (function () {
    function FiberCapsule() {
        this.propsHandlers = [
            new FiberMeshPropsHandler(),
            new FiberAbstractMeshPropsHandler(),
            new FiberTransformNodePropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberCapsule.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCapsule.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCapsule.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'meshBuilder',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateCapsule',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreICreateCapsuleOptions',
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberCapsule.Metadata = {
        acceptsMaterials: true,
        isNode: true,
        isMesh: true,
        className: 'FiberCapsule',
    };
    return FiberCapsule;
}());
var FiberMaterialPropsHandler = /** @class */ (function () {
    function FiberMaterialPropsHandler() {
    }
    FiberMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.allowShaderHotSwapping, newProps.allowShaderHotSwapping, 'allowShaderHotSwapping', changedProps);
        checkPrimitiveDiff(oldProps.alpha, newProps.alpha, 'alpha', changedProps);
        checkPrimitiveDiff(oldProps.alphaMode, newProps.alphaMode, 'alphaMode', changedProps);
        // type: 'BabylonjsCoreAnimation[]' property (not coded) BabylonjsCoreMaterial.animations.
        checkPrimitiveDiff(oldProps.backFaceCulling, newProps.backFaceCulling, 'backFaceCulling', changedProps);
        checkPrimitiveDiff(oldProps.checkReadyOnEveryCall, newProps.checkReadyOnEveryCall, 'checkReadyOnEveryCall', changedProps);
        checkPrimitiveDiff(oldProps.checkReadyOnlyOnce, newProps.checkReadyOnlyOnce, 'checkReadyOnlyOnce', changedProps);
        checkPrimitiveDiff(oldProps.cullBackFaces, newProps.cullBackFaces, 'cullBackFaces', changedProps);
        checkLambdaDiff(oldProps.customShaderNameResolve, newProps.customShaderNameResolve, 'customShaderNameResolve', changedProps);
        checkPrimitiveDiff(oldProps.depthFunction, newProps.depthFunction, 'depthFunction', changedProps);
        checkPrimitiveDiff(oldProps.disableColorWrite, newProps.disableColorWrite, 'disableColorWrite', changedProps);
        checkPrimitiveDiff(oldProps.disableDepthWrite, newProps.disableDepthWrite, 'disableDepthWrite', changedProps);
        checkPrimitiveDiff(oldProps.doNotSerialize, newProps.doNotSerialize, 'doNotSerialize', changedProps);
        checkPrimitiveDiff(oldProps.fillMode, newProps.fillMode, 'fillMode', changedProps);
        checkPrimitiveDiff(oldProps.fogEnabled, newProps.fogEnabled, 'fogEnabled', changedProps);
        checkPrimitiveDiff(oldProps.forceDepthWrite, newProps.forceDepthWrite, 'forceDepthWrite', changedProps);
        checkLambdaDiff(oldProps.getRenderTargetTextures, newProps.getRenderTargetTextures, 'getRenderTargetTextures', changedProps);
        checkPrimitiveDiff(oldProps.id, newProps.id, 'id', changedProps);
        // type: 'BabylonjsCoreIInspectable[]' property (not coded) BabylonjsCoreMaterial.inspectableCustomProperties.
        // type: '{ [id: string]: BabylonjsCoreAbstractMesh; }' property (not coded) BabylonjsCoreMaterial.meshMap.
        // type: 'any' property (not coded) BabylonjsCoreMaterial.metadata.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.needDepthPrePass, newProps.needDepthPrePass, 'needDepthPrePass', changedProps);
        checkLambdaDiff(oldProps.onBind, newProps.onBind, 'onBind', changedProps);
        checkLambdaDiff(oldProps.onCompiled, newProps.onCompiled, 'onCompiled', changedProps);
        checkLambdaDiff(oldProps.onDispose, newProps.onDispose, 'onDispose', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        checkLambdaDiff(oldProps.onError, newProps.onError, 'onError', changedProps);
        checkPrimitiveDiff(oldProps.pointsCloud, newProps.pointsCloud, 'pointsCloud', changedProps);
        checkPrimitiveDiff(oldProps.pointSize, newProps.pointSize, 'pointSize', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreMaterial.releaseVertexArrayObject.
        // type: 'any' property (not coded) BabylonjsCoreMaterial.reservedDataStore.
        checkPrimitiveDiff(oldProps.separateCullingPass, newProps.separateCullingPass, 'separateCullingPass', changedProps);
        // type: 'BabylonjsCoreShadowDepthWrapper' property (not coded) BabylonjsCoreMaterial.shadowDepthWrapper.
        checkPrimitiveDiff(oldProps.sideOrientation, newProps.sideOrientation, 'sideOrientation', changedProps);
        checkPrimitiveDiff(oldProps.state, newProps.state, 'state', changedProps);
        checkPrimitiveDiff(oldProps.transparencyMode, newProps.transparencyMode, 'transparencyMode', changedProps);
        checkPrimitiveDiff(oldProps.uniqueId, newProps.uniqueId, 'uniqueId', changedProps);
        checkPrimitiveDiff(oldProps.wireframe, newProps.wireframe, 'wireframe', changedProps);
        checkPrimitiveDiff(oldProps.zOffset, newProps.zOffset, 'zOffset', changedProps);
        checkPrimitiveDiff(oldProps.zOffsetUnits, newProps.zOffsetUnits, 'zOffsetUnits', changedProps);
        checkMethodDiff(oldProps.setPrePassRenderer, newProps.setPrePassRenderer, 'setPrePassRenderer', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMaterialPropsHandler;
}());
/**
 * Base class for the main features of a material in Babylon.js
 *
 * This code has been generated
 */
var FiberMaterial = /** @class */ (function () {
    function FiberMaterial() {
        this.propsHandlers = [new FiberMaterialPropsHandler()];
    }
    FiberMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Material',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'doNotAdd',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberMaterial',
    };
    return FiberMaterial;
}());
var FiberPushMaterialPropsHandler = /** @class */ (function () {
    function FiberPushMaterialPropsHandler() {
    }
    FiberPushMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberPushMaterialPropsHandler;
}());
/**
 * Base class of materials working in push mode in babylon JS
 *
 * This code has been generated
 */
var FiberPushMaterial = /** @class */ (function () {
    function FiberPushMaterial() {
        this.propsHandlers = [new FiberPushMaterialPropsHandler(), new FiberMaterialPropsHandler()];
    }
    FiberPushMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPushMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPushMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PushMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'storeEffectOnSubMeshes',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPushMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberPushMaterial',
    };
    return FiberPushMaterial;
}());
var FiberNodeMaterialPropsHandler = /** @class */ (function () {
    function FiberNodeMaterialPropsHandler() {
    }
    FiberNodeMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreNodeMaterialBlock[]' property (not coded) BabylonjsCoreNodeMaterial.attachedBlocks.
        // type: 'any' property (not coded) BabylonjsCoreNodeMaterial.BJSNODEMATERIALEDITOR.
        checkPrimitiveDiff(oldProps.buildId, newProps.buildId, 'buildId', changedProps);
        checkPrimitiveDiff(oldProps.comment, newProps.comment, 'comment', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreNodeMaterial.editorData.
        checkPrimitiveDiff(oldProps.forceAlphaBlending, newProps.forceAlphaBlending, 'forceAlphaBlending', changedProps);
        checkPrimitiveDiff(oldProps.ignoreAlpha, newProps.ignoreAlpha, 'ignoreAlpha', changedProps);
        // type: 'BabylonjsCoreImageProcessingConfiguration' property (not coded) BabylonjsCoreNodeMaterial.imageProcessingConfiguration.
        checkPrimitiveDiff(oldProps.maxSimultaneousLights, newProps.maxSimultaneousLights, 'maxSimultaneousLights', changedProps);
        checkPrimitiveDiff(oldProps.mode, newProps.mode, 'mode', changedProps);
        checkObservableDiff(oldProps.onBuildObservable, newProps.onBuildObservable, 'onBuildObservable', changedProps);
        // type: 'BabylonjsCoreINodeMaterialOptions' property (not coded) BabylonjsCoreNodeMaterial.options.
        checkPrimitiveDiff(oldProps.snippetId, newProps.snippetId, 'snippetId', changedProps);
        checkMethodDiff(oldProps.addOutputNode, newProps.addOutputNode, 'addOutputNode', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberNodeMaterialPropsHandler;
}());
/**
 * Class used to create a node based material built by assembling shader blocks
 *
 * This code has been generated
 */
var FiberNodeMaterial = /** @class */ (function () {
    function FiberNodeMaterial() {
        this.propsHandlers = [
            new FiberNodeMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberNodeMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberNodeMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberNodeMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'NodeMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'options',
                type: 'Partial<BabylonjsCoreINodeMaterialOptions>',
                optional: true,
            },
        ],
    };
    FiberNodeMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberNodeMaterial',
    };
    return FiberNodeMaterial;
}());
var FiberShaderMaterialPropsHandler = /** @class */ (function () {
    function FiberShaderMaterialPropsHandler() {
    }
    FiberShaderMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'any' property (not coded) BabylonjsCoreShaderMaterial.shaderPath.
        checkPrimitiveDiff(oldProps.snippetId, newProps.snippetId, 'snippetId', changedProps);
        checkMethodDiff(oldProps.setArray2, newProps.setArray2, 'setArray2', changedProps);
        checkMethodDiff(oldProps.setArray3, newProps.setArray3, 'setArray3', changedProps);
        checkMethodDiff(oldProps.setArray4, newProps.setArray4, 'setArray4', changedProps);
        checkMethodDiff(oldProps.setColor3, newProps.setColor3, 'setColor3', changedProps);
        checkMethodDiff(oldProps.setColor3Array, newProps.setColor3Array, 'setColor3Array', changedProps);
        checkMethodDiff(oldProps.setColor4, newProps.setColor4, 'setColor4', changedProps);
        checkMethodDiff(oldProps.setColor4Array, newProps.setColor4Array, 'setColor4Array', changedProps);
        checkMethodDiff(oldProps.setExternalTexture, newProps.setExternalTexture, 'setExternalTexture', changedProps);
        checkMethodDiff(oldProps.setFloat, newProps.setFloat, 'setFloat', changedProps);
        checkMethodDiff(oldProps.setFloats, newProps.setFloats, 'setFloats', changedProps);
        checkMethodDiff(oldProps.setInt, newProps.setInt, 'setInt', changedProps);
        checkMethodDiff(oldProps.setMatrices, newProps.setMatrices, 'setMatrices', changedProps);
        checkMethodDiff(oldProps.setMatrix, newProps.setMatrix, 'setMatrix', changedProps);
        checkMethodDiff(oldProps.setMatrix2x2, newProps.setMatrix2x2, 'setMatrix2x2', changedProps);
        checkMethodDiff(oldProps.setMatrix3x3, newProps.setMatrix3x3, 'setMatrix3x3', changedProps);
        checkMethodDiff(oldProps.setStorageBuffer, newProps.setStorageBuffer, 'setStorageBuffer', changedProps);
        checkMethodDiff(oldProps.setTexture, newProps.setTexture, 'setTexture', changedProps);
        checkMethodDiff(oldProps.setTextureArray, newProps.setTextureArray, 'setTextureArray', changedProps);
        checkMethodDiff(oldProps.setTextureSampler, newProps.setTextureSampler, 'setTextureSampler', changedProps);
        checkMethodDiff(oldProps.setUniformBuffer, newProps.setUniformBuffer, 'setUniformBuffer', changedProps);
        checkMethodDiff(oldProps.setVector2, newProps.setVector2, 'setVector2', changedProps);
        checkMethodDiff(oldProps.setVector3, newProps.setVector3, 'setVector3', changedProps);
        checkMethodDiff(oldProps.setVector4, newProps.setVector4, 'setVector4', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberShaderMaterialPropsHandler;
}());
/**
 * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
 *
 * This returned material effects how the mesh will look based on the code in the shaders.
 *
 * This code has been generated
 */
var FiberShaderMaterial = /** @class */ (function () {
    function FiberShaderMaterial() {
        this.propsHandlers = [
            new FiberShaderMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberShaderMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberShaderMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberShaderMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ShaderMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'shaderPath',
                type: 'any',
                optional: false,
            },
            {
                name: 'options',
                type: 'Partial<BabylonjsCoreIShaderMaterialOptions>',
                optional: true,
            },
            {
                name: 'storeEffectOnSubMeshes',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberShaderMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberShaderMaterial',
    };
    return FiberShaderMaterial;
}());
var FiberOcclusionMaterialPropsHandler = /** @class */ (function () {
    function FiberOcclusionMaterialPropsHandler() {
    }
    FiberOcclusionMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberOcclusionMaterialPropsHandler;
}());
/**
 * A material to use for fast depth-only rendering.
 *
 * This code has been generated
 */
var FiberOcclusionMaterial = /** @class */ (function () {
    function FiberOcclusionMaterial() {
        this.propsHandlers = [
            new FiberOcclusionMaterialPropsHandler(),
            new FiberShaderMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberOcclusionMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberOcclusionMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberOcclusionMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'OcclusionMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberOcclusionMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberOcclusionMaterial',
    };
    return FiberOcclusionMaterial;
}());
var FiberHandleMaterialPropsHandler = /** @class */ (function () {
    function FiberHandleMaterialPropsHandler() {
    }
    FiberHandleMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.animationLength, newProps.animationLength, 'animationLength', changedProps);
        checkColor3Diff(oldProps.baseColor, newProps.baseColor, 'baseColor', changedProps);
        checkPrimitiveDiff(oldProps.baseScale, newProps.baseScale, 'baseScale', changedProps);
        checkPrimitiveDiff(oldProps.drag, newProps.drag, 'drag', changedProps);
        checkPrimitiveDiff(oldProps.dragScale, newProps.dragScale, 'dragScale', changedProps);
        checkPrimitiveDiff(oldProps.hover, newProps.hover, 'hover', changedProps);
        checkColor3Diff(oldProps.hoverColor, newProps.hoverColor, 'hoverColor', changedProps);
        checkPrimitiveDiff(oldProps.hoverScale, newProps.hoverScale, 'hoverScale', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHandleMaterialPropsHandler;
}());
/**
 * Class used to render gizmo handles with fluent design
 *
 * This code has been generated
 */
var FiberHandleMaterial = /** @class */ (function () {
    function FiberHandleMaterial() {
        this.propsHandlers = [
            new FiberHandleMaterialPropsHandler(),
            new FiberShaderMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberHandleMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHandleMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHandleMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HandleMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberHandleMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberHandleMaterial',
    };
    return FiberHandleMaterial;
}());
var FiberPBRBaseMaterialPropsHandler = /** @class */ (function () {
    function FiberPBRBaseMaterialPropsHandler() {
    }
    FiberPBRBaseMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.debugMode, newProps.debugMode, 'debugMode', changedProps);
        checkPrimitiveDiff(oldProps.realTimeFiltering, newProps.realTimeFiltering, 'realTimeFiltering', changedProps);
        checkPrimitiveDiff(oldProps.realTimeFilteringQuality, newProps.realTimeFilteringQuality, 'realTimeFilteringQuality', changedProps);
        checkPrimitiveDiff(oldProps.useLogarithmicDepth, newProps.useLogarithmicDepth, 'useLogarithmicDepth', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRBaseMaterialPropsHandler;
}());
/**
 * The Physically based material base class of BJS.
 *
 * This offers the main features of a standard PBR material.
 * For more information, please refer to the documentation :
 * https://doc.babylonjs.com/how_to/physically_based_rendering
 *
 * This code has been generated
 */
var FiberPBRBaseMaterial = /** @class */ (function () {
    function FiberPBRBaseMaterial() {
        this.propsHandlers = [
            new FiberPBRBaseMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberPBRBaseMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRBaseMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRBaseMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRBaseMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPBRBaseMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberPBRBaseMaterial',
    };
    return FiberPBRBaseMaterial;
}());
var FiberPBRBaseSimpleMaterialPropsHandler = /** @class */ (function () {
    function FiberPBRBaseSimpleMaterialPropsHandler() {
    }
    FiberPBRBaseSimpleMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.alphaCutOff, newProps.alphaCutOff, 'alphaCutOff', changedProps);
        checkPrimitiveDiff(oldProps.disableLighting, newProps.disableLighting, 'disableLighting', changedProps);
        checkPrimitiveDiff(oldProps.doubleSided, newProps.doubleSided, 'doubleSided', changedProps);
        checkColor3Diff(oldProps.emissiveColor, newProps.emissiveColor, 'emissiveColor', changedProps);
        checkTextureDiff(oldProps.emissiveTexture, newProps.emissiveTexture, 'emissiveTexture', changedProps);
        checkTextureDiff(oldProps.environmentTexture, newProps.environmentTexture, 'environmentTexture', changedProps);
        checkPrimitiveDiff(oldProps.invertNormalMapX, newProps.invertNormalMapX, 'invertNormalMapX', changedProps);
        checkPrimitiveDiff(oldProps.invertNormalMapY, newProps.invertNormalMapY, 'invertNormalMapY', changedProps);
        checkTextureDiff(oldProps.lightmapTexture, newProps.lightmapTexture, 'lightmapTexture', changedProps);
        checkPrimitiveDiff(oldProps.maxSimultaneousLights, newProps.maxSimultaneousLights, 'maxSimultaneousLights', changedProps);
        checkTextureDiff(oldProps.normalTexture, newProps.normalTexture, 'normalTexture', changedProps);
        checkPrimitiveDiff(oldProps.occlusionStrength, newProps.occlusionStrength, 'occlusionStrength', changedProps);
        checkTextureDiff(oldProps.occlusionTexture, newProps.occlusionTexture, 'occlusionTexture', changedProps);
        checkPrimitiveDiff(oldProps.useLightmapAsShadowmap, newProps.useLightmapAsShadowmap, 'useLightmapAsShadowmap', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRBaseSimpleMaterialPropsHandler;
}());
/**
 * The Physically based simple base material of BJS.
 *
 * This enables better naming and convention enforcements on top of the pbrMaterial.
 * It is used as the base class for both the specGloss and metalRough conventions.
 *
 * This code has been generated
 */
var FiberPBRBaseSimpleMaterial = /** @class */ (function () {
    function FiberPBRBaseSimpleMaterial() {
        this.propsHandlers = [
            new FiberPBRBaseSimpleMaterialPropsHandler(),
            new FiberPBRBaseMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberPBRBaseSimpleMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRBaseSimpleMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRBaseSimpleMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRBaseSimpleMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPBRBaseSimpleMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberPBRBaseSimpleMaterial',
    };
    return FiberPBRBaseSimpleMaterial;
}());
var FiberPBRMetallicRoughnessMaterialPropsHandler = /** @class */ (function () {
    function FiberPBRMetallicRoughnessMaterialPropsHandler() {
    }
    FiberPBRMetallicRoughnessMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.baseColor, newProps.baseColor, 'baseColor', changedProps);
        checkTextureDiff(oldProps.baseTexture, newProps.baseTexture, 'baseTexture', changedProps);
        checkPrimitiveDiff(oldProps.metallic, newProps.metallic, 'metallic', changedProps);
        checkTextureDiff(oldProps.metallicRoughnessTexture, newProps.metallicRoughnessTexture, 'metallicRoughnessTexture', changedProps);
        checkPrimitiveDiff(oldProps.roughness, newProps.roughness, 'roughness', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRMetallicRoughnessMaterialPropsHandler;
}());
/**
 * The PBR material of BJS following the metal roughness convention.
 *
 * This fits to the PBR convention in the GLTF definition:
 * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 *
 * This code has been generated
 */
var FiberPBRMetallicRoughnessMaterial = /** @class */ (function () {
    function FiberPBRMetallicRoughnessMaterial() {
        this.propsHandlers = [
            new FiberPBRMetallicRoughnessMaterialPropsHandler(),
            new FiberPBRBaseSimpleMaterialPropsHandler(),
            new FiberPBRBaseMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberPBRMetallicRoughnessMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRMetallicRoughnessMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRMetallicRoughnessMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRMetallicRoughnessMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPBRMetallicRoughnessMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberPBRMetallicRoughnessMaterial',
    };
    return FiberPBRMetallicRoughnessMaterial;
}());
var FiberPBRSpecularGlossinessMaterialPropsHandler = /** @class */ (function () {
    function FiberPBRSpecularGlossinessMaterialPropsHandler() {
    }
    FiberPBRSpecularGlossinessMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.diffuseColor, newProps.diffuseColor, 'diffuseColor', changedProps);
        checkTextureDiff(oldProps.diffuseTexture, newProps.diffuseTexture, 'diffuseTexture', changedProps);
        checkPrimitiveDiff(oldProps.glossiness, newProps.glossiness, 'glossiness', changedProps);
        checkColor3Diff(oldProps.specularColor, newProps.specularColor, 'specularColor', changedProps);
        checkTextureDiff(oldProps.specularGlossinessTexture, newProps.specularGlossinessTexture, 'specularGlossinessTexture', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRSpecularGlossinessMaterialPropsHandler;
}());
/**
 * The PBR material of BJS following the specular glossiness convention.
 *
 * This fits to the PBR convention in the GLTF definition:
 * https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
 *
 * This code has been generated
 */
var FiberPBRSpecularGlossinessMaterial = /** @class */ (function () {
    function FiberPBRSpecularGlossinessMaterial() {
        this.propsHandlers = [
            new FiberPBRSpecularGlossinessMaterialPropsHandler(),
            new FiberPBRBaseSimpleMaterialPropsHandler(),
            new FiberPBRBaseMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberPBRSpecularGlossinessMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRSpecularGlossinessMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRSpecularGlossinessMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRSpecularGlossinessMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPBRSpecularGlossinessMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberPBRSpecularGlossinessMaterial',
    };
    return FiberPBRSpecularGlossinessMaterial;
}());
var FiberPBRMaterialPropsHandler = /** @class */ (function () {
    function FiberPBRMaterialPropsHandler() {
    }
    FiberPBRMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.albedoColor, newProps.albedoColor, 'albedoColor', changedProps);
        checkTextureDiff(oldProps.albedoTexture, newProps.albedoTexture, 'albedoTexture', changedProps);
        checkPrimitiveDiff(oldProps.alphaCutOff, newProps.alphaCutOff, 'alphaCutOff', changedProps);
        checkColor3Diff(oldProps.ambientColor, newProps.ambientColor, 'ambientColor', changedProps);
        checkTextureDiff(oldProps.ambientTexture, newProps.ambientTexture, 'ambientTexture', changedProps);
        checkPrimitiveDiff(oldProps.ambientTextureImpactOnAnalyticalLights, newProps.ambientTextureImpactOnAnalyticalLights, 'ambientTextureImpactOnAnalyticalLights', changedProps);
        checkPrimitiveDiff(oldProps.ambientTextureStrength, newProps.ambientTextureStrength, 'ambientTextureStrength', changedProps);
        checkTextureDiff(oldProps.bumpTexture, newProps.bumpTexture, 'bumpTexture', changedProps);
        // type: 'BabylonjsCoreColorCurves' property (not coded) BabylonjsCorePBRMaterial.cameraColorCurves.
        checkPrimitiveDiff(oldProps.cameraColorCurvesEnabled, newProps.cameraColorCurvesEnabled, 'cameraColorCurvesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.cameraColorGradingEnabled, newProps.cameraColorGradingEnabled, 'cameraColorGradingEnabled', changedProps);
        checkTextureDiff(oldProps.cameraColorGradingTexture, newProps.cameraColorGradingTexture, 'cameraColorGradingTexture', changedProps);
        checkPrimitiveDiff(oldProps.cameraContrast, newProps.cameraContrast, 'cameraContrast', changedProps);
        checkPrimitiveDiff(oldProps.cameraExposure, newProps.cameraExposure, 'cameraExposure', changedProps);
        checkPrimitiveDiff(oldProps.cameraToneMappingEnabled, newProps.cameraToneMappingEnabled, 'cameraToneMappingEnabled', changedProps);
        checkPrimitiveDiff(oldProps.directIntensity, newProps.directIntensity, 'directIntensity', changedProps);
        checkPrimitiveDiff(oldProps.disableBumpMap, newProps.disableBumpMap, 'disableBumpMap', changedProps);
        checkPrimitiveDiff(oldProps.disableLighting, newProps.disableLighting, 'disableLighting', changedProps);
        checkColor3Diff(oldProps.emissiveColor, newProps.emissiveColor, 'emissiveColor', changedProps);
        checkPrimitiveDiff(oldProps.emissiveIntensity, newProps.emissiveIntensity, 'emissiveIntensity', changedProps);
        checkTextureDiff(oldProps.emissiveTexture, newProps.emissiveTexture, 'emissiveTexture', changedProps);
        checkPrimitiveDiff(oldProps.enableSpecularAntiAliasing, newProps.enableSpecularAntiAliasing, 'enableSpecularAntiAliasing', changedProps);
        checkTextureDiff(oldProps.environmentBRDFTexture, newProps.environmentBRDFTexture, 'environmentBRDFTexture', changedProps);
        checkPrimitiveDiff(oldProps.environmentIntensity, newProps.environmentIntensity, 'environmentIntensity', changedProps);
        checkPrimitiveDiff(oldProps.forceAlphaTest, newProps.forceAlphaTest, 'forceAlphaTest', changedProps);
        checkPrimitiveDiff(oldProps.forceIrradianceInFragment, newProps.forceIrradianceInFragment, 'forceIrradianceInFragment', changedProps);
        checkPrimitiveDiff(oldProps.forceNormalForward, newProps.forceNormalForward, 'forceNormalForward', changedProps);
        // type: 'BabylonjsCoreImageProcessingConfiguration' property (not coded) BabylonjsCorePBRMaterial.imageProcessingConfiguration.
        checkPrimitiveDiff(oldProps.indexOfRefraction, newProps.indexOfRefraction, 'indexOfRefraction', changedProps);
        checkPrimitiveDiff(oldProps.invertNormalMapX, newProps.invertNormalMapX, 'invertNormalMapX', changedProps);
        checkPrimitiveDiff(oldProps.invertNormalMapY, newProps.invertNormalMapY, 'invertNormalMapY', changedProps);
        checkPrimitiveDiff(oldProps.invertRefractionY, newProps.invertRefractionY, 'invertRefractionY', changedProps);
        checkTextureDiff(oldProps.lightmapTexture, newProps.lightmapTexture, 'lightmapTexture', changedProps);
        checkPrimitiveDiff(oldProps.linkRefractionWithTransparency, newProps.linkRefractionWithTransparency, 'linkRefractionWithTransparency', changedProps);
        checkPrimitiveDiff(oldProps.maxSimultaneousLights, newProps.maxSimultaneousLights, 'maxSimultaneousLights', changedProps);
        checkPrimitiveDiff(oldProps.metallic, newProps.metallic, 'metallic', changedProps);
        checkPrimitiveDiff(oldProps.metallicF0Factor, newProps.metallicF0Factor, 'metallicF0Factor', changedProps);
        checkColor3Diff(oldProps.metallicReflectanceColor, newProps.metallicReflectanceColor, 'metallicReflectanceColor', changedProps);
        checkTextureDiff(oldProps.metallicReflectanceTexture, newProps.metallicReflectanceTexture, 'metallicReflectanceTexture', changedProps);
        checkTextureDiff(oldProps.metallicTexture, newProps.metallicTexture, 'metallicTexture', changedProps);
        checkPrimitiveDiff(oldProps.microSurface, newProps.microSurface, 'microSurface', changedProps);
        checkTextureDiff(oldProps.microSurfaceTexture, newProps.microSurfaceTexture, 'microSurfaceTexture', changedProps);
        checkTextureDiff(oldProps.opacityTexture, newProps.opacityTexture, 'opacityTexture', changedProps);
        checkPrimitiveDiff(oldProps.parallaxScaleBias, newProps.parallaxScaleBias, 'parallaxScaleBias', changedProps);
        checkTextureDiff(oldProps.reflectanceTexture, newProps.reflectanceTexture, 'reflectanceTexture', changedProps);
        checkColor3Diff(oldProps.reflectionColor, newProps.reflectionColor, 'reflectionColor', changedProps);
        checkTextureDiff(oldProps.reflectionTexture, newProps.reflectionTexture, 'reflectionTexture', changedProps);
        checkColor3Diff(oldProps.reflectivityColor, newProps.reflectivityColor, 'reflectivityColor', changedProps);
        checkTextureDiff(oldProps.reflectivityTexture, newProps.reflectivityTexture, 'reflectivityTexture', changedProps);
        checkTextureDiff(oldProps.refractionTexture, newProps.refractionTexture, 'refractionTexture', changedProps);
        checkPrimitiveDiff(oldProps.roughness, newProps.roughness, 'roughness', changedProps);
        checkPrimitiveDiff(oldProps.specularIntensity, newProps.specularIntensity, 'specularIntensity', changedProps);
        checkPrimitiveDiff(oldProps.twoSidedLighting, newProps.twoSidedLighting, 'twoSidedLighting', changedProps);
        checkPrimitiveDiff(oldProps.unlit, newProps.unlit, 'unlit', changedProps);
        checkPrimitiveDiff(oldProps.useAlphaFresnel, newProps.useAlphaFresnel, 'useAlphaFresnel', changedProps);
        checkPrimitiveDiff(oldProps.useAlphaFromAlbedoTexture, newProps.useAlphaFromAlbedoTexture, 'useAlphaFromAlbedoTexture', changedProps);
        checkPrimitiveDiff(oldProps.useAmbientInGrayScale, newProps.useAmbientInGrayScale, 'useAmbientInGrayScale', changedProps);
        checkPrimitiveDiff(oldProps.useAmbientOcclusionFromMetallicTextureRed, newProps.useAmbientOcclusionFromMetallicTextureRed, 'useAmbientOcclusionFromMetallicTextureRed', changedProps);
        checkPrimitiveDiff(oldProps.useAutoMicroSurfaceFromReflectivityMap, newProps.useAutoMicroSurfaceFromReflectivityMap, 'useAutoMicroSurfaceFromReflectivityMap', changedProps);
        checkPrimitiveDiff(oldProps.useGLTFLightFalloff, newProps.useGLTFLightFalloff, 'useGLTFLightFalloff', changedProps);
        checkPrimitiveDiff(oldProps.useHorizonOcclusion, newProps.useHorizonOcclusion, 'useHorizonOcclusion', changedProps);
        checkPrimitiveDiff(oldProps.useLightmapAsShadowmap, newProps.useLightmapAsShadowmap, 'useLightmapAsShadowmap', changedProps);
        checkPrimitiveDiff(oldProps.useLinearAlphaFresnel, newProps.useLinearAlphaFresnel, 'useLinearAlphaFresnel', changedProps);
        checkPrimitiveDiff(oldProps.useMetallnessFromMetallicTextureBlue, newProps.useMetallnessFromMetallicTextureBlue, 'useMetallnessFromMetallicTextureBlue', changedProps);
        checkPrimitiveDiff(oldProps.useMicroSurfaceFromReflectivityMapAlpha, newProps.useMicroSurfaceFromReflectivityMapAlpha, 'useMicroSurfaceFromReflectivityMapAlpha', changedProps);
        checkPrimitiveDiff(oldProps.useObjectSpaceNormalMap, newProps.useObjectSpaceNormalMap, 'useObjectSpaceNormalMap', changedProps);
        checkPrimitiveDiff(oldProps.useOnlyMetallicFromMetallicReflectanceTexture, newProps.useOnlyMetallicFromMetallicReflectanceTexture, 'useOnlyMetallicFromMetallicReflectanceTexture', changedProps);
        checkPrimitiveDiff(oldProps.useParallax, newProps.useParallax, 'useParallax', changedProps);
        checkPrimitiveDiff(oldProps.useParallaxOcclusion, newProps.useParallaxOcclusion, 'useParallaxOcclusion', changedProps);
        checkPrimitiveDiff(oldProps.usePhysicalLightFalloff, newProps.usePhysicalLightFalloff, 'usePhysicalLightFalloff', changedProps);
        checkPrimitiveDiff(oldProps.useRadianceOcclusion, newProps.useRadianceOcclusion, 'useRadianceOcclusion', changedProps);
        checkPrimitiveDiff(oldProps.useRadianceOverAlpha, newProps.useRadianceOverAlpha, 'useRadianceOverAlpha', changedProps);
        checkPrimitiveDiff(oldProps.useRoughnessFromMetallicTextureAlpha, newProps.useRoughnessFromMetallicTextureAlpha, 'useRoughnessFromMetallicTextureAlpha', changedProps);
        checkPrimitiveDiff(oldProps.useRoughnessFromMetallicTextureGreen, newProps.useRoughnessFromMetallicTextureGreen, 'useRoughnessFromMetallicTextureGreen', changedProps);
        checkPrimitiveDiff(oldProps.useSpecularOverAlpha, newProps.useSpecularOverAlpha, 'useSpecularOverAlpha', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRMaterialPropsHandler;
}());
/**
 * The Physically based material of BJS.
 *
 * This offers the main features of a standard PBR material.
 * For more information, please refer to the documentation :
 * https://doc.babylonjs.com/how_to/physically_based_rendering
 *
 * This code has been generated
 */
var FiberPBRMaterial = /** @class */ (function () {
    function FiberPBRMaterial() {
        this.propsHandlers = [
            new FiberPBRMaterialPropsHandler(),
            new FiberPBRBaseMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberPBRMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPBRMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberPBRMaterial',
    };
    return FiberPBRMaterial;
}());
var FiberStandardMaterialPropsHandler = /** @class */ (function () {
    function FiberStandardMaterialPropsHandler() {
    }
    FiberStandardMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.alphaCutOff, newProps.alphaCutOff, 'alphaCutOff', changedProps);
        checkColor3Diff(oldProps.ambientColor, newProps.ambientColor, 'ambientColor', changedProps);
        checkTextureDiff(oldProps.ambientTexture, newProps.ambientTexture, 'ambientTexture', changedProps);
        checkPrimitiveDiff(oldProps.AmbientTextureEnabled, newProps.AmbientTextureEnabled, 'AmbientTextureEnabled', changedProps);
        checkTextureDiff(oldProps.bumpTexture, newProps.bumpTexture, 'bumpTexture', changedProps);
        checkPrimitiveDiff(oldProps.BumpTextureEnabled, newProps.BumpTextureEnabled, 'BumpTextureEnabled', changedProps);
        // type: 'BabylonjsCoreColorCurves' property (not coded) BabylonjsCoreStandardMaterial.cameraColorCurves.
        checkPrimitiveDiff(oldProps.cameraColorCurvesEnabled, newProps.cameraColorCurvesEnabled, 'cameraColorCurvesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.cameraColorGradingEnabled, newProps.cameraColorGradingEnabled, 'cameraColorGradingEnabled', changedProps);
        checkTextureDiff(oldProps.cameraColorGradingTexture, newProps.cameraColorGradingTexture, 'cameraColorGradingTexture', changedProps);
        checkPrimitiveDiff(oldProps.cameraContrast, newProps.cameraContrast, 'cameraContrast', changedProps);
        checkPrimitiveDiff(oldProps.cameraExposure, newProps.cameraExposure, 'cameraExposure', changedProps);
        checkPrimitiveDiff(oldProps.cameraToneMappingEnabled, newProps.cameraToneMappingEnabled, 'cameraToneMappingEnabled', changedProps);
        checkPrimitiveDiff(oldProps.ColorGradingTextureEnabled, newProps.ColorGradingTextureEnabled, 'ColorGradingTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.DetailTextureEnabled, newProps.DetailTextureEnabled, 'DetailTextureEnabled', changedProps);
        checkColor3Diff(oldProps.diffuseColor, newProps.diffuseColor, 'diffuseColor', changedProps);
        checkFresnelParametersDiff(oldProps.diffuseFresnelParameters, newProps.diffuseFresnelParameters, 'diffuseFresnelParameters', changedProps);
        checkTextureDiff(oldProps.diffuseTexture, newProps.diffuseTexture, 'diffuseTexture', changedProps);
        checkPrimitiveDiff(oldProps.DiffuseTextureEnabled, newProps.DiffuseTextureEnabled, 'DiffuseTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.disableLighting, newProps.disableLighting, 'disableLighting', changedProps);
        checkColor3Diff(oldProps.emissiveColor, newProps.emissiveColor, 'emissiveColor', changedProps);
        checkFresnelParametersDiff(oldProps.emissiveFresnelParameters, newProps.emissiveFresnelParameters, 'emissiveFresnelParameters', changedProps);
        checkTextureDiff(oldProps.emissiveTexture, newProps.emissiveTexture, 'emissiveTexture', changedProps);
        checkPrimitiveDiff(oldProps.EmissiveTextureEnabled, newProps.EmissiveTextureEnabled, 'EmissiveTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.FresnelEnabled, newProps.FresnelEnabled, 'FresnelEnabled', changedProps);
        // type: 'BabylonjsCoreImageProcessingConfiguration' property (not coded) BabylonjsCoreStandardMaterial.imageProcessingConfiguration.
        checkPrimitiveDiff(oldProps.indexOfRefraction, newProps.indexOfRefraction, 'indexOfRefraction', changedProps);
        checkPrimitiveDiff(oldProps.invertNormalMapX, newProps.invertNormalMapX, 'invertNormalMapX', changedProps);
        checkPrimitiveDiff(oldProps.invertNormalMapY, newProps.invertNormalMapY, 'invertNormalMapY', changedProps);
        checkPrimitiveDiff(oldProps.invertRefractionY, newProps.invertRefractionY, 'invertRefractionY', changedProps);
        checkTextureDiff(oldProps.lightmapTexture, newProps.lightmapTexture, 'lightmapTexture', changedProps);
        checkPrimitiveDiff(oldProps.LightmapTextureEnabled, newProps.LightmapTextureEnabled, 'LightmapTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.linkEmissiveWithDiffuse, newProps.linkEmissiveWithDiffuse, 'linkEmissiveWithDiffuse', changedProps);
        checkPrimitiveDiff(oldProps.maxSimultaneousLights, newProps.maxSimultaneousLights, 'maxSimultaneousLights', changedProps);
        checkFresnelParametersDiff(oldProps.opacityFresnelParameters, newProps.opacityFresnelParameters, 'opacityFresnelParameters', changedProps);
        checkTextureDiff(oldProps.opacityTexture, newProps.opacityTexture, 'opacityTexture', changedProps);
        checkPrimitiveDiff(oldProps.OpacityTextureEnabled, newProps.OpacityTextureEnabled, 'OpacityTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.parallaxScaleBias, newProps.parallaxScaleBias, 'parallaxScaleBias', changedProps);
        checkFresnelParametersDiff(oldProps.reflectionFresnelParameters, newProps.reflectionFresnelParameters, 'reflectionFresnelParameters', changedProps);
        checkTextureDiff(oldProps.reflectionTexture, newProps.reflectionTexture, 'reflectionTexture', changedProps);
        checkPrimitiveDiff(oldProps.ReflectionTextureEnabled, newProps.ReflectionTextureEnabled, 'ReflectionTextureEnabled', changedProps);
        checkFresnelParametersDiff(oldProps.refractionFresnelParameters, newProps.refractionFresnelParameters, 'refractionFresnelParameters', changedProps);
        checkTextureDiff(oldProps.refractionTexture, newProps.refractionTexture, 'refractionTexture', changedProps);
        checkPrimitiveDiff(oldProps.RefractionTextureEnabled, newProps.RefractionTextureEnabled, 'RefractionTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.roughness, newProps.roughness, 'roughness', changedProps);
        checkColor3Diff(oldProps.specularColor, newProps.specularColor, 'specularColor', changedProps);
        checkPrimitiveDiff(oldProps.specularPower, newProps.specularPower, 'specularPower', changedProps);
        checkTextureDiff(oldProps.specularTexture, newProps.specularTexture, 'specularTexture', changedProps);
        checkPrimitiveDiff(oldProps.SpecularTextureEnabled, newProps.SpecularTextureEnabled, 'SpecularTextureEnabled', changedProps);
        checkPrimitiveDiff(oldProps.twoSidedLighting, newProps.twoSidedLighting, 'twoSidedLighting', changedProps);
        checkPrimitiveDiff(oldProps.useAlphaFromDiffuseTexture, newProps.useAlphaFromDiffuseTexture, 'useAlphaFromDiffuseTexture', changedProps);
        checkPrimitiveDiff(oldProps.useEmissiveAsIllumination, newProps.useEmissiveAsIllumination, 'useEmissiveAsIllumination', changedProps);
        checkPrimitiveDiff(oldProps.useGlossinessFromSpecularMapAlpha, newProps.useGlossinessFromSpecularMapAlpha, 'useGlossinessFromSpecularMapAlpha', changedProps);
        checkPrimitiveDiff(oldProps.useLightmapAsShadowmap, newProps.useLightmapAsShadowmap, 'useLightmapAsShadowmap', changedProps);
        checkPrimitiveDiff(oldProps.useLogarithmicDepth, newProps.useLogarithmicDepth, 'useLogarithmicDepth', changedProps);
        checkPrimitiveDiff(oldProps.useObjectSpaceNormalMap, newProps.useObjectSpaceNormalMap, 'useObjectSpaceNormalMap', changedProps);
        checkPrimitiveDiff(oldProps.useParallax, newProps.useParallax, 'useParallax', changedProps);
        checkPrimitiveDiff(oldProps.useParallaxOcclusion, newProps.useParallaxOcclusion, 'useParallaxOcclusion', changedProps);
        checkPrimitiveDiff(oldProps.useReflectionFresnelFromSpecular, newProps.useReflectionFresnelFromSpecular, 'useReflectionFresnelFromSpecular', changedProps);
        checkPrimitiveDiff(oldProps.useReflectionOverAlpha, newProps.useReflectionOverAlpha, 'useReflectionOverAlpha', changedProps);
        checkPrimitiveDiff(oldProps.useSpecularOverAlpha, newProps.useSpecularOverAlpha, 'useSpecularOverAlpha', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberStandardMaterialPropsHandler;
}());
/**
 * This is the default material used in Babylon. It is the best trade off between quality
 * and performances.
 *
 * This code has been generated
 */
var FiberStandardMaterial = /** @class */ (function () {
    function FiberStandardMaterial() {
        this.propsHandlers = [
            new FiberStandardMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberStandardMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStandardMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStandardMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StandardMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberStandardMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberStandardMaterial',
    };
    return FiberStandardMaterial;
}());
var FiberBackgroundMaterialPropsHandler = /** @class */ (function () {
    function FiberBackgroundMaterialPropsHandler() {
    }
    FiberBackgroundMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps._perceptualColor, newProps._perceptualColor, '_perceptualColor', changedProps);
        // type: 'BabylonjsCoreColorCurves' property (not coded) BabylonjsCoreBackgroundMaterial.cameraColorCurves.
        checkPrimitiveDiff(oldProps.cameraColorCurvesEnabled, newProps.cameraColorCurvesEnabled, 'cameraColorCurvesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.cameraColorGradingEnabled, newProps.cameraColorGradingEnabled, 'cameraColorGradingEnabled', changedProps);
        checkTextureDiff(oldProps.cameraColorGradingTexture, newProps.cameraColorGradingTexture, 'cameraColorGradingTexture', changedProps);
        checkPrimitiveDiff(oldProps.cameraContrast, newProps.cameraContrast, 'cameraContrast', changedProps);
        checkPrimitiveDiff(oldProps.cameraExposure, newProps.cameraExposure, 'cameraExposure', changedProps);
        checkPrimitiveDiff(oldProps.cameraToneMappingEnabled, newProps.cameraToneMappingEnabled, 'cameraToneMappingEnabled', changedProps);
        checkTextureDiff(oldProps.diffuseTexture, newProps.diffuseTexture, 'diffuseTexture', changedProps);
        checkPrimitiveDiff(oldProps.enableNoise, newProps.enableNoise, 'enableNoise', changedProps);
        checkPrimitiveDiff(oldProps.fovMultiplier, newProps.fovMultiplier, 'fovMultiplier', changedProps);
        // type: 'BabylonjsCoreImageProcessingConfiguration' property (not coded) BabylonjsCoreBackgroundMaterial.imageProcessingConfiguration.
        checkPrimitiveDiff(oldProps.maxSimultaneousLights, newProps.maxSimultaneousLights, 'maxSimultaneousLights', changedProps);
        checkPrimitiveDiff(oldProps.opacityFresnel, newProps.opacityFresnel, 'opacityFresnel', changedProps);
        checkColor3Diff(oldProps.primaryColor, newProps.primaryColor, 'primaryColor', changedProps);
        checkPrimitiveDiff(oldProps.primaryColorHighlightLevel, newProps.primaryColorHighlightLevel, 'primaryColorHighlightLevel', changedProps);
        checkPrimitiveDiff(oldProps.primaryColorShadowLevel, newProps.primaryColorShadowLevel, 'primaryColorShadowLevel', changedProps);
        checkPrimitiveDiff(oldProps.reflectionAmount, newProps.reflectionAmount, 'reflectionAmount', changedProps);
        checkPrimitiveDiff(oldProps.reflectionBlur, newProps.reflectionBlur, 'reflectionBlur', changedProps);
        checkPrimitiveDiff(oldProps.reflectionFalloffDistance, newProps.reflectionFalloffDistance, 'reflectionFalloffDistance', changedProps);
        checkPrimitiveDiff(oldProps.reflectionFresnel, newProps.reflectionFresnel, 'reflectionFresnel', changedProps);
        checkPrimitiveDiff(oldProps.reflectionReflectance0, newProps.reflectionReflectance0, 'reflectionReflectance0', changedProps);
        checkPrimitiveDiff(oldProps.reflectionReflectance90, newProps.reflectionReflectance90, 'reflectionReflectance90', changedProps);
        checkPrimitiveDiff(oldProps.reflectionStandardFresnelWeight, newProps.reflectionStandardFresnelWeight, 'reflectionStandardFresnelWeight', changedProps);
        checkTextureDiff(oldProps.reflectionTexture, newProps.reflectionTexture, 'reflectionTexture', changedProps);
        checkVector3Diff(oldProps.sceneCenter, newProps.sceneCenter, 'sceneCenter', changedProps);
        checkPrimitiveDiff(oldProps['sceneCenter-x'], newProps['sceneCenter-x'], 'sceneCenter.x', changedProps);
        checkPrimitiveDiff(oldProps['sceneCenter-y'], newProps['sceneCenter-y'], 'sceneCenter.y', changedProps);
        checkPrimitiveDiff(oldProps['sceneCenter-z'], newProps['sceneCenter-z'], 'sceneCenter.z', changedProps);
        checkPrimitiveDiff(oldProps.shadowLevel, newProps.shadowLevel, 'shadowLevel', changedProps);
        // type: 'BabylonjsCoreIShadowLight[]' property (not coded) BabylonjsCoreBackgroundMaterial.shadowLights.
        checkPrimitiveDiff(oldProps.shadowOnly, newProps.shadowOnly, 'shadowOnly', changedProps);
        checkPrimitiveDiff(oldProps.switchToBGR, newProps.switchToBGR, 'switchToBGR', changedProps);
        checkPrimitiveDiff(oldProps.useEquirectangularFOV, newProps.useEquirectangularFOV, 'useEquirectangularFOV', changedProps);
        checkPrimitiveDiff(oldProps.useRGBColor, newProps.useRGBColor, 'useRGBColor', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBackgroundMaterialPropsHandler;
}());
/**
 * Background material used to create an efficient environment around your scene.
 *
 * This code has been generated
 */
var FiberBackgroundMaterial = /** @class */ (function () {
    function FiberBackgroundMaterial() {
        this.propsHandlers = [
            new FiberBackgroundMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberBackgroundMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBackgroundMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBackgroundMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BackgroundMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberBackgroundMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberBackgroundMaterial',
    };
    return FiberBackgroundMaterial;
}());
var FiberFluentMaterialPropsHandler = /** @class */ (function () {
    function FiberFluentMaterialPropsHandler() {
    }
    FiberFluentMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.albedoColor, newProps.albedoColor, 'albedoColor', changedProps);
        checkTextureDiff(oldProps.albedoTexture, newProps.albedoTexture, 'albedoTexture', changedProps);
        checkPrimitiveDiff(oldProps.borderMinValue, newProps.borderMinValue, 'borderMinValue', changedProps);
        checkPrimitiveDiff(oldProps.borderWidth, newProps.borderWidth, 'borderWidth', changedProps);
        checkPrimitiveDiff(oldProps.edgeSmoothingValue, newProps.edgeSmoothingValue, 'edgeSmoothingValue', changedProps);
        checkColor4Diff(oldProps.hoverColor, newProps.hoverColor, 'hoverColor', changedProps);
        checkVector3Diff(oldProps.hoverPosition, newProps.hoverPosition, 'hoverPosition', changedProps);
        checkPrimitiveDiff(oldProps['hoverPosition-x'], newProps['hoverPosition-x'], 'hoverPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['hoverPosition-y'], newProps['hoverPosition-y'], 'hoverPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['hoverPosition-z'], newProps['hoverPosition-z'], 'hoverPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.hoverRadius, newProps.hoverRadius, 'hoverRadius', changedProps);
        checkColor3Diff(oldProps.innerGlowColor, newProps.innerGlowColor, 'innerGlowColor', changedProps);
        checkPrimitiveDiff(oldProps.innerGlowColorIntensity, newProps.innerGlowColorIntensity, 'innerGlowColorIntensity', changedProps);
        checkPrimitiveDiff(oldProps.renderBorders, newProps.renderBorders, 'renderBorders', changedProps);
        checkPrimitiveDiff(oldProps.renderHoverLight, newProps.renderHoverLight, 'renderHoverLight', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFluentMaterialPropsHandler;
}());
/**
 * Class used to render controls with fluent design
 *
 * This code has been generated
 */
var FiberFluentMaterial = /** @class */ (function () {
    function FiberFluentMaterial() {
        this.propsHandlers = [
            new FiberFluentMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberFluentMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFluentMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFluentMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FluentMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberFluentMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberFluentMaterial',
    };
    return FiberFluentMaterial;
}());
var FiberFluentButtonMaterialPropsHandler = /** @class */ (function () {
    function FiberFluentButtonMaterialPropsHandler() {
    }
    FiberFluentButtonMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.activeFaceDir, newProps.activeFaceDir, 'activeFaceDir', changedProps);
        checkPrimitiveDiff(oldProps['activeFaceDir-x'], newProps['activeFaceDir-x'], 'activeFaceDir.x', changedProps);
        checkPrimitiveDiff(oldProps['activeFaceDir-y'], newProps['activeFaceDir-y'], 'activeFaceDir.y', changedProps);
        checkPrimitiveDiff(oldProps['activeFaceDir-z'], newProps['activeFaceDir-z'], 'activeFaceDir.z', changedProps);
        checkVector3Diff(oldProps.activeFaceUp, newProps.activeFaceUp, 'activeFaceUp', changedProps);
        checkPrimitiveDiff(oldProps['activeFaceUp-x'], newProps['activeFaceUp-x'], 'activeFaceUp.x', changedProps);
        checkPrimitiveDiff(oldProps['activeFaceUp-y'], newProps['activeFaceUp-y'], 'activeFaceUp.y', changedProps);
        checkPrimitiveDiff(oldProps['activeFaceUp-z'], newProps['activeFaceUp-z'], 'activeFaceUp.z', changedProps);
        checkPrimitiveDiff(oldProps.blobFadeLength, newProps.blobFadeLength, 'blobFadeLength', changedProps);
        checkPrimitiveDiff(oldProps.blobFarDistance, newProps.blobFarDistance, 'blobFarDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobFarSize, newProps.blobFarSize, 'blobFarSize', changedProps);
        checkPrimitiveDiff(oldProps.blobIntensity, newProps.blobIntensity, 'blobIntensity', changedProps);
        checkPrimitiveDiff(oldProps.blobNearDistance, newProps.blobNearDistance, 'blobNearDistance', changedProps);
        checkColor4Diff(oldProps.edgeColor, newProps.edgeColor, 'edgeColor', changedProps);
        checkPrimitiveDiff(oldProps.edgeWidth, newProps.edgeWidth, 'edgeWidth', changedProps);
        checkPrimitiveDiff(oldProps.enableFade, newProps.enableFade, 'enableFade', changedProps);
        checkPrimitiveDiff(oldProps.fadeWidth, newProps.fadeWidth, 'fadeWidth', changedProps);
        checkVector3Diff(oldProps.globalLeftIndexTipPosition, newProps.globalLeftIndexTipPosition, 'globalLeftIndexTipPosition', changedProps);
        checkPrimitiveDiff(oldProps['globalLeftIndexTipPosition-x'], newProps['globalLeftIndexTipPosition-x'], 'globalLeftIndexTipPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['globalLeftIndexTipPosition-y'], newProps['globalLeftIndexTipPosition-y'], 'globalLeftIndexTipPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['globalLeftIndexTipPosition-z'], newProps['globalLeftIndexTipPosition-z'], 'globalLeftIndexTipPosition.z', changedProps);
        checkVector3Diff(oldProps.globalRightIndexTipPosition, newProps.globalRightIndexTipPosition, 'globalRightIndexTipPosition', changedProps);
        checkPrimitiveDiff(oldProps['globalRightIndexTipPosition-x'], newProps['globalRightIndexTipPosition-x'], 'globalRightIndexTipPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['globalRightIndexTipPosition-y'], newProps['globalRightIndexTipPosition-y'], 'globalRightIndexTipPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['globalRightIndexTipPosition-z'], newProps['globalRightIndexTipPosition-z'], 'globalRightIndexTipPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.leftBlobEnable, newProps.leftBlobEnable, 'leftBlobEnable', changedProps);
        checkPrimitiveDiff(oldProps.leftBlobFade, newProps.leftBlobFade, 'leftBlobFade', changedProps);
        checkPrimitiveDiff(oldProps.leftBlobInnerFade, newProps.leftBlobInnerFade, 'leftBlobInnerFade', changedProps);
        checkPrimitiveDiff(oldProps.leftBlobNearSize, newProps.leftBlobNearSize, 'leftBlobNearSize', changedProps);
        checkPrimitiveDiff(oldProps.leftBlobPulse, newProps.leftBlobPulse, 'leftBlobPulse', changedProps);
        checkPrimitiveDiff(oldProps.proximityAnisotropy, newProps.proximityAnisotropy, 'proximityAnisotropy', changedProps);
        checkPrimitiveDiff(oldProps.proximityFarDistance, newProps.proximityFarDistance, 'proximityFarDistance', changedProps);
        checkPrimitiveDiff(oldProps.proximityMaxIntensity, newProps.proximityMaxIntensity, 'proximityMaxIntensity', changedProps);
        checkPrimitiveDiff(oldProps.proximityNearRadius, newProps.proximityNearRadius, 'proximityNearRadius', changedProps);
        checkPrimitiveDiff(oldProps.rightBlobEnable, newProps.rightBlobEnable, 'rightBlobEnable', changedProps);
        checkPrimitiveDiff(oldProps.rightBlobFade, newProps.rightBlobFade, 'rightBlobFade', changedProps);
        checkPrimitiveDiff(oldProps.rightBlobInnerFade, newProps.rightBlobInnerFade, 'rightBlobInnerFade', changedProps);
        checkPrimitiveDiff(oldProps.rightBlobNearSize, newProps.rightBlobNearSize, 'rightBlobNearSize', changedProps);
        checkPrimitiveDiff(oldProps.rightBlobPulse, newProps.rightBlobPulse, 'rightBlobPulse', changedProps);
        checkPrimitiveDiff(oldProps.selected, newProps.selected, 'selected', changedProps);
        checkPrimitiveDiff(oldProps.selectedDistance, newProps.selectedDistance, 'selectedDistance', changedProps);
        checkPrimitiveDiff(oldProps.selectedFadeLength, newProps.selectedFadeLength, 'selectedFadeLength', changedProps);
        checkPrimitiveDiff(oldProps.selectionFade, newProps.selectionFade, 'selectionFade', changedProps);
        checkPrimitiveDiff(oldProps.selectionFadeSize, newProps.selectionFadeSize, 'selectionFadeSize', changedProps);
        checkPrimitiveDiff(oldProps.selectionFuzz, newProps.selectionFuzz, 'selectionFuzz', changedProps);
        checkPrimitiveDiff(oldProps.showFrame, newProps.showFrame, 'showFrame', changedProps);
        checkPrimitiveDiff(oldProps.smoothActiveFace, newProps.smoothActiveFace, 'smoothActiveFace', changedProps);
        checkPrimitiveDiff(oldProps.useBlobTexture, newProps.useBlobTexture, 'useBlobTexture', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFluentButtonMaterialPropsHandler;
}());
/**
 * Class used to render square buttons with fluent design
 *
 * This code has been generated
 */
var FiberFluentButtonMaterial = /** @class */ (function () {
    function FiberFluentButtonMaterial() {
        this.propsHandlers = [
            new FiberFluentButtonMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberFluentButtonMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFluentButtonMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFluentButtonMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FluentButtonMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberFluentButtonMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberFluentButtonMaterial',
    };
    return FiberFluentButtonMaterial;
}());
var FiberMRDLSliderBarMaterialPropsHandler = /** @class */ (function () {
    function FiberMRDLSliderBarMaterialPropsHandler() {
    }
    FiberMRDLSliderBarMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor4Diff(oldProps.albedo, newProps.albedo, 'albedo', changedProps);
        checkPrimitiveDiff(oldProps.bevelBack, newProps.bevelBack, 'bevelBack', changedProps);
        checkPrimitiveDiff(oldProps.bevelBackStretch, newProps.bevelBackStretch, 'bevelBackStretch', changedProps);
        checkPrimitiveDiff(oldProps.bevelFront, newProps.bevelFront, 'bevelFront', changedProps);
        checkPrimitiveDiff(oldProps.bevelFrontStretch, newProps.bevelFrontStretch, 'bevelFrontStretch', changedProps);
        checkPrimitiveDiff(oldProps.blobFade, newProps.blobFade, 'blobFade', changedProps);
        checkPrimitiveDiff(oldProps.blobFade2, newProps.blobFade2, 'blobFade2', changedProps);
        checkPrimitiveDiff(oldProps.blobFadeLength, newProps.blobFadeLength, 'blobFadeLength', changedProps);
        checkPrimitiveDiff(oldProps.blobFarDistance, newProps.blobFarDistance, 'blobFarDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobFarSize, newProps.blobFarSize, 'blobFarSize', changedProps);
        checkPrimitiveDiff(oldProps.blobIntensity, newProps.blobIntensity, 'blobIntensity', changedProps);
        checkPrimitiveDiff(oldProps.blobNearDistance, newProps.blobNearDistance, 'blobNearDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobNearSize, newProps.blobNearSize, 'blobNearSize', changedProps);
        checkPrimitiveDiff(oldProps.blobNearSize2, newProps.blobNearSize2, 'blobNearSize2', changedProps);
        checkVector3Diff(oldProps.blobPosition, newProps.blobPosition, 'blobPosition', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition-x'], newProps['blobPosition-x'], 'blobPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition-y'], newProps['blobPosition-y'], 'blobPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition-z'], newProps['blobPosition-z'], 'blobPosition.z', changedProps);
        checkVector3Diff(oldProps.blobPosition2, newProps.blobPosition2, 'blobPosition2', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition2-x'], newProps['blobPosition2-x'], 'blobPosition2.x', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition2-y'], newProps['blobPosition2-y'], 'blobPosition2.y', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition2-z'], newProps['blobPosition2-z'], 'blobPosition2.z', changedProps);
        checkPrimitiveDiff(oldProps.blobPulse, newProps.blobPulse, 'blobPulse', changedProps);
        checkPrimitiveDiff(oldProps.blobPulse2, newProps.blobPulse2, 'blobPulse2', changedProps);
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.blobTexture.
        checkPrimitiveDiff(oldProps.bulgeEnabled, newProps.bulgeEnabled, 'bulgeEnabled', changedProps);
        checkPrimitiveDiff(oldProps.bulgeHeight, newProps.bulgeHeight, 'bulgeHeight', changedProps);
        checkPrimitiveDiff(oldProps.bulgeRadius, newProps.bulgeRadius, 'bulgeRadius', changedProps);
        checkPrimitiveDiff(oldProps.clipFade, newProps.clipFade, 'clipFade', changedProps);
        checkPrimitiveDiff(oldProps.decalFrontOnly, newProps.decalFrontOnly, 'decalFrontOnly', changedProps);
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.decalScaleXY.
        checkPrimitiveDiff(oldProps.edgeReflect, newProps.edgeReflect, 'edgeReflect', changedProps);
        checkPrimitiveDiff(oldProps.frontReflect, newProps.frontReflect, 'frontReflect', changedProps);
        checkPrimitiveDiff(oldProps.fuzz, newProps.fuzz, 'fuzz', changedProps);
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.globalLeftIndexMiddlePosition.
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.globalLeftIndexTipPosition.
        checkPrimitiveDiff(oldProps.globalLeftIndexTipProximity, newProps.globalLeftIndexTipProximity, 'globalLeftIndexTipProximity', changedProps);
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.globalLeftThumbTipPosition.
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.globalRightIndexMiddlePosition.
        checkPrimitiveDiff(oldProps.globalRightIndexTipProximity, newProps.globalRightIndexTipProximity, 'globalRightIndexTipProximity', changedProps);
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.globalRightThumbTipPosition.
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderBarMaterial.globaRightIndexTipPosition.
        checkColor4Diff(oldProps.groundColor, newProps.groundColor, 'groundColor', changedProps);
        checkColor4Diff(oldProps.horizonColor, newProps.horizonColor, 'horizonColor', changedProps);
        checkPrimitiveDiff(oldProps.horizonPower, newProps.horizonPower, 'horizonPower', changedProps);
        checkPrimitiveDiff(oldProps.hueShift, newProps.hueShift, 'hueShift', changedProps);
        checkPrimitiveDiff(oldProps.indirectDiffuse, newProps.indirectDiffuse, 'indirectDiffuse', changedProps);
        checkPrimitiveDiff(oldProps.iridescenceIntensity, newProps.iridescenceIntensity, 'iridescenceIntensity', changedProps);
        checkColor4Diff(oldProps.leftGradientColor, newProps.leftGradientColor, 'leftGradientColor', changedProps);
        checkVector3Diff(oldProps.leftIndexMiddlePosition, newProps.leftIndexMiddlePosition, 'leftIndexMiddlePosition', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexMiddlePosition-x'], newProps['leftIndexMiddlePosition-x'], 'leftIndexMiddlePosition.x', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexMiddlePosition-y'], newProps['leftIndexMiddlePosition-y'], 'leftIndexMiddlePosition.y', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexMiddlePosition-z'], newProps['leftIndexMiddlePosition-z'], 'leftIndexMiddlePosition.z', changedProps);
        checkVector3Diff(oldProps.leftIndexPosition, newProps.leftIndexPosition, 'leftIndexPosition', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexPosition-x'], newProps['leftIndexPosition-x'], 'leftIndexPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexPosition-y'], newProps['leftIndexPosition-y'], 'leftIndexPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexPosition-z'], newProps['leftIndexPosition-z'], 'leftIndexPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.minFuzz, newProps.minFuzz, 'minFuzz', changedProps);
        checkPrimitiveDiff(oldProps.power, newProps.power, 'power', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.radiusBottomLeft, newProps.radiusBottomLeft, 'radiusBottomLeft', changedProps);
        checkPrimitiveDiff(oldProps.radiusBottomRight, newProps.radiusBottomRight, 'radiusBottomRight', changedProps);
        checkPrimitiveDiff(oldProps.radiusTopLeft, newProps.radiusTopLeft, 'radiusTopLeft', changedProps);
        checkPrimitiveDiff(oldProps.radiusTopRight, newProps.radiusTopRight, 'radiusTopRight', changedProps);
        checkPrimitiveDiff(oldProps.reflection, newProps.reflection, 'reflection', changedProps);
        checkColor4Diff(oldProps.rightGradientColor, newProps.rightGradientColor, 'rightGradientColor', changedProps);
        checkVector3Diff(oldProps.rightIndexMiddlePosition, newProps.rightIndexMiddlePosition, 'rightIndexMiddlePosition', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexMiddlePosition-x'], newProps['rightIndexMiddlePosition-x'], 'rightIndexMiddlePosition.x', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexMiddlePosition-y'], newProps['rightIndexMiddlePosition-y'], 'rightIndexMiddlePosition.y', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexMiddlePosition-z'], newProps['rightIndexMiddlePosition-z'], 'rightIndexMiddlePosition.z', changedProps);
        checkVector3Diff(oldProps.rightIndexPosition, newProps.rightIndexPosition, 'rightIndexPosition', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexPosition-x'], newProps['rightIndexPosition-x'], 'rightIndexPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexPosition-y'], newProps['rightIndexPosition-y'], 'rightIndexPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexPosition-z'], newProps['rightIndexPosition-z'], 'rightIndexPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.rimHueShift, newProps.rimHueShift, 'rimHueShift', changedProps);
        checkPrimitiveDiff(oldProps.rimIntensity, newProps.rimIntensity, 'rimIntensity', changedProps);
        checkPrimitiveDiff(oldProps.rimSaturationShift, newProps.rimSaturationShift, 'rimSaturationShift', changedProps);
        checkPrimitiveDiff(oldProps.rimValueShift, newProps.rimValueShift, 'rimValueShift', changedProps);
        checkPrimitiveDiff(oldProps.saturationShift, newProps.saturationShift, 'saturationShift', changedProps);
        checkPrimitiveDiff(oldProps.sharpness, newProps.sharpness, 'sharpness', changedProps);
        checkPrimitiveDiff(oldProps.shininess, newProps.shininess, 'shininess', changedProps);
        checkColor4Diff(oldProps.skyColor, newProps.skyColor, 'skyColor', changedProps);
        checkPrimitiveDiff(oldProps.specular, newProps.specular, 'specular', changedProps);
        checkPrimitiveDiff(oldProps.subsurface, newProps.subsurface, 'subsurface', changedProps);
        checkPrimitiveDiff(oldProps.sunIntensity, newProps.sunIntensity, 'sunIntensity', changedProps);
        checkPrimitiveDiff(oldProps.sunPhi, newProps.sunPhi, 'sunPhi', changedProps);
        checkPrimitiveDiff(oldProps.sunTheta, newProps.sunTheta, 'sunTheta', changedProps);
        checkPrimitiveDiff(oldProps.useGlobalLeftIndex, newProps.useGlobalLeftIndex, 'useGlobalLeftIndex', changedProps);
        checkPrimitiveDiff(oldProps.useGlobalRightIndex, newProps.useGlobalRightIndex, 'useGlobalRightIndex', changedProps);
        checkPrimitiveDiff(oldProps.valueShift, newProps.valueShift, 'valueShift', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMRDLSliderBarMaterialPropsHandler;
}());
/**
 * Class used to render Slider Bar material with MRDL
 *
 * This code has been generated
 */
var FiberMRDLSliderBarMaterial = /** @class */ (function () {
    function FiberMRDLSliderBarMaterial() {
        this.propsHandlers = [
            new FiberMRDLSliderBarMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberMRDLSliderBarMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMRDLSliderBarMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMRDLSliderBarMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MRDLSliderBarMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberMRDLSliderBarMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberMRDLSliderBarMaterial',
    };
    return FiberMRDLSliderBarMaterial;
}());
var FiberMRDLSliderThumbMaterialPropsHandler = /** @class */ (function () {
    function FiberMRDLSliderThumbMaterialPropsHandler() {
    }
    FiberMRDLSliderThumbMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor4Diff(oldProps.albedo, newProps.albedo, 'albedo', changedProps);
        checkPrimitiveDiff(oldProps.bevelBack, newProps.bevelBack, 'bevelBack', changedProps);
        checkPrimitiveDiff(oldProps.bevelBackStretch, newProps.bevelBackStretch, 'bevelBackStretch', changedProps);
        checkPrimitiveDiff(oldProps.bevelFront, newProps.bevelFront, 'bevelFront', changedProps);
        checkPrimitiveDiff(oldProps.bevelFrontStretch, newProps.bevelFrontStretch, 'bevelFrontStretch', changedProps);
        checkPrimitiveDiff(oldProps.blobFade, newProps.blobFade, 'blobFade', changedProps);
        checkPrimitiveDiff(oldProps.blobFade2, newProps.blobFade2, 'blobFade2', changedProps);
        checkPrimitiveDiff(oldProps.blobFadeLength, newProps.blobFadeLength, 'blobFadeLength', changedProps);
        checkPrimitiveDiff(oldProps.blobFarDistance, newProps.blobFarDistance, 'blobFarDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobFarSize, newProps.blobFarSize, 'blobFarSize', changedProps);
        checkPrimitiveDiff(oldProps.blobIntensity, newProps.blobIntensity, 'blobIntensity', changedProps);
        checkPrimitiveDiff(oldProps.blobNearDistance, newProps.blobNearDistance, 'blobNearDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobNearSize, newProps.blobNearSize, 'blobNearSize', changedProps);
        checkPrimitiveDiff(oldProps.blobNearSize2, newProps.blobNearSize2, 'blobNearSize2', changedProps);
        checkVector3Diff(oldProps.blobPosition, newProps.blobPosition, 'blobPosition', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition-x'], newProps['blobPosition-x'], 'blobPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition-y'], newProps['blobPosition-y'], 'blobPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition-z'], newProps['blobPosition-z'], 'blobPosition.z', changedProps);
        checkVector3Diff(oldProps.blobPosition2, newProps.blobPosition2, 'blobPosition2', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition2-x'], newProps['blobPosition2-x'], 'blobPosition2.x', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition2-y'], newProps['blobPosition2-y'], 'blobPosition2.y', changedProps);
        checkPrimitiveDiff(oldProps['blobPosition2-z'], newProps['blobPosition2-z'], 'blobPosition2.z', changedProps);
        checkPrimitiveDiff(oldProps.blobPulse, newProps.blobPulse, 'blobPulse', changedProps);
        checkPrimitiveDiff(oldProps.blobPulse2, newProps.blobPulse2, 'blobPulse2', changedProps);
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.blobTexture.
        checkPrimitiveDiff(oldProps.bulgeEnabled, newProps.bulgeEnabled, 'bulgeEnabled', changedProps);
        checkPrimitiveDiff(oldProps.bulgeHeight, newProps.bulgeHeight, 'bulgeHeight', changedProps);
        checkPrimitiveDiff(oldProps.bulgeRadius, newProps.bulgeRadius, 'bulgeRadius', changedProps);
        checkPrimitiveDiff(oldProps.clipFade, newProps.clipFade, 'clipFade', changedProps);
        checkPrimitiveDiff(oldProps.decalFrontOnly, newProps.decalFrontOnly, 'decalFrontOnly', changedProps);
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.decalScaleXY.
        checkPrimitiveDiff(oldProps.edgeReflect, newProps.edgeReflect, 'edgeReflect', changedProps);
        checkPrimitiveDiff(oldProps.frontReflect, newProps.frontReflect, 'frontReflect', changedProps);
        checkPrimitiveDiff(oldProps.fuzz, newProps.fuzz, 'fuzz', changedProps);
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.globalLeftIndexMiddlePosition.
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.globalLeftIndexTipPosition.
        checkPrimitiveDiff(oldProps.globalLeftIndexTipProximity, newProps.globalLeftIndexTipProximity, 'globalLeftIndexTipProximity', changedProps);
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.globalLeftThumbTipPosition.
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.globalRightIndexMiddlePosition.
        checkPrimitiveDiff(oldProps.globalRightIndexTipProximity, newProps.globalRightIndexTipProximity, 'globalRightIndexTipProximity', changedProps);
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.globalRightThumbTipPosition.
        // type: 'BabylonjsCoreVector4' property (not coded) BabylonjsGuiMRDLSliderThumbMaterial.globaRightIndexTipPosition.
        checkColor4Diff(oldProps.groundColor, newProps.groundColor, 'groundColor', changedProps);
        checkColor4Diff(oldProps.horizonColor, newProps.horizonColor, 'horizonColor', changedProps);
        checkPrimitiveDiff(oldProps.horizonPower, newProps.horizonPower, 'horizonPower', changedProps);
        checkPrimitiveDiff(oldProps.hueShift, newProps.hueShift, 'hueShift', changedProps);
        checkPrimitiveDiff(oldProps.indirectDiffuse, newProps.indirectDiffuse, 'indirectDiffuse', changedProps);
        checkPrimitiveDiff(oldProps.iridescenceIntensity, newProps.iridescenceIntensity, 'iridescenceIntensity', changedProps);
        checkColor4Diff(oldProps.leftGradientColor, newProps.leftGradientColor, 'leftGradientColor', changedProps);
        checkVector3Diff(oldProps.leftIndexMiddlePosition, newProps.leftIndexMiddlePosition, 'leftIndexMiddlePosition', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexMiddlePosition-x'], newProps['leftIndexMiddlePosition-x'], 'leftIndexMiddlePosition.x', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexMiddlePosition-y'], newProps['leftIndexMiddlePosition-y'], 'leftIndexMiddlePosition.y', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexMiddlePosition-z'], newProps['leftIndexMiddlePosition-z'], 'leftIndexMiddlePosition.z', changedProps);
        checkVector3Diff(oldProps.leftIndexPosition, newProps.leftIndexPosition, 'leftIndexPosition', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexPosition-x'], newProps['leftIndexPosition-x'], 'leftIndexPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexPosition-y'], newProps['leftIndexPosition-y'], 'leftIndexPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['leftIndexPosition-z'], newProps['leftIndexPosition-z'], 'leftIndexPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.minFuzz, newProps.minFuzz, 'minFuzz', changedProps);
        checkPrimitiveDiff(oldProps.power, newProps.power, 'power', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.radiusBottomLeft, newProps.radiusBottomLeft, 'radiusBottomLeft', changedProps);
        checkPrimitiveDiff(oldProps.radiusBottomRight, newProps.radiusBottomRight, 'radiusBottomRight', changedProps);
        checkPrimitiveDiff(oldProps.radiusTopLeft, newProps.radiusTopLeft, 'radiusTopLeft', changedProps);
        checkPrimitiveDiff(oldProps.radiusTopRight, newProps.radiusTopRight, 'radiusTopRight', changedProps);
        checkPrimitiveDiff(oldProps.reflection, newProps.reflection, 'reflection', changedProps);
        checkColor4Diff(oldProps.rightGradientColor, newProps.rightGradientColor, 'rightGradientColor', changedProps);
        checkVector3Diff(oldProps.rightIndexMiddlePosition, newProps.rightIndexMiddlePosition, 'rightIndexMiddlePosition', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexMiddlePosition-x'], newProps['rightIndexMiddlePosition-x'], 'rightIndexMiddlePosition.x', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexMiddlePosition-y'], newProps['rightIndexMiddlePosition-y'], 'rightIndexMiddlePosition.y', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexMiddlePosition-z'], newProps['rightIndexMiddlePosition-z'], 'rightIndexMiddlePosition.z', changedProps);
        checkVector3Diff(oldProps.rightIndexPosition, newProps.rightIndexPosition, 'rightIndexPosition', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexPosition-x'], newProps['rightIndexPosition-x'], 'rightIndexPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexPosition-y'], newProps['rightIndexPosition-y'], 'rightIndexPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['rightIndexPosition-z'], newProps['rightIndexPosition-z'], 'rightIndexPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.rimHueShift, newProps.rimHueShift, 'rimHueShift', changedProps);
        checkPrimitiveDiff(oldProps.rimIntensity, newProps.rimIntensity, 'rimIntensity', changedProps);
        checkPrimitiveDiff(oldProps.rimSaturationShift, newProps.rimSaturationShift, 'rimSaturationShift', changedProps);
        checkPrimitiveDiff(oldProps.rimValueShift, newProps.rimValueShift, 'rimValueShift', changedProps);
        checkPrimitiveDiff(oldProps.saturationShift, newProps.saturationShift, 'saturationShift', changedProps);
        checkPrimitiveDiff(oldProps.sharpness, newProps.sharpness, 'sharpness', changedProps);
        checkPrimitiveDiff(oldProps.shininess, newProps.shininess, 'shininess', changedProps);
        checkColor4Diff(oldProps.skyColor, newProps.skyColor, 'skyColor', changedProps);
        checkPrimitiveDiff(oldProps.specular, newProps.specular, 'specular', changedProps);
        checkPrimitiveDiff(oldProps.subsurface, newProps.subsurface, 'subsurface', changedProps);
        checkPrimitiveDiff(oldProps.sunIntensity, newProps.sunIntensity, 'sunIntensity', changedProps);
        checkPrimitiveDiff(oldProps.sunPhi, newProps.sunPhi, 'sunPhi', changedProps);
        checkPrimitiveDiff(oldProps.sunTheta, newProps.sunTheta, 'sunTheta', changedProps);
        checkPrimitiveDiff(oldProps.useGlobalLeftIndex, newProps.useGlobalLeftIndex, 'useGlobalLeftIndex', changedProps);
        checkPrimitiveDiff(oldProps.useGlobalRightIndex, newProps.useGlobalRightIndex, 'useGlobalRightIndex', changedProps);
        checkPrimitiveDiff(oldProps.valueShift, newProps.valueShift, 'valueShift', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMRDLSliderThumbMaterialPropsHandler;
}());
/**
 * Class used to render Slider Thumb material with MRDL
 *
 * This code has been generated
 */
var FiberMRDLSliderThumbMaterial = /** @class */ (function () {
    function FiberMRDLSliderThumbMaterial() {
        this.propsHandlers = [
            new FiberMRDLSliderThumbMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberMRDLSliderThumbMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMRDLSliderThumbMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMRDLSliderThumbMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MRDLSliderThumbMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberMRDLSliderThumbMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberMRDLSliderThumbMaterial',
    };
    return FiberMRDLSliderThumbMaterial;
}());
var FiberMRDLBackplateMaterialPropsHandler = /** @class */ (function () {
    function FiberMRDLBackplateMaterialPropsHandler() {
    }
    FiberMRDLBackplateMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.absoluteSizes, newProps.absoluteSizes, 'absoluteSizes', changedProps);
        checkColor4Diff(oldProps.baseColor, newProps.baseColor, 'baseColor', changedProps);
        checkColor4Diff(oldProps.bottomLeftGradientColor, newProps.bottomLeftGradientColor, 'bottomLeftGradientColor', changedProps);
        checkColor4Diff(oldProps.bottomRightGradientColor, newProps.bottomRightGradientColor, 'bottomRightGradientColor', changedProps);
        checkPrimitiveDiff(oldProps.edgeLineGradientBlend, newProps.edgeLineGradientBlend, 'edgeLineGradientBlend', changedProps);
        checkPrimitiveDiff(oldProps.edgePower, newProps.edgePower, 'edgePower', changedProps);
        checkPrimitiveDiff(oldProps.edgeWidth, newProps.edgeWidth, 'edgeWidth', changedProps);
        checkPrimitiveDiff(oldProps.fadeOut, newProps.fadeOut, 'fadeOut', changedProps);
        checkColor4Diff(oldProps.gradientColor, newProps.gradientColor, 'gradientColor', changedProps);
        checkColor4Diff(oldProps.highlightColor, newProps.highlightColor, 'highlightColor', changedProps);
        checkPrimitiveDiff(oldProps.highlightWidth, newProps.highlightWidth, 'highlightWidth', changedProps);
        checkPrimitiveDiff(oldProps.iridescenceEdgeIntensity, newProps.iridescenceEdgeIntensity, 'iridescenceEdgeIntensity', changedProps);
        checkPrimitiveDiff(oldProps.iridescenceIntensity, newProps.iridescenceIntensity, 'iridescenceIntensity', changedProps);
        checkColor4Diff(oldProps.iridescenceTint, newProps.iridescenceTint, 'iridescenceTint', changedProps);
        checkColor4Diff(oldProps.lineColor, newProps.lineColor, 'lineColor', changedProps);
        checkPrimitiveDiff(oldProps.lineWidth, newProps.lineWidth, 'lineWidth', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.radiusBottomLeft, newProps.radiusBottomLeft, 'radiusBottomLeft', changedProps);
        checkPrimitiveDiff(oldProps.radiusBottomRight, newProps.radiusBottomRight, 'radiusBottomRight', changedProps);
        checkPrimitiveDiff(oldProps.radiusTopLeft, newProps.radiusTopLeft, 'radiusTopLeft', changedProps);
        checkPrimitiveDiff(oldProps.radiusTopRight, newProps.radiusTopRight, 'radiusTopRight', changedProps);
        checkColor4Diff(oldProps.topLeftGradientColor, newProps.topLeftGradientColor, 'topLeftGradientColor', changedProps);
        checkColor4Diff(oldProps.topRightGradientColor, newProps.topRightGradientColor, 'topRightGradientColor', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMRDLBackplateMaterialPropsHandler;
}());
/**
 * Class used to render backplate material with MRDL
 *
 * This code has been generated
 */
var FiberMRDLBackplateMaterial = /** @class */ (function () {
    function FiberMRDLBackplateMaterial() {
        this.propsHandlers = [
            new FiberMRDLBackplateMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberMRDLBackplateMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMRDLBackplateMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMRDLBackplateMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MRDLBackplateMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberMRDLBackplateMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberMRDLBackplateMaterial',
    };
    return FiberMRDLBackplateMaterial;
}());
var FiberFluentBackplateMaterialPropsHandler = /** @class */ (function () {
    function FiberFluentBackplateMaterialPropsHandler() {
    }
    FiberFluentBackplateMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.absoluteSizes, newProps.absoluteSizes, 'absoluteSizes', changedProps);
        checkColor4Diff(oldProps.baseColor, newProps.baseColor, 'baseColor', changedProps);
        checkPrimitiveDiff(oldProps.blobFade, newProps.blobFade, 'blobFade', changedProps);
        checkPrimitiveDiff(oldProps.blobFade2, newProps.blobFade2, 'blobFade2', changedProps);
        checkPrimitiveDiff(oldProps.blobFadeLength, newProps.blobFadeLength, 'blobFadeLength', changedProps);
        checkPrimitiveDiff(oldProps.blobFarDistance, newProps.blobFarDistance, 'blobFarDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobFarSize, newProps.blobFarSize, 'blobFarSize', changedProps);
        checkPrimitiveDiff(oldProps.blobIntensity, newProps.blobIntensity, 'blobIntensity', changedProps);
        checkPrimitiveDiff(oldProps.blobNearDistance, newProps.blobNearDistance, 'blobNearDistance', changedProps);
        checkPrimitiveDiff(oldProps.blobNearSize, newProps.blobNearSize, 'blobNearSize', changedProps);
        checkPrimitiveDiff(oldProps.blobNearSize2, newProps.blobNearSize2, 'blobNearSize2', changedProps);
        checkPrimitiveDiff(oldProps.blobPulse, newProps.blobPulse, 'blobPulse', changedProps);
        checkPrimitiveDiff(oldProps.blobPulse2, newProps.blobPulse2, 'blobPulse2', changedProps);
        checkPrimitiveDiff(oldProps.fadeOut, newProps.fadeOut, 'fadeOut', changedProps);
        checkVector3Diff(oldProps.globalLeftIndexTipPosition, newProps.globalLeftIndexTipPosition, 'globalLeftIndexTipPosition', changedProps);
        checkPrimitiveDiff(oldProps['globalLeftIndexTipPosition-x'], newProps['globalLeftIndexTipPosition-x'], 'globalLeftIndexTipPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['globalLeftIndexTipPosition-y'], newProps['globalLeftIndexTipPosition-y'], 'globalLeftIndexTipPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['globalLeftIndexTipPosition-z'], newProps['globalLeftIndexTipPosition-z'], 'globalLeftIndexTipPosition.z', changedProps);
        checkVector3Diff(oldProps.globalRightIndexTipPosition, newProps.globalRightIndexTipPosition, 'globalRightIndexTipPosition', changedProps);
        checkPrimitiveDiff(oldProps['globalRightIndexTipPosition-x'], newProps['globalRightIndexTipPosition-x'], 'globalRightIndexTipPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['globalRightIndexTipPosition-y'], newProps['globalRightIndexTipPosition-y'], 'globalRightIndexTipPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['globalRightIndexTipPosition-z'], newProps['globalRightIndexTipPosition-z'], 'globalRightIndexTipPosition.z', changedProps);
        checkColor4Diff(oldProps.highlightColor, newProps.highlightColor, 'highlightColor', changedProps);
        checkPrimitiveDiff(oldProps.highlightWidth, newProps.highlightWidth, 'highlightWidth', changedProps);
        checkPrimitiveDiff(oldProps.iridescenceEdgeIntensity, newProps.iridescenceEdgeIntensity, 'iridescenceEdgeIntensity', changedProps);
        checkPrimitiveDiff(oldProps.iridescenceIntensity, newProps.iridescenceIntensity, 'iridescenceIntensity', changedProps);
        checkColor4Diff(oldProps.lineColor, newProps.lineColor, 'lineColor', changedProps);
        checkPrimitiveDiff(oldProps.lineWidth, newProps.lineWidth, 'lineWidth', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFluentBackplateMaterialPropsHandler;
}());
/**
 * Class used to render square buttons with fluent design
 *
 * This code has been generated
 */
var FiberFluentBackplateMaterial = /** @class */ (function () {
    function FiberFluentBackplateMaterial() {
        this.propsHandlers = [
            new FiberFluentBackplateMaterialPropsHandler(),
            new FiberPushMaterialPropsHandler(),
            new FiberMaterialPropsHandler(),
        ];
    }
    FiberFluentBackplateMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFluentBackplateMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFluentBackplateMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FluentBackplateMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberFluentBackplateMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberFluentBackplateMaterial',
    };
    return FiberFluentBackplateMaterial;
}());
var FiberMultiMaterialPropsHandler = /** @class */ (function () {
    function FiberMultiMaterialPropsHandler() {
    }
    FiberMultiMaterialPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        // skipping type: 'BabylonjsCoreMaterial[]' property (not coded) BabylonjsCoreMultiMaterial.subMaterials.
        return null; // no props to check
    };
    return FiberMultiMaterialPropsHandler;
}());
/**
 * A multi-material is used to apply different materials to different parts of the same object without the need of
 * separate meshes. This can be use to improve performances.
 *
 * This code has been generated
 */
var FiberMultiMaterial = /** @class */ (function () {
    function FiberMultiMaterial() {
        this.propsHandlers = [new FiberMultiMaterialPropsHandler(), new FiberMaterialPropsHandler()];
    }
    FiberMultiMaterial.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMultiMaterial.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMultiMaterial.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MultiMaterial',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberMultiMaterial.Metadata = {
        isMaterial: true,
        className: 'FiberMultiMaterial',
    };
    return FiberMultiMaterial;
}());
var FiberLightPropsHandler = /** @class */ (function () {
    function FiberLightPropsHandler() {
    }
    FiberLightPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.diffuse, newProps.diffuse, 'diffuse', changedProps);
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreLight.excludedMeshes.
        checkPrimitiveDiff(oldProps.excludeWithLayerMask, newProps.excludeWithLayerMask, 'excludeWithLayerMask', changedProps);
        checkPrimitiveDiff(oldProps.falloffType, newProps.falloffType, 'falloffType', changedProps);
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreLight.includedOnlyMeshes.
        checkPrimitiveDiff(oldProps.includeOnlyWithLayerMask, newProps.includeOnlyWithLayerMask, 'includeOnlyWithLayerMask', changedProps);
        checkPrimitiveDiff(oldProps.intensity, newProps.intensity, 'intensity', changedProps);
        checkPrimitiveDiff(oldProps.intensityMode, newProps.intensityMode, 'intensityMode', changedProps);
        checkPrimitiveDiff(oldProps.lightmapMode, newProps.lightmapMode, 'lightmapMode', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.range, newProps.range, 'range', changedProps);
        checkPrimitiveDiff(oldProps.renderPriority, newProps.renderPriority, 'renderPriority', changedProps);
        checkPrimitiveDiff(oldProps.shadowEnabled, newProps.shadowEnabled, 'shadowEnabled', changedProps);
        checkColor3Diff(oldProps.specular, newProps.specular, 'specular', changedProps);
        checkMethodDiff(oldProps.setEnabled, newProps.setEnabled, 'setEnabled', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberLightPropsHandler;
}());
/**
 * Base class of all the lights in Babylon. It groups all the generic information about lights.
 * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
 * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
 *
 * This code has been generated
 */
var FiberLight = /** @class */ (function () {
    function FiberLight() {
        this.propsHandlers = [new FiberLightPropsHandler(), new FiberNodePropsHandler()];
    }
    FiberLight.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLight.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLight.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Light',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberLight.Metadata = {
        isNode: true,
        className: 'FiberLight',
    };
    return FiberLight;
}());
var FiberShadowLightPropsHandler = /** @class */ (function () {
    function FiberShadowLightPropsHandler() {
    }
    FiberShadowLightPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkLambdaDiff(oldProps.customProjectionMatrixBuilder, newProps.customProjectionMatrixBuilder, 'customProjectionMatrixBuilder', changedProps);
        checkVector3Diff(oldProps.direction, newProps.direction, 'direction', changedProps);
        checkPrimitiveDiff(oldProps['direction-x'], newProps['direction-x'], 'direction.x', changedProps);
        checkPrimitiveDiff(oldProps['direction-y'], newProps['direction-y'], 'direction.y', changedProps);
        checkPrimitiveDiff(oldProps['direction-z'], newProps['direction-z'], 'direction.z', changedProps);
        checkVector3Diff(oldProps.position, newProps.position, 'position', changedProps);
        checkPrimitiveDiff(oldProps['position-x'], newProps['position-x'], 'position.x', changedProps);
        checkPrimitiveDiff(oldProps['position-y'], newProps['position-y'], 'position.y', changedProps);
        checkPrimitiveDiff(oldProps['position-z'], newProps['position-z'], 'position.z', changedProps);
        checkPrimitiveDiff(oldProps.shadowMaxZ, newProps.shadowMaxZ, 'shadowMaxZ', changedProps);
        checkPrimitiveDiff(oldProps.shadowMinZ, newProps.shadowMinZ, 'shadowMinZ', changedProps);
        checkVector3Diff(oldProps.transformedDirection, newProps.transformedDirection, 'transformedDirection', changedProps);
        checkPrimitiveDiff(oldProps['transformedDirection-x'], newProps['transformedDirection-x'], 'transformedDirection.x', changedProps);
        checkPrimitiveDiff(oldProps['transformedDirection-y'], newProps['transformedDirection-y'], 'transformedDirection.y', changedProps);
        checkPrimitiveDiff(oldProps['transformedDirection-z'], newProps['transformedDirection-z'], 'transformedDirection.z', changedProps);
        checkVector3Diff(oldProps.transformedPosition, newProps.transformedPosition, 'transformedPosition', changedProps);
        checkPrimitiveDiff(oldProps['transformedPosition-x'], newProps['transformedPosition-x'], 'transformedPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['transformedPosition-y'], newProps['transformedPosition-y'], 'transformedPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['transformedPosition-z'], newProps['transformedPosition-z'], 'transformedPosition.z', changedProps);
        checkMethodDiff(oldProps.setDirectionToTarget, newProps.setDirectionToTarget, 'setDirectionToTarget', changedProps);
        checkMethodDiff(oldProps.setShadowProjectionMatrix, newProps.setShadowProjectionMatrix, 'setShadowProjectionMatrix', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberShadowLightPropsHandler;
}());
/**
 * Base implementation IShadowLight
 * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.
 *
 * This code has been generated
 */
var FiberShadowLight = /** @class */ (function () {
    function FiberShadowLight() {
        this.propsHandlers = [
            new FiberShadowLightPropsHandler(),
            new FiberLightPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberShadowLight.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberShadowLight.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberShadowLight.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ShadowLight',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberShadowLight.Metadata = {
        isNode: true,
        isShadowLight: true,
        className: 'FiberShadowLight',
    };
    return FiberShadowLight;
}());
var FiberDirectionalLightPropsHandler = /** @class */ (function () {
    function FiberDirectionalLightPropsHandler() {
    }
    FiberDirectionalLightPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.autoCalcShadowZBounds, newProps.autoCalcShadowZBounds, 'autoCalcShadowZBounds', changedProps);
        checkPrimitiveDiff(oldProps.autoUpdateExtends, newProps.autoUpdateExtends, 'autoUpdateExtends', changedProps);
        checkPrimitiveDiff(oldProps.orthoBottom, newProps.orthoBottom, 'orthoBottom', changedProps);
        checkPrimitiveDiff(oldProps.orthoLeft, newProps.orthoLeft, 'orthoLeft', changedProps);
        checkPrimitiveDiff(oldProps.orthoRight, newProps.orthoRight, 'orthoRight', changedProps);
        checkPrimitiveDiff(oldProps.orthoTop, newProps.orthoTop, 'orthoTop', changedProps);
        checkPrimitiveDiff(oldProps.shadowFrustumSize, newProps.shadowFrustumSize, 'shadowFrustumSize', changedProps);
        checkPrimitiveDiff(oldProps.shadowOrthoScale, newProps.shadowOrthoScale, 'shadowOrthoScale', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDirectionalLightPropsHandler;
}());
/**
 * A directional light is defined by a direction (what a surprise!).
 * The light is emitted from everywhere in the specified direction, and has an infinite range.
 * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
 * Documentation: https://doc.babylonjs.com/babylon101/lights
 *
 * This code has been generated
 */
var FiberDirectionalLight = /** @class */ (function () {
    function FiberDirectionalLight() {
        this.propsHandlers = [
            new FiberDirectionalLightPropsHandler(),
            new FiberShadowLightPropsHandler(),
            new FiberLightPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberDirectionalLight.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDirectionalLight.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDirectionalLight.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DirectionalLight',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'direction',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberDirectionalLight.Metadata = {
        isNode: true,
        isShadowLight: true,
        className: 'FiberDirectionalLight',
    };
    return FiberDirectionalLight;
}());
var FiberPointLightPropsHandler = /** @class */ (function () {
    function FiberPointLightPropsHandler() {
    }
    FiberPointLightPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.direction, newProps.direction, 'direction', changedProps);
        checkPrimitiveDiff(oldProps['direction-x'], newProps['direction-x'], 'direction.x', changedProps);
        checkPrimitiveDiff(oldProps['direction-y'], newProps['direction-y'], 'direction.y', changedProps);
        checkPrimitiveDiff(oldProps['direction-z'], newProps['direction-z'], 'direction.z', changedProps);
        checkPrimitiveDiff(oldProps.shadowAngle, newProps.shadowAngle, 'shadowAngle', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPointLightPropsHandler;
}());
/**
 * A point light is a light defined by an unique point in world space.
 * The light is emitted in every direction from this point.
 * A good example of a point light is a standard light bulb.
 * Documentation: https://doc.babylonjs.com/babylon101/lights
 *
 * This code has been generated
 */
var FiberPointLight = /** @class */ (function () {
    function FiberPointLight() {
        this.propsHandlers = [
            new FiberPointLightPropsHandler(),
            new FiberShadowLightPropsHandler(),
            new FiberLightPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberPointLight.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPointLight.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPointLight.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PointLight',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberPointLight.Metadata = {
        isNode: true,
        isShadowLight: true,
        className: 'FiberPointLight',
    };
    return FiberPointLight;
}());
var FiberSpotLightPropsHandler = /** @class */ (function () {
    function FiberSpotLightPropsHandler() {
    }
    FiberSpotLightPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.angle, newProps.angle, 'angle', changedProps);
        checkPrimitiveDiff(oldProps.exponent, newProps.exponent, 'exponent', changedProps);
        checkPrimitiveDiff(oldProps.innerAngle, newProps.innerAngle, 'innerAngle', changedProps);
        checkTextureDiff(oldProps.projectionTexture, newProps.projectionTexture, 'projectionTexture', changedProps);
        checkPrimitiveDiff(oldProps.projectionTextureLightFar, newProps.projectionTextureLightFar, 'projectionTextureLightFar', changedProps);
        checkPrimitiveDiff(oldProps.projectionTextureLightNear, newProps.projectionTextureLightNear, 'projectionTextureLightNear', changedProps);
        // type: 'BabylonjsCoreMatrix' property (not coded) BabylonjsCoreSpotLight.projectionTextureProjectionLightMatrix.
        checkVector3Diff(oldProps.projectionTextureUpDirection, newProps.projectionTextureUpDirection, 'projectionTextureUpDirection', changedProps);
        checkPrimitiveDiff(oldProps['projectionTextureUpDirection-x'], newProps['projectionTextureUpDirection-x'], 'projectionTextureUpDirection.x', changedProps);
        checkPrimitiveDiff(oldProps['projectionTextureUpDirection-y'], newProps['projectionTextureUpDirection-y'], 'projectionTextureUpDirection.y', changedProps);
        checkPrimitiveDiff(oldProps['projectionTextureUpDirection-z'], newProps['projectionTextureUpDirection-z'], 'projectionTextureUpDirection.z', changedProps);
        checkPrimitiveDiff(oldProps.shadowAngleScale, newProps.shadowAngleScale, 'shadowAngleScale', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSpotLightPropsHandler;
}());
/**
 * A spot light is defined by a position, a direction, an angle, and an exponent.
 * These values define a cone of light starting from the position, emitting toward the direction.
 * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
 * and the exponent defines the speed of the decay of the light with distance (reach).
 * Documentation: https://doc.babylonjs.com/babylon101/lights
 *
 * This code has been generated
 */
var FiberSpotLight = /** @class */ (function () {
    function FiberSpotLight() {
        this.propsHandlers = [
            new FiberSpotLightPropsHandler(),
            new FiberShadowLightPropsHandler(),
            new FiberLightPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberSpotLight.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSpotLight.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSpotLight.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SpotLight',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'position',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'direction',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'angle',
                type: 'number',
                optional: false,
            },
            {
                name: 'exponent',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberSpotLight.Metadata = {
        isNode: true,
        isShadowLight: true,
        className: 'FiberSpotLight',
    };
    return FiberSpotLight;
}());
var FiberHemisphericLightPropsHandler = /** @class */ (function () {
    function FiberHemisphericLightPropsHandler() {
    }
    FiberHemisphericLightPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.direction, newProps.direction, 'direction', changedProps);
        checkPrimitiveDiff(oldProps['direction-x'], newProps['direction-x'], 'direction.x', changedProps);
        checkPrimitiveDiff(oldProps['direction-y'], newProps['direction-y'], 'direction.y', changedProps);
        checkPrimitiveDiff(oldProps['direction-z'], newProps['direction-z'], 'direction.z', changedProps);
        checkColor3Diff(oldProps.groundColor, newProps.groundColor, 'groundColor', changedProps);
        checkMethodDiff(oldProps.setDirectionToTarget, newProps.setDirectionToTarget, 'setDirectionToTarget', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHemisphericLightPropsHandler;
}());
/**
 * The HemisphericLight simulates the ambient environment light,
 * so the passed direction is the light reflection direction, not the incoming direction.
 *
 * This code has been generated
 */
var FiberHemisphericLight = /** @class */ (function () {
    function FiberHemisphericLight() {
        this.propsHandlers = [
            new FiberHemisphericLightPropsHandler(),
            new FiberLightPropsHandler(),
            new FiberNodePropsHandler(),
        ];
    }
    FiberHemisphericLight.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHemisphericLight.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHemisphericLight.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HemisphericLight',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'direction',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberHemisphericLight.Metadata = {
        isNode: true,
        className: 'FiberHemisphericLight',
    };
    return FiberHemisphericLight;
}());
var FiberControlPropsHandler = /** @class */ (function () {
    function FiberControlPropsHandler() {
    }
    FiberControlPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.alpha, newProps.alpha, 'alpha', changedProps);
        checkPrimitiveDiff(oldProps.clipChildren, newProps.clipChildren, 'clipChildren', changedProps);
        checkPrimitiveDiff(oldProps.clipContent, newProps.clipContent, 'clipContent', changedProps);
        checkPrimitiveDiff(oldProps.color, newProps.color, 'color', changedProps);
        checkPrimitiveDiff(oldProps.descendantsOnlyPadding, newProps.descendantsOnlyPadding, 'descendantsOnlyPadding', changedProps);
        checkPrimitiveDiff(oldProps.disabledColor, newProps.disabledColor, 'disabledColor', changedProps);
        checkPrimitiveDiff(oldProps.disabledColorItem, newProps.disabledColorItem, 'disabledColorItem', changedProps);
        checkPrimitiveDiff(oldProps.fixedRatio, newProps.fixedRatio, 'fixedRatio', changedProps);
        checkPrimitiveDiff(oldProps.fontFamily, newProps.fontFamily, 'fontFamily', changedProps);
        // type: '{ ascent: number; height: number; descent: number; }' property (not coded) BabylonjsGuiControl.fontOffset.
        checkPrimitiveDiff(oldProps.fontSize, newProps.fontSize, 'fontSize', changedProps);
        checkPrimitiveDiff(oldProps.fontSizeInPixels, newProps.fontSizeInPixels, 'fontSizeInPixels', changedProps);
        checkPrimitiveDiff(oldProps.fontStyle, newProps.fontStyle, 'fontStyle', changedProps);
        checkPrimitiveDiff(oldProps.fontWeight, newProps.fontWeight, 'fontWeight', changedProps);
        checkPrimitiveDiff(oldProps.height, newProps.height, 'height', changedProps);
        checkPrimitiveDiff(oldProps.heightInPixels, newProps.heightInPixels, 'heightInPixels', changedProps);
        checkPrimitiveDiff(oldProps.highlightColor, newProps.highlightColor, 'highlightColor', changedProps);
        checkPrimitiveDiff(oldProps.highlightLineWidth, newProps.highlightLineWidth, 'highlightLineWidth', changedProps);
        checkPrimitiveDiff(oldProps.horizontalAlignment, newProps.horizontalAlignment, 'horizontalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.hoverCursor, newProps.hoverCursor, 'hoverCursor', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkPrimitiveDiff(oldProps.isFocusInvisible, newProps.isFocusInvisible, 'isFocusInvisible', changedProps);
        checkPrimitiveDiff(oldProps.isHighlighted, newProps.isHighlighted, 'isHighlighted', changedProps);
        checkPrimitiveDiff(oldProps.isHitTestVisible, newProps.isHitTestVisible, 'isHitTestVisible', changedProps);
        checkPrimitiveDiff(oldProps.isPointerBlocker, newProps.isPointerBlocker, 'isPointerBlocker', changedProps);
        checkPrimitiveDiff(oldProps.isReadOnly, newProps.isReadOnly, 'isReadOnly', changedProps);
        checkPrimitiveDiff(oldProps.isVisible, newProps.isVisible, 'isVisible', changedProps);
        checkPrimitiveDiff(oldProps.left, newProps.left, 'left', changedProps);
        checkPrimitiveDiff(oldProps.leftInPixels, newProps.leftInPixels, 'leftInPixels', changedProps);
        checkPrimitiveDiff(oldProps.linkOffsetX, newProps.linkOffsetX, 'linkOffsetX', changedProps);
        checkPrimitiveDiff(oldProps.linkOffsetXInPixels, newProps.linkOffsetXInPixels, 'linkOffsetXInPixels', changedProps);
        checkPrimitiveDiff(oldProps.linkOffsetY, newProps.linkOffsetY, 'linkOffsetY', changedProps);
        checkPrimitiveDiff(oldProps.linkOffsetYInPixels, newProps.linkOffsetYInPixels, 'linkOffsetYInPixels', changedProps);
        // type: 'any' property (not coded) BabylonjsGuiControl.metadata.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.notRenderable, newProps.notRenderable, 'notRenderable', changedProps);
        checkObservableDiff(oldProps.onAfterDrawObservable, newProps.onAfterDrawObservable, 'onAfterDrawObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeDrawObservable, newProps.onBeforeDrawObservable, 'onBeforeDrawObservable', changedProps);
        checkObservableDiff(oldProps.onDirtyObservable, newProps.onDirtyObservable, 'onDirtyObservable', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        checkObservableDiff(oldProps.onPointerClickObservable, newProps.onPointerClickObservable, 'onPointerClickObservable', changedProps);
        checkObservableDiff(oldProps.onPointerDownObservable, newProps.onPointerDownObservable, 'onPointerDownObservable', changedProps);
        checkObservableDiff(oldProps.onPointerEnterObservable, newProps.onPointerEnterObservable, 'onPointerEnterObservable', changedProps);
        checkObservableDiff(oldProps.onPointerMoveObservable, newProps.onPointerMoveObservable, 'onPointerMoveObservable', changedProps);
        checkObservableDiff(oldProps.onPointerOutObservable, newProps.onPointerOutObservable, 'onPointerOutObservable', changedProps);
        checkObservableDiff(oldProps.onPointerUpObservable, newProps.onPointerUpObservable, 'onPointerUpObservable', changedProps);
        checkObservableDiff(oldProps.onWheelObservable, newProps.onWheelObservable, 'onWheelObservable', changedProps);
        checkPrimitiveDiff(oldProps.overlapDeltaMultiplier, newProps.overlapDeltaMultiplier, 'overlapDeltaMultiplier', changedProps);
        checkPrimitiveDiff(oldProps.overlapGroup, newProps.overlapGroup, 'overlapGroup', changedProps);
        checkPrimitiveDiff(oldProps.paddingBottom, newProps.paddingBottom, 'paddingBottom', changedProps);
        checkPrimitiveDiff(oldProps.paddingBottomInPixels, newProps.paddingBottomInPixels, 'paddingBottomInPixels', changedProps);
        checkPrimitiveDiff(oldProps.paddingLeft, newProps.paddingLeft, 'paddingLeft', changedProps);
        checkPrimitiveDiff(oldProps.paddingLeftInPixels, newProps.paddingLeftInPixels, 'paddingLeftInPixels', changedProps);
        checkPrimitiveDiff(oldProps.paddingRight, newProps.paddingRight, 'paddingRight', changedProps);
        checkPrimitiveDiff(oldProps.paddingRightInPixels, newProps.paddingRightInPixels, 'paddingRightInPixels', changedProps);
        checkPrimitiveDiff(oldProps.paddingTop, newProps.paddingTop, 'paddingTop', changedProps);
        checkPrimitiveDiff(oldProps.paddingTopInPixels, newProps.paddingTopInPixels, 'paddingTopInPixels', changedProps);
        // type: 'BabylonjsGuiContainer' property (not coded) BabylonjsGuiControl.parent.
        checkPrimitiveDiff(oldProps.rotation, newProps.rotation, 'rotation', changedProps);
        checkPrimitiveDiff(oldProps.scaleX, newProps.scaleX, 'scaleX', changedProps);
        checkPrimitiveDiff(oldProps.scaleY, newProps.scaleY, 'scaleY', changedProps);
        checkPrimitiveDiff(oldProps.shadowBlur, newProps.shadowBlur, 'shadowBlur', changedProps);
        checkPrimitiveDiff(oldProps.shadowColor, newProps.shadowColor, 'shadowColor', changedProps);
        checkPrimitiveDiff(oldProps.shadowOffsetX, newProps.shadowOffsetX, 'shadowOffsetX', changedProps);
        checkPrimitiveDiff(oldProps.shadowOffsetY, newProps.shadowOffsetY, 'shadowOffsetY', changedProps);
        // type: 'BabylonjsGuiStyle' property (not coded) BabylonjsGuiControl.style.
        checkPrimitiveDiff(oldProps.top, newProps.top, 'top', changedProps);
        checkPrimitiveDiff(oldProps.topInPixels, newProps.topInPixels, 'topInPixels', changedProps);
        checkPrimitiveDiff(oldProps.transformCenterX, newProps.transformCenterX, 'transformCenterX', changedProps);
        checkPrimitiveDiff(oldProps.transformCenterY, newProps.transformCenterY, 'transformCenterY', changedProps);
        checkPrimitiveDiff(oldProps.uniqueId, newProps.uniqueId, 'uniqueId', changedProps);
        checkPrimitiveDiff(oldProps.useBitmapCache, newProps.useBitmapCache, 'useBitmapCache', changedProps);
        checkPrimitiveDiff(oldProps.verticalAlignment, newProps.verticalAlignment, 'verticalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        checkPrimitiveDiff(oldProps.widthInPixels, newProps.widthInPixels, 'widthInPixels', changedProps);
        checkPrimitiveDiff(oldProps.zIndex, newProps.zIndex, 'zIndex', changedProps);
        checkMethodDiff(oldProps.setPadding, newProps.setPadding, 'setPadding', changedProps);
        checkMethodDiff(oldProps.setPaddingInPixels, newProps.setPaddingInPixels, 'setPaddingInPixels', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberControlPropsHandler;
}());
/**
 * Root class used for all 2D controls
 *
 * This code has been generated
 */
var FiberControl = /** @class */ (function () {
    function FiberControl() {
        this.propsHandlers = [new FiberControlPropsHandler()];
    }
    FiberControl.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberControl.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberControl.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Control',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberControl.Metadata = {
        isGUI2DControl: true,
        className: 'FiberControl',
    };
    return FiberControl;
}());
var FiberContainerPropsHandler = /** @class */ (function () {
    function FiberContainerPropsHandler() {
    }
    FiberContainerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.adaptHeightToChildren, newProps.adaptHeightToChildren, 'adaptHeightToChildren', changedProps);
        checkPrimitiveDiff(oldProps.adaptWidthToChildren, newProps.adaptWidthToChildren, 'adaptWidthToChildren', changedProps);
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.isReadOnly, newProps.isReadOnly, 'isReadOnly', changedProps);
        checkPrimitiveDiff(oldProps.logLayoutCycleErrors, newProps.logLayoutCycleErrors, 'logLayoutCycleErrors', changedProps);
        checkPrimitiveDiff(oldProps.maxLayoutCycle, newProps.maxLayoutCycle, 'maxLayoutCycle', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.renderToIntermediateTexture, newProps.renderToIntermediateTexture, 'renderToIntermediateTexture', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberContainerPropsHandler;
}());
/**
 * Root class for 2D containers
 *
 * This code has been generated
 */
var FiberContainer = /** @class */ (function () {
    function FiberContainer() {
        this.propsHandlers = [new FiberContainerPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberContainer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberContainer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberContainer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Container',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberContainer.Metadata = {
        isGUI2DControl: true,
        className: 'FiberContainer',
    };
    return FiberContainer;
}());
var FiberRectanglePropsHandler = /** @class */ (function () {
    function FiberRectanglePropsHandler() {
    }
    FiberRectanglePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.cornerRadius, newProps.cornerRadius, 'cornerRadius', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.thickness, newProps.thickness, 'thickness', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRectanglePropsHandler;
}());
/**
 * Class used to create rectangle container
 *
 * This code has been generated
 */
var FiberRectangle = /** @class */ (function () {
    function FiberRectangle() {
        this.propsHandlers = [
            new FiberRectanglePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberRectangle.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRectangle.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRectangle.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Rectangle',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberRectangle.Metadata = {
        isGUI2DControl: true,
        className: 'FiberRectangle',
    };
    return FiberRectangle;
}());
var FiberButtonPropsHandler = /** @class */ (function () {
    function FiberButtonPropsHandler() {
    }
    FiberButtonPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.delegatePickingToChildren, newProps.delegatePickingToChildren, 'delegatePickingToChildren', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkLambdaDiff(oldProps.pointerDownAnimation, newProps.pointerDownAnimation, 'pointerDownAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerEnterAnimation, newProps.pointerEnterAnimation, 'pointerEnterAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerOutAnimation, newProps.pointerOutAnimation, 'pointerOutAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerUpAnimation, newProps.pointerUpAnimation, 'pointerUpAnimation', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberButtonPropsHandler;
}());
/**
 * Class used to create 2D buttons
 *
 * This code has been generated
 */
var FiberButton = /** @class */ (function () {
    function FiberButton() {
        this.propsHandlers = [
            new FiberButtonPropsHandler(),
            new FiberRectanglePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberButton.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberButton.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberButton.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Button',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberButton.Metadata = {
        isGUI2DControl: true,
        className: 'FiberButton',
    };
    return FiberButton;
}());
var FiberFocusableButtonPropsHandler = /** @class */ (function () {
    function FiberFocusableButtonPropsHandler() {
    }
    FiberFocusableButtonPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.focusedColor, newProps.focusedColor, 'focusedColor', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onBlurObservable, newProps.onBlurObservable, 'onBlurObservable', changedProps);
        checkObservableDiff(oldProps.onFocusObservable, newProps.onFocusObservable, 'onFocusObservable', changedProps);
        checkObservableDiff(oldProps.onKeyboardEventProcessedObservable, newProps.onKeyboardEventProcessedObservable, 'onKeyboardEventProcessedObservable', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFocusableButtonPropsHandler;
}());
/**
 * Class used to create a focusable button that can easily handle keyboard events
 *
 * This code has been generated
 */
var FiberFocusableButton = /** @class */ (function () {
    function FiberFocusableButton() {
        this.propsHandlers = [
            new FiberFocusableButtonPropsHandler(),
            new FiberButtonPropsHandler(),
            new FiberRectanglePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberFocusableButton.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFocusableButton.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFocusableButton.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FocusableButton',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberFocusableButton.Metadata = {
        isGUI2DControl: true,
        className: 'FiberFocusableButton',
    };
    return FiberFocusableButton;
}());
var FiberSelectionPanelPropsHandler = /** @class */ (function () {
    function FiberSelectionPanelPropsHandler() {
    }
    FiberSelectionPanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.barColor, newProps.barColor, 'barColor', changedProps);
        checkPrimitiveDiff(oldProps.barHeight, newProps.barHeight, 'barHeight', changedProps);
        checkPrimitiveDiff(oldProps.buttonBackground, newProps.buttonBackground, 'buttonBackground', changedProps);
        checkPrimitiveDiff(oldProps.buttonColor, newProps.buttonColor, 'buttonColor', changedProps);
        // type: 'BabylonjsGuiSelectorGroup[]' property (not coded) BabylonjsGuiSelectionPanel.groups.
        checkPrimitiveDiff(oldProps.headerColor, newProps.headerColor, 'headerColor', changedProps);
        checkPrimitiveDiff(oldProps.labelColor, newProps.labelColor, 'labelColor', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.spacerHeight, newProps.spacerHeight, 'spacerHeight', changedProps);
        checkMethodDiff(oldProps.addGroup, newProps.addGroup, 'addGroup', changedProps);
        checkMethodDiff(oldProps.addToGroupCheckbox, newProps.addToGroupCheckbox, 'addToGroupCheckbox', changedProps);
        checkMethodDiff(oldProps.addToGroupRadio, newProps.addToGroupRadio, 'addToGroupRadio', changedProps);
        checkMethodDiff(oldProps.addToGroupSlider, newProps.addToGroupSlider, 'addToGroupSlider', changedProps);
        checkMethodDiff(oldProps.setHeaderName, newProps.setHeaderName, 'setHeaderName', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSelectionPanelPropsHandler;
}());
/**
 * Class used to hold the controls for the checkboxes, radio buttons and sliders
 *
 * This code has been generated
 */
var FiberSelectionPanel = /** @class */ (function () {
    function FiberSelectionPanel() {
        this.propsHandlers = [
            new FiberSelectionPanelPropsHandler(),
            new FiberRectanglePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberSelectionPanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSelectionPanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSelectionPanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SelectionPanel',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'groups',
                type: 'BabylonjsGuiSelectorGroup[]',
                optional: true,
            },
        ],
    };
    FiberSelectionPanel.Metadata = {
        isGUI2DControl: true,
        className: 'FiberSelectionPanel',
    };
    return FiberSelectionPanel;
}());
var FiberScrollViewerPropsHandler = /** @class */ (function () {
    function FiberScrollViewerPropsHandler() {
    }
    FiberScrollViewerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.barBackground, newProps.barBackground, 'barBackground', changedProps);
        checkPrimitiveDiff(oldProps.barColor, newProps.barColor, 'barColor', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiScrollViewer.barImage.
        checkPrimitiveDiff(oldProps.barImageHeight, newProps.barImageHeight, 'barImageHeight', changedProps);
        checkPrimitiveDiff(oldProps.barSize, newProps.barSize, 'barSize', changedProps);
        checkPrimitiveDiff(oldProps.forceHorizontalBar, newProps.forceHorizontalBar, 'forceHorizontalBar', changedProps);
        checkPrimitiveDiff(oldProps.forceVerticalBar, newProps.forceVerticalBar, 'forceVerticalBar', changedProps);
        checkPrimitiveDiff(oldProps.freezeControls, newProps.freezeControls, 'freezeControls', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiScrollViewer.horizontalBarImage.
        checkPrimitiveDiff(oldProps.horizontalBarImageHeight, newProps.horizontalBarImageHeight, 'horizontalBarImageHeight', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiScrollViewer.horizontalThumbImage.
        checkPrimitiveDiff(oldProps.scrollBackground, newProps.scrollBackground, 'scrollBackground', changedProps);
        checkPrimitiveDiff(oldProps.thumbHeight, newProps.thumbHeight, 'thumbHeight', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiScrollViewer.thumbImage.
        checkPrimitiveDiff(oldProps.thumbLength, newProps.thumbLength, 'thumbLength', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiScrollViewer.verticalBarImage.
        checkPrimitiveDiff(oldProps.verticalBarImageHeight, newProps.verticalBarImageHeight, 'verticalBarImageHeight', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiScrollViewer.verticalThumbImage.
        checkPrimitiveDiff(oldProps.wheelPrecision, newProps.wheelPrecision, 'wheelPrecision', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        checkMethodDiff(oldProps.setBucketSizes, newProps.setBucketSizes, 'setBucketSizes', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScrollViewerPropsHandler;
}());
/**
 * Class used to hold a viewer window and sliders in a grid
 *
 * This code has been generated
 */
var FiberScrollViewer = /** @class */ (function () {
    function FiberScrollViewer() {
        this.propsHandlers = [
            new FiberScrollViewerPropsHandler(),
            new FiberRectanglePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberScrollViewer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberScrollViewer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberScrollViewer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ScrollViewer',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'isImageBased',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberScrollViewer.Metadata = {
        isGUI2DControl: true,
        className: 'FiberScrollViewer',
    };
    return FiberScrollViewer;
}());
var FiberToggleButtonPropsHandler = /** @class */ (function () {
    function FiberToggleButtonPropsHandler() {
    }
    FiberToggleButtonPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.delegatePickingToChildren, newProps.delegatePickingToChildren, 'delegatePickingToChildren', changedProps);
        checkPrimitiveDiff(oldProps.group, newProps.group, 'group', changedProps);
        checkPrimitiveDiff(oldProps.isActive, newProps.isActive, 'isActive', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onIsActiveChangedObservable, newProps.onIsActiveChangedObservable, 'onIsActiveChangedObservable', changedProps);
        checkLambdaDiff(oldProps.pointerDownActiveAnimation, newProps.pointerDownActiveAnimation, 'pointerDownActiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerDownInactiveAnimation, newProps.pointerDownInactiveAnimation, 'pointerDownInactiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerEnterActiveAnimation, newProps.pointerEnterActiveAnimation, 'pointerEnterActiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerEnterInactiveAnimation, newProps.pointerEnterInactiveAnimation, 'pointerEnterInactiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerOutActiveAnimation, newProps.pointerOutActiveAnimation, 'pointerOutActiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerOutInactiveAnimation, newProps.pointerOutInactiveAnimation, 'pointerOutInactiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerUpActiveAnimation, newProps.pointerUpActiveAnimation, 'pointerUpActiveAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerUpInactiveAnimation, newProps.pointerUpInactiveAnimation, 'pointerUpInactiveAnimation', changedProps);
        checkLambdaDiff(oldProps.toActiveAnimation, newProps.toActiveAnimation, 'toActiveAnimation', changedProps);
        checkLambdaDiff(oldProps.toInactiveAnimation, newProps.toInactiveAnimation, 'toInactiveAnimation', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberToggleButtonPropsHandler;
}());
/**
 * Class used to create toggle buttons
 *
 * This code has been generated
 */
var FiberToggleButton = /** @class */ (function () {
    function FiberToggleButton() {
        this.propsHandlers = [
            new FiberToggleButtonPropsHandler(),
            new FiberRectanglePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberToggleButton.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberToggleButton.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberToggleButton.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ToggleButton',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'group',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberToggleButton.Metadata = {
        isGUI2DControl: true,
        className: 'FiberToggleButton',
    };
    return FiberToggleButton;
}());
var FiberStackPanelPropsHandler = /** @class */ (function () {
    function FiberStackPanelPropsHandler() {
    }
    FiberStackPanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.height, newProps.height, 'height', changedProps);
        checkPrimitiveDiff(oldProps.ignoreLayoutWarnings, newProps.ignoreLayoutWarnings, 'ignoreLayoutWarnings', changedProps);
        checkPrimitiveDiff(oldProps.isVertical, newProps.isVertical, 'isVertical', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.spacing, newProps.spacing, 'spacing', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberStackPanelPropsHandler;
}());
/**
 * Class used to create a 2D stack panel container
 *
 * This code has been generated
 */
var FiberStackPanel = /** @class */ (function () {
    function FiberStackPanel() {
        this.propsHandlers = [
            new FiberStackPanelPropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberStackPanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStackPanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStackPanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StackPanel',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberStackPanel.Metadata = {
        isGUI2DControl: true,
        className: 'FiberStackPanel',
    };
    return FiberStackPanel;
}());
var FiberVirtualKeyboardPropsHandler = /** @class */ (function () {
    function FiberVirtualKeyboardPropsHandler() {
    }
    FiberVirtualKeyboardPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.defaultButtonBackground, newProps.defaultButtonBackground, 'defaultButtonBackground', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonColor, newProps.defaultButtonColor, 'defaultButtonColor', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonHeight, newProps.defaultButtonHeight, 'defaultButtonHeight', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonPaddingBottom, newProps.defaultButtonPaddingBottom, 'defaultButtonPaddingBottom', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonPaddingLeft, newProps.defaultButtonPaddingLeft, 'defaultButtonPaddingLeft', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonPaddingRight, newProps.defaultButtonPaddingRight, 'defaultButtonPaddingRight', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonPaddingTop, newProps.defaultButtonPaddingTop, 'defaultButtonPaddingTop', changedProps);
        checkPrimitiveDiff(oldProps.defaultButtonWidth, newProps.defaultButtonWidth, 'defaultButtonWidth', changedProps);
        checkObservableDiff(oldProps.onKeyPressObservable, newProps.onKeyPressObservable, 'onKeyPressObservable', changedProps);
        checkPrimitiveDiff(oldProps.selectedShiftThickness, newProps.selectedShiftThickness, 'selectedShiftThickness', changedProps);
        checkPrimitiveDiff(oldProps.shiftButtonColor, newProps.shiftButtonColor, 'shiftButtonColor', changedProps);
        checkPrimitiveDiff(oldProps.shiftState, newProps.shiftState, 'shiftState', changedProps);
        checkMethodDiff(oldProps.addKeysRow, newProps.addKeysRow, 'addKeysRow', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberVirtualKeyboardPropsHandler;
}());
/**
 * Class used to create virtual keyboard
 *
 * This code has been generated
 */
var FiberVirtualKeyboard = /** @class */ (function () {
    function FiberVirtualKeyboard() {
        this.propsHandlers = [
            new FiberVirtualKeyboardPropsHandler(),
            new FiberStackPanelPropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberVirtualKeyboard.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVirtualKeyboard.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVirtualKeyboard.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VirtualKeyboard',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberVirtualKeyboard.Metadata = {
        isGUI2DControl: true,
        className: 'FiberVirtualKeyboard',
    };
    return FiberVirtualKeyboard;
}());
var FiberEllipsePropsHandler = /** @class */ (function () {
    function FiberEllipsePropsHandler() {
    }
    FiberEllipsePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.thickness, newProps.thickness, 'thickness', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberEllipsePropsHandler;
}());
/**
 * Class used to create 2D ellipse containers
 *
 * This code has been generated
 */
var FiberEllipse = /** @class */ (function () {
    function FiberEllipse() {
        this.propsHandlers = [
            new FiberEllipsePropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberEllipse.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberEllipse.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberEllipse.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Ellipse',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberEllipse.Metadata = {
        isGUI2DControl: true,
        className: 'FiberEllipse',
    };
    return FiberEllipse;
}());
var FiberGridPropsHandler = /** @class */ (function () {
    function FiberGridPropsHandler() {
    }
    FiberGridPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkMethodDiff(oldProps.addColumnDefinition, newProps.addColumnDefinition, 'addColumnDefinition', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        checkMethodDiff(oldProps.addRowDefinition, newProps.addRowDefinition, 'addRowDefinition', changedProps);
        checkMethodDiff(oldProps.setColumnDefinition, newProps.setColumnDefinition, 'setColumnDefinition', changedProps);
        checkMethodDiff(oldProps.setRowDefinition, newProps.setRowDefinition, 'setRowDefinition', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGridPropsHandler;
}());
/**
 * Class used to create a 2D grid container
 *
 * This code has been generated
 */
var FiberGrid = /** @class */ (function () {
    function FiberGrid() {
        this.propsHandlers = [
            new FiberGridPropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberGrid.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGrid.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGrid.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Grid',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberGrid.Metadata = {
        isGUI2DControl: true,
        isGUI2DGrid: true,
        className: 'FiberGrid',
    };
    return FiberGrid;
}());
var Fiber_ScrollViewerWindowPropsHandler = /** @class */ (function () {
    function Fiber_ScrollViewerWindowPropsHandler() {
    }
    Fiber_ScrollViewerWindowPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.freezeControls, newProps.freezeControls, 'freezeControls', changedProps);
        checkPrimitiveDiff(oldProps.parentClientHeight, newProps.parentClientHeight, 'parentClientHeight', changedProps);
        checkPrimitiveDiff(oldProps.parentClientWidth, newProps.parentClientWidth, 'parentClientWidth', changedProps);
        checkMethodDiff(oldProps.setBucketSizes, newProps.setBucketSizes, 'setBucketSizes', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return Fiber_ScrollViewerWindowPropsHandler;
}());
/**
 * Class used to hold a the container for ScrollViewer
 *
 * This code has been generated
 */
var Fiber_ScrollViewerWindow = /** @class */ (function () {
    function Fiber_ScrollViewerWindow() {
        this.propsHandlers = [
            new Fiber_ScrollViewerWindowPropsHandler(),
            new FiberContainerPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    Fiber_ScrollViewerWindow.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    Fiber_ScrollViewerWindow.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    Fiber_ScrollViewerWindow.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: '_ScrollViewerWindow',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    Fiber_ScrollViewerWindow.Metadata = {
        isGUI2DControl: true,
        className: 'Fiber_ScrollViewerWindow',
    };
    return Fiber_ScrollViewerWindow;
}());
var FiberTextBlockPropsHandler = /** @class */ (function () {
    function FiberTextBlockPropsHandler() {
    }
    FiberTextBlockPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.lineSpacing, newProps.lineSpacing, 'lineSpacing', changedProps);
        checkPrimitiveDiff(oldProps.lineThrough, newProps.lineThrough, 'lineThrough', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onLinesReadyObservable, newProps.onLinesReadyObservable, 'onLinesReadyObservable', changedProps);
        checkObservableDiff(oldProps.onTextChangedObservable, newProps.onTextChangedObservable, 'onTextChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.outlineColor, newProps.outlineColor, 'outlineColor', changedProps);
        checkPrimitiveDiff(oldProps.outlineWidth, newProps.outlineWidth, 'outlineWidth', changedProps);
        checkPrimitiveDiff(oldProps.resizeToFit, newProps.resizeToFit, 'resizeToFit', changedProps);
        checkPrimitiveDiff(oldProps.text, newProps.text, 'text', changedProps);
        checkPrimitiveDiff(oldProps.textHorizontalAlignment, newProps.textHorizontalAlignment, 'textHorizontalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.textVerticalAlignment, newProps.textVerticalAlignment, 'textVerticalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.textWrapping, newProps.textWrapping, 'textWrapping', changedProps);
        checkPrimitiveDiff(oldProps.underline, newProps.underline, 'underline', changedProps);
        checkLambdaDiff(oldProps.wordSplittingFunction, newProps.wordSplittingFunction, 'wordSplittingFunction', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTextBlockPropsHandler;
}());
/**
 * Class used to create text block control
 *
 * This code has been generated
 */
var FiberTextBlock = /** @class */ (function () {
    function FiberTextBlock() {
        this.propsHandlers = [new FiberTextBlockPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberTextBlock.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTextBlock.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTextBlock.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TextBlock',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'text',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberTextBlock.Metadata = {
        isGUI2DControl: true,
        className: 'FiberTextBlock',
    };
    return FiberTextBlock;
}());
var FiberImagePropsHandler = /** @class */ (function () {
    function FiberImagePropsHandler() {
    }
    FiberImagePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.autoScale, newProps.autoScale, 'autoScale', changedProps);
        checkPrimitiveDiff(oldProps.cellHeight, newProps.cellHeight, 'cellHeight', changedProps);
        checkPrimitiveDiff(oldProps.cellId, newProps.cellId, 'cellId', changedProps);
        checkPrimitiveDiff(oldProps.cellWidth, newProps.cellWidth, 'cellWidth', changedProps);
        checkPrimitiveDiff(oldProps.detectPointerOnOpaqueOnly, newProps.detectPointerOnOpaqueOnly, 'detectPointerOnOpaqueOnly', changedProps);
        // type: 'BabylonjsCoreIImage' property (not coded) BabylonjsGuiImage.domImage.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onImageLoadedObservable, newProps.onImageLoadedObservable, 'onImageLoadedObservable', changedProps);
        checkObservableDiff(oldProps.onSVGAttributesComputedObservable, newProps.onSVGAttributesComputedObservable, 'onSVGAttributesComputedObservable', changedProps);
        checkPrimitiveDiff(oldProps.populateNinePatchSlicesFromImage, newProps.populateNinePatchSlicesFromImage, 'populateNinePatchSlicesFromImage', changedProps);
        checkPrimitiveDiff(oldProps.sliceBottom, newProps.sliceBottom, 'sliceBottom', changedProps);
        checkPrimitiveDiff(oldProps.sliceLeft, newProps.sliceLeft, 'sliceLeft', changedProps);
        checkPrimitiveDiff(oldProps.sliceRight, newProps.sliceRight, 'sliceRight', changedProps);
        checkPrimitiveDiff(oldProps.sliceTop, newProps.sliceTop, 'sliceTop', changedProps);
        checkPrimitiveDiff(oldProps.source, newProps.source, 'source', changedProps);
        checkPrimitiveDiff(oldProps.sourceHeight, newProps.sourceHeight, 'sourceHeight', changedProps);
        checkPrimitiveDiff(oldProps.sourceLeft, newProps.sourceLeft, 'sourceLeft', changedProps);
        checkPrimitiveDiff(oldProps.sourceTop, newProps.sourceTop, 'sourceTop', changedProps);
        checkPrimitiveDiff(oldProps.sourceWidth, newProps.sourceWidth, 'sourceWidth', changedProps);
        checkPrimitiveDiff(oldProps.stretch, newProps.stretch, 'stretch', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberImagePropsHandler;
}());
/**
 * Class used to create 2D images
 *
 * This code has been generated
 */
var FiberImage = /** @class */ (function () {
    function FiberImage() {
        this.propsHandlers = [new FiberImagePropsHandler(), new FiberControlPropsHandler()];
    }
    FiberImage.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberImage.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberImage.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Image',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'url',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberImage.Metadata = {
        isGUI2DControl: true,
        className: 'FiberImage',
    };
    return FiberImage;
}());
var FiberCheckboxPropsHandler = /** @class */ (function () {
    function FiberCheckboxPropsHandler() {
    }
    FiberCheckboxPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.checkSizeRatio, newProps.checkSizeRatio, 'checkSizeRatio', changedProps);
        checkPrimitiveDiff(oldProps.isChecked, newProps.isChecked, 'isChecked', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onIsCheckedChangedObservable, newProps.onIsCheckedChangedObservable, 'onIsCheckedChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.thickness, newProps.thickness, 'thickness', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCheckboxPropsHandler;
}());
/**
 * Class used to represent a 2D checkbox
 *
 * This code has been generated
 */
var FiberCheckbox = /** @class */ (function () {
    function FiberCheckbox() {
        this.propsHandlers = [new FiberCheckboxPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberCheckbox.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCheckbox.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCheckbox.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Checkbox',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberCheckbox.Metadata = {
        isGUI2DControl: true,
        className: 'FiberCheckbox',
    };
    return FiberCheckbox;
}());
var FiberColorPickerPropsHandler = /** @class */ (function () {
    function FiberColorPickerPropsHandler() {
    }
    FiberColorPickerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.height, newProps.height, 'height', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onValueChangedObservable, newProps.onValueChangedObservable, 'onValueChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.size, newProps.size, 'size', changedProps);
        checkColor3Diff(oldProps.value, newProps.value, 'value', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberColorPickerPropsHandler;
}());
/**
 * Class used to create color pickers
 *
 * This code has been generated
 */
var FiberColorPicker = /** @class */ (function () {
    function FiberColorPicker() {
        this.propsHandlers = [new FiberColorPickerPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberColorPicker.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberColorPicker.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberColorPicker.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ColorPicker',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberColorPicker.Metadata = {
        isGUI2DControl: true,
        className: 'FiberColorPicker',
    };
    return FiberColorPicker;
}());
var FiberInputTextPropsHandler = /** @class */ (function () {
    function FiberInputTextPropsHandler() {
    }
    FiberInputTextPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.addKey, newProps.addKey, 'addKey', changedProps);
        checkPrimitiveDiff(oldProps.autoStretchWidth, newProps.autoStretchWidth, 'autoStretchWidth', changedProps);
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.currentKey, newProps.currentKey, 'currentKey', changedProps);
        checkPrimitiveDiff(oldProps.deadKey, newProps.deadKey, 'deadKey', changedProps);
        checkPrimitiveDiff(oldProps.disableMobilePrompt, newProps.disableMobilePrompt, 'disableMobilePrompt', changedProps);
        checkPrimitiveDiff(oldProps.focusedBackground, newProps.focusedBackground, 'focusedBackground', changedProps);
        checkPrimitiveDiff(oldProps.focusedColor, newProps.focusedColor, 'focusedColor', changedProps);
        checkPrimitiveDiff(oldProps.highligherOpacity, newProps.highligherOpacity, 'highligherOpacity', changedProps);
        checkPrimitiveDiff(oldProps.highlightedText, newProps.highlightedText, 'highlightedText', changedProps);
        checkPrimitiveDiff(oldProps.margin, newProps.margin, 'margin', changedProps);
        checkPrimitiveDiff(oldProps.maxWidth, newProps.maxWidth, 'maxWidth', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onBeforeKeyAddObservable, newProps.onBeforeKeyAddObservable, 'onBeforeKeyAddObservable', changedProps);
        checkObservableDiff(oldProps.onBlurObservable, newProps.onBlurObservable, 'onBlurObservable', changedProps);
        checkObservableDiff(oldProps.onFocusObservable, newProps.onFocusObservable, 'onFocusObservable', changedProps);
        checkPrimitiveDiff(oldProps.onFocusSelectAll, newProps.onFocusSelectAll, 'onFocusSelectAll', changedProps);
        checkObservableDiff(oldProps.onKeyboardEventProcessedObservable, newProps.onKeyboardEventProcessedObservable, 'onKeyboardEventProcessedObservable', changedProps);
        checkObservableDiff(oldProps.onTextChangedObservable, newProps.onTextChangedObservable, 'onTextChangedObservable', changedProps);
        checkObservableDiff(oldProps.onTextCopyObservable, newProps.onTextCopyObservable, 'onTextCopyObservable', changedProps);
        checkObservableDiff(oldProps.onTextCutObservable, newProps.onTextCutObservable, 'onTextCutObservable', changedProps);
        checkObservableDiff(oldProps.onTextHighlightObservable, newProps.onTextHighlightObservable, 'onTextHighlightObservable', changedProps);
        checkObservableDiff(oldProps.onTextPasteObservable, newProps.onTextPasteObservable, 'onTextPasteObservable', changedProps);
        checkPrimitiveDiff(oldProps.placeholderColor, newProps.placeholderColor, 'placeholderColor', changedProps);
        checkPrimitiveDiff(oldProps.placeholderText, newProps.placeholderText, 'placeholderText', changedProps);
        checkPrimitiveDiff(oldProps.promptMessage, newProps.promptMessage, 'promptMessage', changedProps);
        checkPrimitiveDiff(oldProps.text, newProps.text, 'text', changedProps);
        checkPrimitiveDiff(oldProps.textHighlightColor, newProps.textHighlightColor, 'textHighlightColor', changedProps);
        checkPrimitiveDiff(oldProps.thickness, newProps.thickness, 'thickness', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberInputTextPropsHandler;
}());
/**
 * Class used to create input text control
 *
 * This code has been generated
 */
var FiberInputText = /** @class */ (function () {
    function FiberInputText() {
        this.propsHandlers = [new FiberInputTextPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberInputText.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberInputText.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberInputText.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'InputText',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'text',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberInputText.Metadata = {
        isGUI2DControl: true,
        className: 'FiberInputText',
    };
    return FiberInputText;
}());
var FiberInputPasswordPropsHandler = /** @class */ (function () {
    function FiberInputPasswordPropsHandler() {
    }
    FiberInputPasswordPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberInputPasswordPropsHandler;
}());
/**
 * Class used to create a password control
 *
 * This code has been generated
 */
var FiberInputPassword = /** @class */ (function () {
    function FiberInputPassword() {
        this.propsHandlers = [
            new FiberInputPasswordPropsHandler(),
            new FiberInputTextPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberInputPassword.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberInputPassword.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberInputPassword.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'InputPassword',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberInputPassword.Metadata = {
        isGUI2DControl: true,
        className: 'FiberInputPassword',
    };
    return FiberInputPassword;
}());
var FiberLinePropsHandler = /** @class */ (function () {
    function FiberLinePropsHandler() {
    }
    FiberLinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkControlDiff(oldProps.connectedControl, newProps.connectedControl, 'connectedControl', changedProps);
        checkNumericArrayDiff(oldProps.dash, newProps.dash, 'dash', changedProps);
        checkPrimitiveDiff(oldProps.horizontalAlignment, newProps.horizontalAlignment, 'horizontalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.lineWidth, newProps.lineWidth, 'lineWidth', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.verticalAlignment, newProps.verticalAlignment, 'verticalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.x1, newProps.x1, 'x1', changedProps);
        checkPrimitiveDiff(oldProps.x2, newProps.x2, 'x2', changedProps);
        checkPrimitiveDiff(oldProps.y1, newProps.y1, 'y1', changedProps);
        checkPrimitiveDiff(oldProps.y2, newProps.y2, 'y2', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberLinePropsHandler;
}());
/**
 * Class used to render 2D lines
 *
 * This code has been generated
 */
var FiberLine = /** @class */ (function () {
    function FiberLine() {
        this.propsHandlers = [new FiberLinePropsHandler(), new FiberControlPropsHandler()];
    }
    FiberLine.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLine.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLine.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Line',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberLine.Metadata = {
        isGUI2DControl: true,
        className: 'FiberLine',
    };
    return FiberLine;
}());
var FiberMultiLinePropsHandler = /** @class */ (function () {
    function FiberMultiLinePropsHandler() {
    }
    FiberMultiLinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkNumericArrayDiff(oldProps.dash, newProps.dash, 'dash', changedProps);
        checkPrimitiveDiff(oldProps.horizontalAlignment, newProps.horizontalAlignment, 'horizontalAlignment', changedProps);
        checkPrimitiveDiff(oldProps.lineWidth, newProps.lineWidth, 'lineWidth', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkLambdaDiff(oldProps.onPointUpdate, newProps.onPointUpdate, 'onPointUpdate', changedProps);
        checkPrimitiveDiff(oldProps.verticalAlignment, newProps.verticalAlignment, 'verticalAlignment', changedProps);
        checkMethodDiff(oldProps.add, newProps.add, 'add', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMultiLinePropsHandler;
}());
/**
 * Class used to create multi line control
 *
 * This code has been generated
 */
var FiberMultiLine = /** @class */ (function () {
    function FiberMultiLine() {
        this.propsHandlers = [new FiberMultiLinePropsHandler(), new FiberControlPropsHandler()];
    }
    FiberMultiLine.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMultiLine.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMultiLine.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MultiLine',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberMultiLine.Metadata = {
        isGUI2DControl: true,
        className: 'FiberMultiLine',
    };
    return FiberMultiLine;
}());
var FiberRadioButtonPropsHandler = /** @class */ (function () {
    function FiberRadioButtonPropsHandler() {
    }
    FiberRadioButtonPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.checkSizeRatio, newProps.checkSizeRatio, 'checkSizeRatio', changedProps);
        checkPrimitiveDiff(oldProps.group, newProps.group, 'group', changedProps);
        checkPrimitiveDiff(oldProps.isChecked, newProps.isChecked, 'isChecked', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onIsCheckedChangedObservable, newProps.onIsCheckedChangedObservable, 'onIsCheckedChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.thickness, newProps.thickness, 'thickness', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRadioButtonPropsHandler;
}());
/**
 * Class used to create radio button controls
 *
 * This code has been generated
 */
var FiberRadioButton = /** @class */ (function () {
    function FiberRadioButton() {
        this.propsHandlers = [new FiberRadioButtonPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberRadioButton.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRadioButton.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRadioButton.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RadioButton',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberRadioButton.Metadata = {
        isGUI2DControl: true,
        className: 'FiberRadioButton',
    };
    return FiberRadioButton;
}());
var FiberBaseSliderPropsHandler = /** @class */ (function () {
    function FiberBaseSliderPropsHandler() {
    }
    FiberBaseSliderPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.barOffset, newProps.barOffset, 'barOffset', changedProps);
        checkPrimitiveDiff(oldProps.displayThumb, newProps.displayThumb, 'displayThumb', changedProps);
        checkPrimitiveDiff(oldProps.isThumbClamped, newProps.isThumbClamped, 'isThumbClamped', changedProps);
        checkPrimitiveDiff(oldProps.isVertical, newProps.isVertical, 'isVertical', changedProps);
        checkPrimitiveDiff(oldProps.maximum, newProps.maximum, 'maximum', changedProps);
        checkPrimitiveDiff(oldProps.minimum, newProps.minimum, 'minimum', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onValueChangedObservable, newProps.onValueChangedObservable, 'onValueChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.step, newProps.step, 'step', changedProps);
        checkPrimitiveDiff(oldProps.thumbWidth, newProps.thumbWidth, 'thumbWidth', changedProps);
        checkPrimitiveDiff(oldProps.value, newProps.value, 'value', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBaseSliderPropsHandler;
}());
/**
 * Class used to create slider controls
 *
 * This code has been generated
 */
var FiberBaseSlider = /** @class */ (function () {
    function FiberBaseSlider() {
        this.propsHandlers = [new FiberBaseSliderPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberBaseSlider.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBaseSlider.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBaseSlider.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BaseSlider',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberBaseSlider.Metadata = {
        isGUI2DControl: true,
        className: 'FiberBaseSlider',
    };
    return FiberBaseSlider;
}());
var FiberScrollBarPropsHandler = /** @class */ (function () {
    function FiberScrollBarPropsHandler() {
    }
    FiberScrollBarPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.borderColor, newProps.borderColor, 'borderColor', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScrollBarPropsHandler;
}());
/**
 * Class used to create slider controls
 *
 * This code has been generated
 */
var FiberScrollBar = /** @class */ (function () {
    function FiberScrollBar() {
        this.propsHandlers = [
            new FiberScrollBarPropsHandler(),
            new FiberBaseSliderPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberScrollBar.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberScrollBar.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberScrollBar.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ScrollBar',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberScrollBar.Metadata = {
        isGUI2DControl: true,
        className: 'FiberScrollBar',
    };
    return FiberScrollBar;
}());
var FiberImageScrollBarPropsHandler = /** @class */ (function () {
    function FiberImageScrollBarPropsHandler() {
    }
    FiberImageScrollBarPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiImageScrollBar.backgroundImage.
        checkPrimitiveDiff(oldProps.barImageHeight, newProps.barImageHeight, 'barImageHeight', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.num90RotationInVerticalMode, newProps.num90RotationInVerticalMode, 'num90RotationInVerticalMode', changedProps);
        checkPrimitiveDiff(oldProps.thumbHeight, newProps.thumbHeight, 'thumbHeight', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiImageScrollBar.thumbImage.
        checkPrimitiveDiff(oldProps.thumbLength, newProps.thumbLength, 'thumbLength', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberImageScrollBarPropsHandler;
}());
/**
 * Class used to create slider controls
 *
 * This code has been generated
 */
var FiberImageScrollBar = /** @class */ (function () {
    function FiberImageScrollBar() {
        this.propsHandlers = [
            new FiberImageScrollBarPropsHandler(),
            new FiberBaseSliderPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberImageScrollBar.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberImageScrollBar.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberImageScrollBar.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ImageScrollBar',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberImageScrollBar.Metadata = {
        isGUI2DControl: true,
        className: 'FiberImageScrollBar',
    };
    return FiberImageScrollBar;
}());
var FiberSliderPropsHandler = /** @class */ (function () {
    function FiberSliderPropsHandler() {
    }
    FiberSliderPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.borderColor, newProps.borderColor, 'borderColor', changedProps);
        checkPrimitiveDiff(oldProps.displayValueBar, newProps.displayValueBar, 'displayValueBar', changedProps);
        checkPrimitiveDiff(oldProps.isThumbCircle, newProps.isThumbCircle, 'isThumbCircle', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.thumbColor, newProps.thumbColor, 'thumbColor', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSliderPropsHandler;
}());
/**
 * Class used to create slider controls
 *
 * This code has been generated
 */
var FiberSlider = /** @class */ (function () {
    function FiberSlider() {
        this.propsHandlers = [
            new FiberSliderPropsHandler(),
            new FiberBaseSliderPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberSlider.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSlider.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSlider.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Slider',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberSlider.Metadata = {
        isGUI2DControl: true,
        className: 'FiberSlider',
    };
    return FiberSlider;
}());
var FiberImageBasedSliderPropsHandler = /** @class */ (function () {
    function FiberImageBasedSliderPropsHandler() {
    }
    FiberImageBasedSliderPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiImageBasedSlider.backgroundImage.
        checkPrimitiveDiff(oldProps.displayThumb, newProps.displayThumb, 'displayThumb', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiImageBasedSlider.thumbImage.
        // type: 'BabylonjsGuiImage' property (not coded) BabylonjsGuiImageBasedSlider.valueBarImage.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberImageBasedSliderPropsHandler;
}());
/**
 * Class used to create slider controls based on images
 *
 * This code has been generated
 */
var FiberImageBasedSlider = /** @class */ (function () {
    function FiberImageBasedSlider() {
        this.propsHandlers = [
            new FiberImageBasedSliderPropsHandler(),
            new FiberBaseSliderPropsHandler(),
            new FiberControlPropsHandler(),
        ];
    }
    FiberImageBasedSlider.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberImageBasedSlider.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberImageBasedSlider.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ImageBasedSlider',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberImageBasedSlider.Metadata = {
        isGUI2DControl: true,
        className: 'FiberImageBasedSlider',
    };
    return FiberImageBasedSlider;
}());
var FiberDisplayGridPropsHandler = /** @class */ (function () {
    function FiberDisplayGridPropsHandler() {
    }
    FiberDisplayGridPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.cellHeight, newProps.cellHeight, 'cellHeight', changedProps);
        checkPrimitiveDiff(oldProps.cellWidth, newProps.cellWidth, 'cellWidth', changedProps);
        checkPrimitiveDiff(oldProps.displayMajorLines, newProps.displayMajorLines, 'displayMajorLines', changedProps);
        checkPrimitiveDiff(oldProps.displayMinorLines, newProps.displayMinorLines, 'displayMinorLines', changedProps);
        checkPrimitiveDiff(oldProps.majorLineColor, newProps.majorLineColor, 'majorLineColor', changedProps);
        checkPrimitiveDiff(oldProps.majorLineFrequency, newProps.majorLineFrequency, 'majorLineFrequency', changedProps);
        checkPrimitiveDiff(oldProps.majorLineTickness, newProps.majorLineTickness, 'majorLineTickness', changedProps);
        checkPrimitiveDiff(oldProps.minorLineColor, newProps.minorLineColor, 'minorLineColor', changedProps);
        checkPrimitiveDiff(oldProps.minorLineTickness, newProps.minorLineTickness, 'minorLineTickness', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDisplayGridPropsHandler;
}());
/**
 * Class used to render a grid
 *
 * This code has been generated
 */
var FiberDisplayGrid = /** @class */ (function () {
    function FiberDisplayGrid() {
        this.propsHandlers = [new FiberDisplayGridPropsHandler(), new FiberControlPropsHandler()];
    }
    FiberDisplayGrid.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDisplayGrid.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDisplayGrid.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DisplayGrid',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberDisplayGrid.Metadata = {
        isGUI2DControl: true,
        className: 'FiberDisplayGrid',
    };
    return FiberDisplayGrid;
}());
var FiberControl3DPropsHandler = /** @class */ (function () {
    function FiberControl3DPropsHandler() {
    }
    FiberControl3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.isVisible, newProps.isVisible, 'isVisible', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onPointerClickObservable, newProps.onPointerClickObservable, 'onPointerClickObservable', changedProps);
        checkObservableDiff(oldProps.onPointerDownObservable, newProps.onPointerDownObservable, 'onPointerDownObservable', changedProps);
        checkObservableDiff(oldProps.onPointerEnterObservable, newProps.onPointerEnterObservable, 'onPointerEnterObservable', changedProps);
        checkObservableDiff(oldProps.onPointerMoveObservable, newProps.onPointerMoveObservable, 'onPointerMoveObservable', changedProps);
        checkObservableDiff(oldProps.onPointerOutObservable, newProps.onPointerOutObservable, 'onPointerOutObservable', changedProps);
        checkObservableDiff(oldProps.onPointerUpObservable, newProps.onPointerUpObservable, 'onPointerUpObservable', changedProps);
        // type: 'BabylonjsGuiContainer3D' property (not coded) BabylonjsGuiControl3D.parent.
        checkLambdaDiff(oldProps.pointerDownAnimation, newProps.pointerDownAnimation, 'pointerDownAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerEnterAnimation, newProps.pointerEnterAnimation, 'pointerEnterAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerOutAnimation, newProps.pointerOutAnimation, 'pointerOutAnimation', changedProps);
        checkLambdaDiff(oldProps.pointerUpAnimation, newProps.pointerUpAnimation, 'pointerUpAnimation', changedProps);
        checkVector3Diff(oldProps.position, newProps.position, 'position', changedProps);
        checkPrimitiveDiff(oldProps['position-x'], newProps['position-x'], 'position.x', changedProps);
        checkPrimitiveDiff(oldProps['position-y'], newProps['position-y'], 'position.y', changedProps);
        checkPrimitiveDiff(oldProps['position-z'], newProps['position-z'], 'position.z', changedProps);
        checkVector3Diff(oldProps.scaling, newProps.scaling, 'scaling', changedProps);
        checkPrimitiveDiff(oldProps['scaling-x'], newProps['scaling-x'], 'scaling.x', changedProps);
        checkPrimitiveDiff(oldProps['scaling-y'], newProps['scaling-y'], 'scaling.y', changedProps);
        checkPrimitiveDiff(oldProps['scaling-z'], newProps['scaling-z'], 'scaling.z', changedProps);
        checkMethodDiff(oldProps.addBehavior, newProps.addBehavior, 'addBehavior', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberControl3DPropsHandler;
}());
/**
 * Class used as base class for controls
 *
 * This code has been generated
 */
var FiberControl3D = /** @class */ (function () {
    function FiberControl3D() {
        this.propsHandlers = [new FiberControl3DPropsHandler()];
    }
    FiberControl3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberControl3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberControl3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Control3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberControl3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberControl3D',
    };
    return FiberControl3D;
}());
var FiberContainer3DPropsHandler = /** @class */ (function () {
    function FiberContainer3DPropsHandler() {
    }
    FiberContainer3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.blockLayout, newProps.blockLayout, 'blockLayout', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberContainer3DPropsHandler;
}());
/**
 * Class used to create containers for controls
 *
 * This code has been generated
 */
var FiberContainer3D = /** @class */ (function () {
    function FiberContainer3D() {
        this.propsHandlers = [new FiberContainer3DPropsHandler(), new FiberControl3DPropsHandler()];
    }
    FiberContainer3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberContainer3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberContainer3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Container3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberContainer3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberContainer3D',
    };
    return FiberContainer3D;
}());
var FiberVolumeBasedPanelPropsHandler = /** @class */ (function () {
    function FiberVolumeBasedPanelPropsHandler() {
    }
    FiberVolumeBasedPanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.columns, newProps.columns, 'columns', changedProps);
        checkPrimitiveDiff(oldProps.margin, newProps.margin, 'margin', changedProps);
        checkPrimitiveDiff(oldProps.orientation, newProps.orientation, 'orientation', changedProps);
        checkPrimitiveDiff(oldProps.rows, newProps.rows, 'rows', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberVolumeBasedPanelPropsHandler;
}());
/**
 * Abstract class used to create a container panel deployed on the surface of a volume
 *
 * This code has been generated
 */
var FiberVolumeBasedPanel = /** @class */ (function () {
    function FiberVolumeBasedPanel() {
        this.propsHandlers = [
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberVolumeBasedPanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVolumeBasedPanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVolumeBasedPanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VolumeBasedPanel',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberVolumeBasedPanel.Metadata = {
        isGUI3DControl: true,
        className: 'FiberVolumeBasedPanel',
    };
    return FiberVolumeBasedPanel;
}());
var FiberCylinderPanelPropsHandler = /** @class */ (function () {
    function FiberCylinderPanelPropsHandler() {
    }
    FiberCylinderPanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCylinderPanelPropsHandler;
}());
/**
 * Class used to create a container panel deployed on the surface of a cylinder
 *
 * This code has been generated
 */
var FiberCylinderPanel = /** @class */ (function () {
    function FiberCylinderPanel() {
        this.propsHandlers = [
            new FiberCylinderPanelPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberCylinderPanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCylinderPanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCylinderPanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'CylinderPanel',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberCylinderPanel.Metadata = {
        isGUI3DControl: true,
        className: 'FiberCylinderPanel',
    };
    return FiberCylinderPanel;
}());
var FiberTouchHolographicMenuPropsHandler = /** @class */ (function () {
    function FiberTouchHolographicMenuPropsHandler() {
    }
    FiberTouchHolographicMenuPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.backPlateMargin, newProps.backPlateMargin, 'backPlateMargin', changedProps);
        checkMethodDiff(oldProps.addButton, newProps.addButton, 'addButton', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTouchHolographicMenuPropsHandler;
}());
/**
 * Simple menu that can contain holographic buttons
 *
 * This code has been generated
 */
var FiberTouchHolographicMenu = /** @class */ (function () {
    function FiberTouchHolographicMenu() {
        this.propsHandlers = [
            new FiberTouchHolographicMenuPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberTouchHolographicMenu.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTouchHolographicMenu.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTouchHolographicMenu.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TouchHolographicMenu',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberTouchHolographicMenu.Metadata = {
        isGUI3DControl: true,
        className: 'FiberTouchHolographicMenu',
    };
    return FiberTouchHolographicMenu;
}());
var FiberHandMenuPropsHandler = /** @class */ (function () {
    function FiberHandMenuPropsHandler() {
    }
    FiberHandMenuPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberHandMenuPropsHandler;
}());
/**
 * Hand menu that displays buttons and floats around the hand.
 *
 * This code has been generated
 */
var FiberHandMenu = /** @class */ (function () {
    function FiberHandMenu() {
        this.propsHandlers = [
            new FiberHandMenuPropsHandler(),
            new FiberTouchHolographicMenuPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberHandMenu.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHandMenu.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHandMenu.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HandMenu',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'xr',
                type: 'BabylonjsCoreWebXRExperienceHelper',
                optional: false,
            },
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberHandMenu.Metadata = {
        isGUI3DControl: true,
        className: 'FiberHandMenu',
    };
    return FiberHandMenu;
}());
var FiberNearMenuPropsHandler = /** @class */ (function () {
    function FiberNearMenuPropsHandler() {
    }
    FiberNearMenuPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.isPinned, newProps.isPinned, 'isPinned', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberNearMenuPropsHandler;
}());
/**
 * NearMenu that displays buttons and follows the camera
 *
 * This code has been generated
 */
var FiberNearMenu = /** @class */ (function () {
    function FiberNearMenu() {
        this.propsHandlers = [
            new FiberNearMenuPropsHandler(),
            new FiberTouchHolographicMenuPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberNearMenu.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberNearMenu.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberNearMenu.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'NearMenu',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberNearMenu.Metadata = {
        isGUI3DControl: true,
        className: 'FiberNearMenu',
    };
    return FiberNearMenu;
}());
var FiberPlanePanelPropsHandler = /** @class */ (function () {
    function FiberPlanePanelPropsHandler() {
    }
    FiberPlanePanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberPlanePanelPropsHandler;
}());
/**
 * Class used to create a container panel deployed on the surface of a plane
 *
 * This code has been generated
 */
var FiberPlanePanel = /** @class */ (function () {
    function FiberPlanePanel() {
        this.propsHandlers = [
            new FiberPlanePanelPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberPlanePanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPlanePanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPlanePanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PlanePanel',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberPlanePanel.Metadata = {
        isGUI3DControl: true,
        className: 'FiberPlanePanel',
    };
    return FiberPlanePanel;
}());
var FiberScatterPanelPropsHandler = /** @class */ (function () {
    function FiberScatterPanelPropsHandler() {
    }
    FiberScatterPanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.iteration, newProps.iteration, 'iteration', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScatterPanelPropsHandler;
}());
/**
 * Class used to create a container panel where items get randomized planar mapping
 *
 * This code has been generated
 */
var FiberScatterPanel = /** @class */ (function () {
    function FiberScatterPanel() {
        this.propsHandlers = [
            new FiberScatterPanelPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberScatterPanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberScatterPanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberScatterPanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ScatterPanel',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberScatterPanel.Metadata = {
        isGUI3DControl: true,
        className: 'FiberScatterPanel',
    };
    return FiberScatterPanel;
}());
var FiberSpherePanelPropsHandler = /** @class */ (function () {
    function FiberSpherePanelPropsHandler() {
    }
    FiberSpherePanelPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSpherePanelPropsHandler;
}());
/**
 * Class used to create a container panel deployed on the surface of a sphere
 *
 * This code has been generated
 */
var FiberSpherePanel = /** @class */ (function () {
    function FiberSpherePanel() {
        this.propsHandlers = [
            new FiberSpherePanelPropsHandler(),
            new FiberVolumeBasedPanelPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberSpherePanel.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSpherePanel.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSpherePanel.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SpherePanel',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberSpherePanel.Metadata = {
        isGUI3DControl: true,
        className: 'FiberSpherePanel',
    };
    return FiberSpherePanel;
}());
var FiberStackPanel3DPropsHandler = /** @class */ (function () {
    function FiberStackPanel3DPropsHandler() {
    }
    FiberStackPanel3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.isVertical, newProps.isVertical, 'isVertical', changedProps);
        checkPrimitiveDiff(oldProps.margin, newProps.margin, 'margin', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberStackPanel3DPropsHandler;
}());
/**
 * Class used to create a stack panel in 3D on XY plane
 *
 * This code has been generated
 */
var FiberStackPanel3D = /** @class */ (function () {
    function FiberStackPanel3D() {
        this.propsHandlers = [
            new FiberStackPanel3DPropsHandler(),
            new FiberContainer3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberStackPanel3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStackPanel3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStackPanel3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StackPanel3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'isVertical',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberStackPanel3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberStackPanel3D',
    };
    return FiberStackPanel3D;
}());
var FiberContentDisplay3DPropsHandler = /** @class */ (function () {
    function FiberContentDisplay3DPropsHandler() {
    }
    FiberContentDisplay3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkControlDiff(oldProps.content, newProps.content, 'content', changedProps);
        checkPrimitiveDiff(oldProps.contentResolution, newProps.contentResolution, 'contentResolution', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberContentDisplay3DPropsHandler;
}());
/**
 * The base class for controls that display content
 *
 * This code has been generated
 */
var FiberContentDisplay3D = /** @class */ (function () {
    function FiberContentDisplay3D() {
        this.propsHandlers = [new FiberContentDisplay3DPropsHandler(), new FiberControl3DPropsHandler()];
    }
    FiberContentDisplay3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberContentDisplay3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberContentDisplay3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ContentDisplay3D',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberContentDisplay3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberContentDisplay3D',
    };
    return FiberContentDisplay3D;
}());
var FiberAbstractButton3DPropsHandler = /** @class */ (function () {
    function FiberAbstractButton3DPropsHandler() {
    }
    FiberAbstractButton3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberAbstractButton3DPropsHandler;
}());
/**
 * Class used as a root to all buttons
 *
 * This code has been generated
 */
var FiberAbstractButton3D = /** @class */ (function () {
    function FiberAbstractButton3D() {
        this.propsHandlers = [
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberAbstractButton3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAbstractButton3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAbstractButton3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AbstractButton3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberAbstractButton3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberAbstractButton3D',
    };
    return FiberAbstractButton3D;
}());
var FiberButton3DPropsHandler = /** @class */ (function () {
    function FiberButton3DPropsHandler() {
    }
    FiberButton3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberButton3DPropsHandler;
}());
/**
 * Class used to create a button in 3D
 *
 * This code has been generated
 */
var FiberButton3D = /** @class */ (function () {
    function FiberButton3D() {
        this.propsHandlers = [
            new FiberButton3DPropsHandler(),
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberButton3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberButton3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberButton3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Button3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberButton3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberButton3D',
    };
    return FiberButton3D;
}());
var FiberHolographicButtonPropsHandler = /** @class */ (function () {
    function FiberHolographicButtonPropsHandler() {
    }
    FiberHolographicButtonPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.imageUrl, newProps.imageUrl, 'imageUrl', changedProps);
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        checkPrimitiveDiff(oldProps.text, newProps.text, 'text', changedProps);
        checkPrimitiveDiff(oldProps.tooltipText, newProps.tooltipText, 'tooltipText', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHolographicButtonPropsHandler;
}());
/**
 * Class used to create a holographic button in 3D
 *
 * This code has been generated
 */
var FiberHolographicButton = /** @class */ (function () {
    function FiberHolographicButton() {
        this.propsHandlers = [
            new FiberHolographicButtonPropsHandler(),
            new FiberButton3DPropsHandler(),
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberHolographicButton.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHolographicButton.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHolographicButton.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HolographicButton',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'shareMaterials',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberHolographicButton.Metadata = {
        isGUI3DControl: true,
        className: 'FiberHolographicButton',
    };
    return FiberHolographicButton;
}());
var FiberTouchButton3DPropsHandler = /** @class */ (function () {
    function FiberTouchButton3DPropsHandler() {
    }
    FiberTouchButton3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.collidableFrontDirection, newProps.collidableFrontDirection, 'collidableFrontDirection', changedProps);
        checkPrimitiveDiff(oldProps['collidableFrontDirection-x'], newProps['collidableFrontDirection-x'], 'collidableFrontDirection.x', changedProps);
        checkPrimitiveDiff(oldProps['collidableFrontDirection-y'], newProps['collidableFrontDirection-y'], 'collidableFrontDirection.y', changedProps);
        checkPrimitiveDiff(oldProps['collidableFrontDirection-z'], newProps['collidableFrontDirection-z'], 'collidableFrontDirection.z', changedProps);
        // type: 'BabylonjsCoreMesh' property (not coded) BabylonjsGuiTouchButton3D.collisionMesh.
        checkPrimitiveDiff(oldProps.isToggleButton, newProps.isToggleButton, 'isToggleButton', changedProps);
        checkPrimitiveDiff(oldProps.isToggled, newProps.isToggled, 'isToggled', changedProps);
        checkObservableDiff(oldProps.onToggleObservable, newProps.onToggleObservable, 'onToggleObservable', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTouchButton3DPropsHandler;
}());
/**
 * Class used to create a touchable button in 3D
 *
 * This code has been generated
 */
var FiberTouchButton3D = /** @class */ (function () {
    function FiberTouchButton3D() {
        this.propsHandlers = [
            new FiberTouchButton3DPropsHandler(),
            new FiberButton3DPropsHandler(),
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberTouchButton3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTouchButton3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTouchButton3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TouchButton3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'collisionMesh',
                type: 'BabylonjsCoreMesh',
                optional: true,
            },
        ],
    };
    FiberTouchButton3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberTouchButton3D',
    };
    return FiberTouchButton3D;
}());
var FiberTouchHolographicButtonPropsHandler = /** @class */ (function () {
    function FiberTouchHolographicButtonPropsHandler() {
    }
    FiberTouchHolographicButtonPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.imageUrl, newProps.imageUrl, 'imageUrl', changedProps);
        checkPrimitiveDiff(oldProps.isBackplateVisible, newProps.isBackplateVisible, 'isBackplateVisible', changedProps);
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        checkPrimitiveDiff(oldProps.text, newProps.text, 'text', changedProps);
        checkPrimitiveDiff(oldProps.tooltipText, newProps.tooltipText, 'tooltipText', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTouchHolographicButtonPropsHandler;
}());
/**
 * Class used to create a holographic button in 3D
 *
 * This code has been generated
 */
var FiberTouchHolographicButton = /** @class */ (function () {
    function FiberTouchHolographicButton() {
        this.propsHandlers = [
            new FiberTouchHolographicButtonPropsHandler(),
            new FiberTouchButton3DPropsHandler(),
            new FiberButton3DPropsHandler(),
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberTouchHolographicButton.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTouchHolographicButton.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTouchHolographicButton.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TouchHolographicButton',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'shareMaterials',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberTouchHolographicButton.Metadata = {
        isGUI3DControl: true,
        className: 'FiberTouchHolographicButton',
    };
    return FiberTouchHolographicButton;
}());
var FiberTouchMeshButton3DPropsHandler = /** @class */ (function () {
    function FiberTouchMeshButton3DPropsHandler() {
    }
    FiberTouchMeshButton3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberTouchMeshButton3DPropsHandler;
}());
/**
 * Class used to create an interactable object. It's a touchable 3D button using a mesh coming from the current scene
 *
 * This code has been generated
 */
var FiberTouchMeshButton3D = /** @class */ (function () {
    function FiberTouchMeshButton3D() {
        this.propsHandlers = [
            new FiberTouchMeshButton3DPropsHandler(),
            new FiberTouchButton3DPropsHandler(),
            new FiberButton3DPropsHandler(),
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberTouchMeshButton3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTouchMeshButton3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTouchMeshButton3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TouchMeshButton3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'mesh',
                type: 'BabylonjsCoreMesh',
                optional: false,
            },
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberTouchMeshButton3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberTouchMeshButton3D',
    };
    return FiberTouchMeshButton3D;
}());
var FiberMeshButton3DPropsHandler = /** @class */ (function () {
    function FiberMeshButton3DPropsHandler() {
    }
    FiberMeshButton3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberMeshButton3DPropsHandler;
}());
/**
 * Class used to create an interactable object. It's a 3D button using a mesh coming from the current scene
 *
 * This code has been generated
 */
var FiberMeshButton3D = /** @class */ (function () {
    function FiberMeshButton3D() {
        this.propsHandlers = [
            new FiberMeshButton3DPropsHandler(),
            new FiberButton3DPropsHandler(),
            new FiberAbstractButton3DPropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberMeshButton3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMeshButton3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMeshButton3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MeshButton3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'mesh',
                type: 'BabylonjsCoreMesh',
                optional: false,
            },
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberMeshButton3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberMeshButton3D',
    };
    return FiberMeshButton3D;
}());
var FiberHolographicSlatePropsHandler = /** @class */ (function () {
    function FiberHolographicSlatePropsHandler() {
    }
    FiberHolographicSlatePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsGuiHolographicSlate.dimensions.
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsGuiHolographicSlate.minDimensions.
        checkVector3Diff(oldProps.origin, newProps.origin, 'origin', changedProps);
        checkPrimitiveDiff(oldProps['origin-x'], newProps['origin-x'], 'origin.x', changedProps);
        checkPrimitiveDiff(oldProps['origin-y'], newProps['origin-y'], 'origin.y', changedProps);
        checkPrimitiveDiff(oldProps['origin-z'], newProps['origin-z'], 'origin.z', changedProps);
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        checkPrimitiveDiff(oldProps.title, newProps.title, 'title', changedProps);
        checkPrimitiveDiff(oldProps.titleBarHeight, newProps.titleBarHeight, 'titleBarHeight', changedProps);
        checkPrimitiveDiff(oldProps.titleBarMargin, newProps.titleBarMargin, 'titleBarMargin', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHolographicSlatePropsHandler;
}());
/**
 * Class used to create a holographic slate
 *
 * This code has been generated
 */
var FiberHolographicSlate = /** @class */ (function () {
    function FiberHolographicSlate() {
        this.propsHandlers = [
            new FiberHolographicSlatePropsHandler(),
            new FiberContentDisplay3DPropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberHolographicSlate.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHolographicSlate.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHolographicSlate.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HolographicSlate',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberHolographicSlate.Metadata = {
        isGUI3DControl: true,
        className: 'FiberHolographicSlate',
    };
    return FiberHolographicSlate;
}());
var FiberSlider3DPropsHandler = /** @class */ (function () {
    function FiberSlider3DPropsHandler() {
    }
    FiberSlider3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.maximum, newProps.maximum, 'maximum', changedProps);
        checkPrimitiveDiff(oldProps.minimum, newProps.minimum, 'minimum', changedProps);
        checkObservableDiff(oldProps.onValueChangedObservable, newProps.onValueChangedObservable, 'onValueChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.step, newProps.step, 'step', changedProps);
        checkPrimitiveDiff(oldProps.value, newProps.value, 'value', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSlider3DPropsHandler;
}());
/**
 * Class used to create a slider in 3D
 *
 * This code has been generated
 */
var FiberSlider3D = /** @class */ (function () {
    function FiberSlider3D() {
        this.propsHandlers = [new FiberSlider3DPropsHandler(), new FiberControl3DPropsHandler()];
    }
    FiberSlider3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSlider3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSlider3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Slider3D',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'sliderBackplateVisible',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberSlider3D.Metadata = {
        isGUI3DControl: true,
        className: 'FiberSlider3D',
    };
    return FiberSlider3D;
}());
var FiberHolographicBackplatePropsHandler = /** @class */ (function () {
    function FiberHolographicBackplatePropsHandler() {
    }
    FiberHolographicBackplatePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHolographicBackplatePropsHandler;
}());
/**
 * Class used to create a holographic backplate in 3D
 *
 * This code has been generated
 */
var FiberHolographicBackplate = /** @class */ (function () {
    function FiberHolographicBackplate() {
        this.propsHandlers = [
            new FiberHolographicBackplatePropsHandler(),
            new FiberControl3DPropsHandler(),
        ];
    }
    FiberHolographicBackplate.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHolographicBackplate.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHolographicBackplate.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HolographicBackplate',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: '_shareMaterials',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberHolographicBackplate.Metadata = {
        isGUI3DControl: true,
        className: 'FiberHolographicBackplate',
    };
    return FiberHolographicBackplate;
}());
var FiberEffectLayerPropsHandler = /** @class */ (function () {
    function FiberEffectLayerPropsHandler() {
    }
    FiberEffectLayerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.disableBoundingBoxesFromEffectLayer, newProps.disableBoundingBoxesFromEffectLayer, 'disableBoundingBoxesFromEffectLayer', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkColor4Diff(oldProps.neutralColor, newProps.neutralColor, 'neutralColor', changedProps);
        checkObservableDiff(oldProps.onAfterComposeObservable, newProps.onAfterComposeObservable, 'onAfterComposeObservable', changedProps);
        checkObservableDiff(oldProps.onAfterRenderMeshToEffect, newProps.onAfterRenderMeshToEffect, 'onAfterRenderMeshToEffect', changedProps);
        checkObservableDiff(oldProps.onBeforeComposeObservable, newProps.onBeforeComposeObservable, 'onBeforeComposeObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderMainTextureObservable, newProps.onBeforeRenderMainTextureObservable, 'onBeforeRenderMainTextureObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderMeshToEffect, newProps.onBeforeRenderMeshToEffect, 'onBeforeRenderMeshToEffect', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        checkObservableDiff(oldProps.onSizeChangedObservable, newProps.onSizeChangedObservable, 'onSizeChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.renderingGroupId, newProps.renderingGroupId, 'renderingGroupId', changedProps);
        checkMethodDiff(oldProps.setMaterialForRendering, newProps.setMaterialForRendering, 'setMaterialForRendering', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberEffectLayerPropsHandler;
}());
/**
 * The effect layer Helps adding post process effect blended with the main pass.
 *
 * This can be for instance use to generate glow or highlight effects on the scene.
 *
 * The effect layer class can not be used directly and is intented to inherited from to be
 * customized per effects.
 *
 * This code has been generated
 */
var FiberEffectLayer = /** @class */ (function () {
    function FiberEffectLayer() {
        this.propsHandlers = [new FiberEffectLayerPropsHandler()];
    }
    FiberEffectLayer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberEffectLayer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberEffectLayer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'EffectLayer',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberEffectLayer.Metadata = {
        isEffectLayer: true,
        isGlowLayer: false,
        className: 'FiberEffectLayer',
    };
    return FiberEffectLayer;
}());
var FiberGlowLayerPropsHandler = /** @class */ (function () {
    function FiberGlowLayerPropsHandler() {
    }
    FiberGlowLayerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.blurKernelSize, newProps.blurKernelSize, 'blurKernelSize', changedProps);
        checkLambdaDiff(oldProps.customEmissiveColorSelector, newProps.customEmissiveColorSelector, 'customEmissiveColorSelector', changedProps);
        checkLambdaDiff(oldProps.customEmissiveTextureSelector, newProps.customEmissiveTextureSelector, 'customEmissiveTextureSelector', changedProps);
        checkPrimitiveDiff(oldProps.intensity, newProps.intensity, 'intensity', changedProps);
        checkMethodDiff(oldProps.addExcludedMesh, newProps.addExcludedMesh, 'addExcludedMesh', changedProps);
        checkMethodDiff(oldProps.addIncludedOnlyMesh, newProps.addIncludedOnlyMesh, 'addIncludedOnlyMesh', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGlowLayerPropsHandler;
}());
/**
 * The glow layer Helps adding a glow effect around the emissive parts of a mesh.
 *
 * Once instantiated in a scene, by default, all the emissive meshes will glow.
 *
 * Documentation: https://doc.babylonjs.com/how_to/glow_layer
 *
 * This code has been generated
 */
var FiberGlowLayer = /** @class */ (function () {
    function FiberGlowLayer() {
        this.propsHandlers = [new FiberGlowLayerPropsHandler(), new FiberEffectLayerPropsHandler()];
    }
    FiberGlowLayer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGlowLayer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGlowLayer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GlowLayer',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'options',
                type: 'Partial<BabylonjsCoreIGlowLayerOptions>',
                optional: true,
            },
        ],
    };
    FiberGlowLayer.Metadata = {
        isEffectLayer: true,
        isGlowLayer: true,
        className: 'FiberGlowLayer',
    };
    return FiberGlowLayer;
}());
var FiberHighlightLayerPropsHandler = /** @class */ (function () {
    function FiberHighlightLayerPropsHandler() {
    }
    FiberHighlightLayerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.blurHorizontalSize, newProps.blurHorizontalSize, 'blurHorizontalSize', changedProps);
        checkPrimitiveDiff(oldProps.blurVerticalSize, newProps.blurVerticalSize, 'blurVerticalSize', changedProps);
        checkPrimitiveDiff(oldProps.innerGlow, newProps.innerGlow, 'innerGlow', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkObservableDiff(oldProps.onAfterBlurObservable, newProps.onAfterBlurObservable, 'onAfterBlurObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeBlurObservable, newProps.onBeforeBlurObservable, 'onBeforeBlurObservable', changedProps);
        checkPrimitiveDiff(oldProps.outerGlow, newProps.outerGlow, 'outerGlow', changedProps);
        checkMethodDiff(oldProps.addExcludedMesh, newProps.addExcludedMesh, 'addExcludedMesh', changedProps);
        checkMethodDiff(oldProps.addMesh, newProps.addMesh, 'addMesh', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHighlightLayerPropsHandler;
}());
/**
 * The highlight layer Helps adding a glow effect around a mesh.
 *
 * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove
 * glowy meshes to your scene.
 *
 * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
 *
 * This code has been generated
 */
var FiberHighlightLayer = /** @class */ (function () {
    function FiberHighlightLayer() {
        this.propsHandlers = [new FiberHighlightLayerPropsHandler(), new FiberEffectLayerPropsHandler()];
    }
    FiberHighlightLayer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHighlightLayer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHighlightLayer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HighlightLayer',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'options',
                type: 'Partial<BabylonjsCoreIHighlightLayerOptions>',
                optional: true,
            },
        ],
    };
    FiberHighlightLayer.Metadata = {
        isEffectLayer: true,
        isGlowLayer: false,
        className: 'FiberHighlightLayer',
    };
    return FiberHighlightLayer;
}());
var FiberThinTexturePropsHandler = /** @class */ (function () {
    function FiberThinTexturePropsHandler() {
    }
    FiberThinTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.anisotropicFilteringLevel, newProps.anisotropicFilteringLevel, 'anisotropicFilteringLevel', changedProps);
        checkPrimitiveDiff(oldProps.delayLoadState, newProps.delayLoadState, 'delayLoadState', changedProps);
        checkPrimitiveDiff(oldProps.is2DArray, newProps.is2DArray, 'is2DArray', changedProps);
        checkPrimitiveDiff(oldProps.is3D, newProps.is3D, 'is3D', changedProps);
        checkPrimitiveDiff(oldProps.isCube, newProps.isCube, 'isCube', changedProps);
        checkPrimitiveDiff(oldProps.wrapR, newProps.wrapR, 'wrapR', changedProps);
        checkPrimitiveDiff(oldProps.wrapU, newProps.wrapU, 'wrapU', changedProps);
        checkPrimitiveDiff(oldProps.wrapV, newProps.wrapV, 'wrapV', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberThinTexturePropsHandler;
}());
/**
 * Base class of all the textures in babylon.
 * It groups all the common properties required to work with Thin Engine.
 *
 * This code has been generated
 */
var FiberThinTexture = /** @class */ (function () {
    function FiberThinTexture() {
        this.propsHandlers = [new FiberThinTexturePropsHandler()];
    }
    FiberThinTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberThinTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberThinTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ThinTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'internalTexture',
                type: 'BabylonjsCoreInternalTexture',
                optional: false,
            },
        ],
    };
    FiberThinTexture.Metadata = {
        isTexture: true,
        className: 'FiberThinTexture',
    };
    return FiberThinTexture;
}());
var FiberBaseTexturePropsHandler = /** @class */ (function () {
    function FiberBaseTexturePropsHandler() {
    }
    FiberBaseTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAnimation[]' property (not coded) BabylonjsCoreBaseTexture.animations.
        checkPrimitiveDiff(oldProps.anisotropicFilteringLevel, newProps.anisotropicFilteringLevel, 'anisotropicFilteringLevel', changedProps);
        checkPrimitiveDiff(oldProps.coordinatesIndex, newProps.coordinatesIndex, 'coordinatesIndex', changedProps);
        checkPrimitiveDiff(oldProps.coordinatesMode, newProps.coordinatesMode, 'coordinatesMode', changedProps);
        checkPrimitiveDiff(oldProps.gammaSpace, newProps.gammaSpace, 'gammaSpace', changedProps);
        checkPrimitiveDiff(oldProps.getAlphaFromRGB, newProps.getAlphaFromRGB, 'getAlphaFromRGB', changedProps);
        checkPrimitiveDiff(oldProps.hasAlpha, newProps.hasAlpha, 'hasAlpha', changedProps);
        checkPrimitiveDiff(oldProps.invertZ, newProps.invertZ, 'invertZ', changedProps);
        checkTextureDiff(oldProps.irradianceTexture, newProps.irradianceTexture, 'irradianceTexture', changedProps);
        checkPrimitiveDiff(oldProps.is2DArray, newProps.is2DArray, 'is2DArray', changedProps);
        checkPrimitiveDiff(oldProps.is3D, newProps.is3D, 'is3D', changedProps);
        checkPrimitiveDiff(oldProps.isCube, newProps.isCube, 'isCube', changedProps);
        checkPrimitiveDiff(oldProps.isRenderTarget, newProps.isRenderTarget, 'isRenderTarget', changedProps);
        checkPrimitiveDiff(oldProps.isRGBD, newProps.isRGBD, 'isRGBD', changedProps);
        checkPrimitiveDiff(oldProps.level, newProps.level, 'level', changedProps);
        checkPrimitiveDiff(oldProps.linearSpecularLOD, newProps.linearSpecularLOD, 'linearSpecularLOD', changedProps);
        checkPrimitiveDiff(oldProps.lodGenerationOffset, newProps.lodGenerationOffset, 'lodGenerationOffset', changedProps);
        checkPrimitiveDiff(oldProps.lodGenerationScale, newProps.lodGenerationScale, 'lodGenerationScale', changedProps);
        checkPrimitiveDiff(oldProps.lodLevelInAlpha, newProps.lodLevelInAlpha, 'lodLevelInAlpha', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreBaseTexture.metadata.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkLambdaDiff(oldProps.onDispose, newProps.onDispose, 'onDispose', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreBaseTexture.reservedDataStore.
        checkPrimitiveDiff(oldProps.uniqueId, newProps.uniqueId, 'uniqueId', changedProps);
        checkPrimitiveDiff(oldProps.wrapR, newProps.wrapR, 'wrapR', changedProps);
        checkPrimitiveDiff(oldProps.wrapU, newProps.wrapU, 'wrapU', changedProps);
        checkPrimitiveDiff(oldProps.wrapV, newProps.wrapV, 'wrapV', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBaseTexturePropsHandler;
}());
/**
 * Base class of all the textures in babylon.
 * It groups all the common properties the materials, post process, lights... might need
 * in order to make a correct use of the texture.
 *
 * This code has been generated
 */
var FiberBaseTexture = /** @class */ (function () {
    function FiberBaseTexture() {
        this.propsHandlers = [new FiberBaseTexturePropsHandler(), new FiberThinTexturePropsHandler()];
    }
    FiberBaseTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBaseTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBaseTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BaseTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'sceneOrEngine',
                type: 'BabylonjsCoreScene | BabylonjsCoreThinEngine',
                optional: true,
            },
        ],
    };
    FiberBaseTexture.Metadata = {
        isTexture: true,
        className: 'FiberBaseTexture',
    };
    return FiberBaseTexture;
}());
var FiberCubeTexturePropsHandler = /** @class */ (function () {
    function FiberCubeTexturePropsHandler() {
    }
    FiberCubeTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.boundingBoxPosition, newProps.boundingBoxPosition, 'boundingBoxPosition', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-x'], newProps['boundingBoxPosition-x'], 'boundingBoxPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-y'], newProps['boundingBoxPosition-y'], 'boundingBoxPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-z'], newProps['boundingBoxPosition-z'], 'boundingBoxPosition.z', changedProps);
        checkVector3Diff(oldProps.boundingBoxSize, newProps.boundingBoxSize, 'boundingBoxSize', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-x'], newProps['boundingBoxSize-x'], 'boundingBoxSize.x', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-y'], newProps['boundingBoxSize-y'], 'boundingBoxSize.y', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-z'], newProps['boundingBoxSize-z'], 'boundingBoxSize.z', changedProps);
        checkObservableDiff(oldProps.onLoadObservable, newProps.onLoadObservable, 'onLoadObservable', changedProps);
        checkPrimitiveDiff(oldProps.rotationY, newProps.rotationY, 'rotationY', changedProps);
        checkPrimitiveDiff(oldProps.url, newProps.url, 'url', changedProps);
        checkMethodDiff(oldProps.setReflectionTextureMatrix, newProps.setReflectionTextureMatrix, 'setReflectionTextureMatrix', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCubeTexturePropsHandler;
}());
/**
 * Class for creating a cube texture
 *
 * This code has been generated
 */
var FiberCubeTexture = /** @class */ (function () {
    function FiberCubeTexture() {
        this.propsHandlers = [
            new FiberCubeTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberCubeTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCubeTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCubeTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'CubeTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'rootUrl',
                type: 'string',
                optional: false,
            },
            {
                name: 'sceneOrEngine',
                type: 'BabylonjsCoreScene | BabylonjsCoreThinEngine',
                optional: false,
            },
            {
                name: 'extensions',
                type: 'string[]',
                optional: true,
            },
            {
                name: 'noMipmap',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'files',
                type: 'string[]',
                optional: true,
            },
            {
                name: 'onLoad',
                type: '() => void',
                optional: true,
            },
            {
                name: 'onError',
                type: '(message?: string, exception?: any) => void',
                optional: true,
            },
            {
                name: 'format',
                type: 'number',
                optional: true,
            },
            {
                name: 'prefiltered',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'forcedExtension',
                type: 'any',
                optional: true,
            },
            {
                name: 'createPolynomials',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'lodScale',
                type: 'number',
                optional: true,
            },
            {
                name: 'lodOffset',
                type: 'number',
                optional: true,
            },
            {
                name: 'loaderOptions',
                type: 'any',
                optional: true,
            },
            {
                name: 'useSRGBBuffer',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberCubeTexture.Metadata = {
        isTexture: true,
        className: 'FiberCubeTexture',
    };
    return FiberCubeTexture;
}());
var FiberRawCubeTexturePropsHandler = /** @class */ (function () {
    function FiberRawCubeTexturePropsHandler() {
    }
    FiberRawCubeTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberRawCubeTexturePropsHandler;
}());
/**
 * Raw cube texture where the raw buffers are passed in
 *
 * This code has been generated
 */
var FiberRawCubeTexture = /** @class */ (function () {
    function FiberRawCubeTexture() {
        this.propsHandlers = [
            new FiberRawCubeTexturePropsHandler(),
            new FiberCubeTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberRawCubeTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRawCubeTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRawCubeTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RawCubeTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'data',
                type: 'ArrayBufferView[]',
                optional: false,
            },
            {
                name: 'size',
                type: 'number',
                optional: false,
            },
            {
                name: 'format',
                type: 'number',
                optional: true,
            },
            {
                name: 'type',
                type: 'number',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'compression',
                type: 'string',
                optional: true,
            },
        ],
    };
    FiberRawCubeTexture.Metadata = {
        isTexture: true,
        className: 'FiberRawCubeTexture',
    };
    return FiberRawCubeTexture;
}());
var FiberTexturePropsHandler = /** @class */ (function () {
    function FiberTexturePropsHandler() {
    }
    FiberTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.homogeneousRotationInUVTransform, newProps.homogeneousRotationInUVTransform, 'homogeneousRotationInUVTransform', changedProps);
        // type: 'BabylonjsCoreIInspectable[]' property (not coded) BabylonjsCoreTexture.inspectableCustomProperties.
        checkPrimitiveDiff(oldProps.isBlocking, newProps.isBlocking, 'isBlocking', changedProps);
        checkObservableDiff(oldProps.onLoadObservable, newProps.onLoadObservable, 'onLoadObservable', changedProps);
        checkPrimitiveDiff(oldProps.uAng, newProps.uAng, 'uAng', changedProps);
        checkPrimitiveDiff(oldProps.uOffset, newProps.uOffset, 'uOffset', changedProps);
        checkPrimitiveDiff(oldProps.url, newProps.url, 'url', changedProps);
        checkPrimitiveDiff(oldProps.uRotationCenter, newProps.uRotationCenter, 'uRotationCenter', changedProps);
        checkPrimitiveDiff(oldProps.uScale, newProps.uScale, 'uScale', changedProps);
        checkPrimitiveDiff(oldProps.vAng, newProps.vAng, 'vAng', changedProps);
        checkPrimitiveDiff(oldProps.vOffset, newProps.vOffset, 'vOffset', changedProps);
        checkPrimitiveDiff(oldProps.vRotationCenter, newProps.vRotationCenter, 'vRotationCenter', changedProps);
        checkPrimitiveDiff(oldProps.vScale, newProps.vScale, 'vScale', changedProps);
        checkPrimitiveDiff(oldProps.wAng, newProps.wAng, 'wAng', changedProps);
        checkPrimitiveDiff(oldProps.wRotationCenter, newProps.wRotationCenter, 'wRotationCenter', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTexturePropsHandler;
}());
/**
 * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
 *
 * This code has been generated
 */
var FiberTexture = /** @class */ (function () {
    function FiberTexture() {
        this.propsHandlers = [
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Texture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'url',
                type: 'string',
                optional: false,
            },
            {
                name: 'sceneOrEngine',
                type: 'BabylonjsCoreScene | BabylonjsCoreThinEngine',
                optional: true,
            },
            {
                name: 'noMipmapOrOptions',
                type: 'boolean | BabylonjsCoreITextureCreationOptions',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'onLoad',
                type: '() => void',
                optional: true,
            },
            {
                name: 'onError',
                type: '(message?: string, exception?: any) => void',
                optional: true,
            },
            {
                name: 'buffer',
                type: 'string | ArrayBufferView | ArrayBuffer | HTMLImageElement | Blob | ImageBitmap',
                optional: true,
            },
            {
                name: 'deleteBuffer',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'format',
                type: 'number',
                optional: true,
            },
            {
                name: 'mimeType',
                type: 'string',
                optional: true,
            },
            {
                name: 'loaderOptions',
                type: 'any',
                optional: true,
            },
            {
                name: 'creationFlags',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberTexture.Metadata = {
        isTexture: true,
        className: 'FiberTexture',
    };
    return FiberTexture;
}());
var FiberProceduralTexturePropsHandler = /** @class */ (function () {
    function FiberProceduralTexturePropsHandler() {
    }
    FiberProceduralTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.autoClear, newProps.autoClear, 'autoClear', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        // type: 'BabylonjsCoreNodeMaterial' property (not coded) BabylonjsCoreProceduralTexture.nodeMaterialSource.
        checkObservableDiff(oldProps.onBeforeGenerationObservable, newProps.onBeforeGenerationObservable, 'onBeforeGenerationObservable', changedProps);
        checkLambdaDiff(oldProps.onGenerated, newProps.onGenerated, 'onGenerated', changedProps);
        checkObservableDiff(oldProps.onGeneratedObservable, newProps.onGeneratedObservable, 'onGeneratedObservable', changedProps);
        checkPrimitiveDiff(oldProps.refreshRate, newProps.refreshRate, 'refreshRate', changedProps);
        checkMethodDiff(oldProps.setColor3, newProps.setColor3, 'setColor3', changedProps);
        checkMethodDiff(oldProps.setColor4, newProps.setColor4, 'setColor4', changedProps);
        checkMethodDiff(oldProps.setFloat, newProps.setFloat, 'setFloat', changedProps);
        checkMethodDiff(oldProps.setFloats, newProps.setFloats, 'setFloats', changedProps);
        checkMethodDiff(oldProps.setFragment, newProps.setFragment, 'setFragment', changedProps);
        checkMethodDiff(oldProps.setInt, newProps.setInt, 'setInt', changedProps);
        checkMethodDiff(oldProps.setMatrix, newProps.setMatrix, 'setMatrix', changedProps);
        checkMethodDiff(oldProps.setTexture, newProps.setTexture, 'setTexture', changedProps);
        checkMethodDiff(oldProps.setVector2, newProps.setVector2, 'setVector2', changedProps);
        checkMethodDiff(oldProps.setVector3, newProps.setVector3, 'setVector3', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberProceduralTexturePropsHandler;
}());
/**
 * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.
 * This is the base class of any Procedural texture and contains most of the shareable code.
 *
 * This code has been generated
 */
var FiberProceduralTexture = /** @class */ (function () {
    function FiberProceduralTexture() {
        this.propsHandlers = [
            new FiberProceduralTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberProceduralTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberProceduralTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberProceduralTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ProceduralTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'BabylonjsCoreTextureSize',
                optional: false,
            },
            {
                name: 'fragment',
                type: 'any',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'fallbackTexture',
                type: 'BabylonjsCoreTexture',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'isCube',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberProceduralTexture.Metadata = {
        isTexture: true,
        className: 'FiberProceduralTexture',
    };
    return FiberProceduralTexture;
}());
var FiberCustomProceduralTexturePropsHandler = /** @class */ (function () {
    function FiberCustomProceduralTexturePropsHandler() {
    }
    FiberCustomProceduralTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.animate, newProps.animate, 'animate', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCustomProceduralTexturePropsHandler;
}());
/**
 * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
 * Custom Procedural textures are the easiest way to create your own procedural in your application.
 *
 * This code has been generated
 */
var FiberCustomProceduralTexture = /** @class */ (function () {
    function FiberCustomProceduralTexture() {
        this.propsHandlers = [
            new FiberCustomProceduralTexturePropsHandler(),
            new FiberProceduralTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberCustomProceduralTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCustomProceduralTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCustomProceduralTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'CustomProceduralTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'texturePath',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'fallbackTexture',
                type: 'BabylonjsCoreTexture',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberCustomProceduralTexture.Metadata = {
        isTexture: true,
        className: 'FiberCustomProceduralTexture',
    };
    return FiberCustomProceduralTexture;
}());
var FiberNoiseProceduralTexturePropsHandler = /** @class */ (function () {
    function FiberNoiseProceduralTexturePropsHandler() {
    }
    FiberNoiseProceduralTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.animationSpeedFactor, newProps.animationSpeedFactor, 'animationSpeedFactor', changedProps);
        checkPrimitiveDiff(oldProps.brightness, newProps.brightness, 'brightness', changedProps);
        checkPrimitiveDiff(oldProps.octaves, newProps.octaves, 'octaves', changedProps);
        checkPrimitiveDiff(oldProps.persistence, newProps.persistence, 'persistence', changedProps);
        checkPrimitiveDiff(oldProps.time, newProps.time, 'time', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberNoiseProceduralTexturePropsHandler;
}());
/**
 * Class used to generate noise procedural textures
 *
 * This code has been generated
 */
var FiberNoiseProceduralTexture = /** @class */ (function () {
    function FiberNoiseProceduralTexture() {
        this.propsHandlers = [
            new FiberNoiseProceduralTexturePropsHandler(),
            new FiberProceduralTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberNoiseProceduralTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberNoiseProceduralTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberNoiseProceduralTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'NoiseProceduralTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'number',
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'fallbackTexture',
                type: 'BabylonjsCoreTexture',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberNoiseProceduralTexture.Metadata = {
        isTexture: true,
        className: 'FiberNoiseProceduralTexture',
    };
    return FiberNoiseProceduralTexture;
}());
var FiberRawTexturePropsHandler = /** @class */ (function () {
    function FiberRawTexturePropsHandler() {
    }
    FiberRawTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.format, newProps.format, 'format', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRawTexturePropsHandler;
}());
/**
 * Raw texture can help creating a texture directly from an array of data.
 * This can be super useful if you either get the data from an uncompressed source or
 * if you wish to create your texture pixel by pixel.
 *
 * This code has been generated
 */
var FiberRawTexture = /** @class */ (function () {
    function FiberRawTexture() {
        this.propsHandlers = [
            new FiberRawTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberRawTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRawTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRawTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RawTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'data',
                type: 'ArrayBufferView',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: false,
            },
            {
                name: 'height',
                type: 'number',
                optional: false,
            },
            {
                name: 'format',
                type: 'number',
                optional: false,
            },
            {
                name: 'sceneOrEngine',
                type: 'BabylonjsCoreScene | BabylonjsCoreThinEngine',
                optional: false,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'type',
                type: 'number',
                optional: true,
            },
            {
                name: 'creationFlags',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberRawTexture.Metadata = {
        isTexture: true,
        className: 'FiberRawTexture',
    };
    return FiberRawTexture;
}());
var FiberRawTexture2DArrayPropsHandler = /** @class */ (function () {
    function FiberRawTexture2DArrayPropsHandler() {
    }
    FiberRawTexture2DArrayPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.format, newProps.format, 'format', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRawTexture2DArrayPropsHandler;
}());
/**
 * Class used to store 2D array textures containing user data
 *
 * This code has been generated
 */
var FiberRawTexture2DArray = /** @class */ (function () {
    function FiberRawTexture2DArray() {
        this.propsHandlers = [
            new FiberRawTexture2DArrayPropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberRawTexture2DArray.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRawTexture2DArray.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRawTexture2DArray.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RawTexture2DArray',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'data',
                type: 'ArrayBufferView',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: false,
            },
            {
                name: 'height',
                type: 'number',
                optional: false,
            },
            {
                name: 'depth',
                type: 'number',
                optional: false,
            },
            {
                name: 'format',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberRawTexture2DArray.Metadata = {
        isTexture: true,
        className: 'FiberRawTexture2DArray',
    };
    return FiberRawTexture2DArray;
}());
var FiberRenderTargetTexturePropsHandler = /** @class */ (function () {
    function FiberRenderTargetTexturePropsHandler() {
    }
    FiberRenderTargetTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreRenderTargetTexture.activeCamera.
        checkVector3Diff(oldProps.boundingBoxPosition, newProps.boundingBoxPosition, 'boundingBoxPosition', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-x'], newProps['boundingBoxPosition-x'], 'boundingBoxPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-y'], newProps['boundingBoxPosition-y'], 'boundingBoxPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-z'], newProps['boundingBoxPosition-z'], 'boundingBoxPosition.z', changedProps);
        checkVector3Diff(oldProps.boundingBoxSize, newProps.boundingBoxSize, 'boundingBoxSize', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-x'], newProps['boundingBoxSize-x'], 'boundingBoxSize.x', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-y'], newProps['boundingBoxSize-y'], 'boundingBoxSize.y', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-z'], newProps['boundingBoxSize-z'], 'boundingBoxSize.z', changedProps);
        checkColor4Diff(oldProps.clearColor, newProps.clearColor, 'clearColor', changedProps);
        checkLambdaDiff(oldProps.customIsReadyFunction, newProps.customIsReadyFunction, 'customIsReadyFunction', changedProps);
        checkLambdaDiff(oldProps.customRenderFunction, newProps.customRenderFunction, 'customRenderFunction', changedProps);
        checkLambdaDiff(oldProps.getCustomRenderList, newProps.getCustomRenderList, 'getCustomRenderList', changedProps);
        checkPrimitiveDiff(oldProps.ignoreCameraViewport, newProps.ignoreCameraViewport, 'ignoreCameraViewport', changedProps);
        checkLambdaDiff(oldProps.onAfterRender, newProps.onAfterRender, 'onAfterRender', changedProps);
        checkObservableDiff(oldProps.onAfterRenderObservable, newProps.onAfterRenderObservable, 'onAfterRenderObservable', changedProps);
        checkLambdaDiff(oldProps.onAfterUnbind, newProps.onAfterUnbind, 'onAfterUnbind', changedProps);
        checkObservableDiff(oldProps.onAfterUnbindObservable, newProps.onAfterUnbindObservable, 'onAfterUnbindObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeBindObservable, newProps.onBeforeBindObservable, 'onBeforeBindObservable', changedProps);
        checkLambdaDiff(oldProps.onBeforeRender, newProps.onBeforeRender, 'onBeforeRender', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderObservable, newProps.onBeforeRenderObservable, 'onBeforeRenderObservable', changedProps);
        checkLambdaDiff(oldProps.onClear, newProps.onClear, 'onClear', changedProps);
        checkObservableDiff(oldProps.onClearObservable, newProps.onClearObservable, 'onClearObservable', changedProps);
        checkObservableDiff(oldProps.onResizeObservable, newProps.onResizeObservable, 'onResizeObservable', changedProps);
        checkPrimitiveDiff(oldProps.refreshRate, newProps.refreshRate, 'refreshRate', changedProps);
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreRenderTargetTexture.renderList.
        checkLambdaDiff(oldProps.renderListPredicate, newProps.renderListPredicate, 'renderListPredicate', changedProps);
        checkPrimitiveDiff(oldProps.renderParticles, newProps.renderParticles, 'renderParticles', changedProps);
        checkPrimitiveDiff(oldProps.renderPassId, newProps.renderPassId, 'renderPassId', changedProps);
        checkPrimitiveDiff(oldProps.renderSprites, newProps.renderSprites, 'renderSprites', changedProps);
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        checkPrimitiveDiff(oldProps.skipInitialClear, newProps.skipInitialClear, 'skipInitialClear', changedProps);
        checkPrimitiveDiff(oldProps.useCameraPostProcesses, newProps.useCameraPostProcesses, 'useCameraPostProcesses', changedProps);
        checkMethodDiff(oldProps.addPostProcess, newProps.addPostProcess, 'addPostProcess', changedProps);
        checkMethodDiff(oldProps.setMaterialForRendering, newProps.setMaterialForRendering, 'setMaterialForRendering', changedProps);
        checkMethodDiff(oldProps.setRenderingAutoClearDepthStencil, newProps.setRenderingAutoClearDepthStencil, 'setRenderingAutoClearDepthStencil', changedProps);
        checkMethodDiff(oldProps.setRenderingOrder, newProps.setRenderingOrder, 'setRenderingOrder', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRenderTargetTexturePropsHandler;
}());
/**
 * This Helps creating a texture that will be created from a camera in your scene.
 * It is basically a dynamic texture that could be used to create special effects for instance.
 * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
 *
 * This code has been generated
 */
var FiberRenderTargetTexture = /** @class */ (function () {
    function FiberRenderTargetTexture() {
        this.propsHandlers = [
            new FiberRenderTargetTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberRenderTargetTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRenderTargetTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRenderTargetTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RenderTargetTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'number | { width: number; height: number; layers?: number; } | { ratio: number; }',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'doNotChangeAspectRatio',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'type',
                type: 'number',
                optional: true,
            },
            {
                name: 'isCube',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'generateDepthBuffer',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'generateStencilBuffer',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'isMulti',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'format',
                type: 'number',
                optional: true,
            },
            {
                name: 'delayAllocation',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samples',
                type: 'number',
                optional: true,
            },
            {
                name: 'creationFlags',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberRenderTargetTexture.Metadata = {
        isTexture: true,
        className: 'FiberRenderTargetTexture',
    };
    return FiberRenderTargetTexture;
}());
var FiberMirrorTexturePropsHandler = /** @class */ (function () {
    function FiberMirrorTexturePropsHandler() {
    }
    FiberMirrorTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.adaptiveBlurKernel, newProps.adaptiveBlurKernel, 'adaptiveBlurKernel', changedProps);
        checkPrimitiveDiff(oldProps.blurKernel, newProps.blurKernel, 'blurKernel', changedProps);
        checkPrimitiveDiff(oldProps.blurKernelX, newProps.blurKernelX, 'blurKernelX', changedProps);
        checkPrimitiveDiff(oldProps.blurKernelY, newProps.blurKernelY, 'blurKernelY', changedProps);
        checkPrimitiveDiff(oldProps.blurRatio, newProps.blurRatio, 'blurRatio', changedProps);
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreMirrorTexture.mirrorPlane.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMirrorTexturePropsHandler;
}());
/**
 * Mirror texture can be used to simulate the view from a mirror in a scene.
 * It will dynamically be rendered every frame to adapt to the camera point of view.
 * You can then easily use it as a reflectionTexture on a flat surface.
 * In case the surface is not a plane, please consider relying on reflection probes.
 *
 * This code has been generated
 */
var FiberMirrorTexture = /** @class */ (function () {
    function FiberMirrorTexture() {
        this.propsHandlers = [
            new FiberMirrorTexturePropsHandler(),
            new FiberRenderTargetTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberMirrorTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMirrorTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMirrorTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MirrorTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'number | { width: number; height: number; } | { ratio: number; }',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'type',
                type: 'number',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'generateDepthBuffer',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberMirrorTexture.Metadata = {
        isTexture: true,
        className: 'FiberMirrorTexture',
    };
    return FiberMirrorTexture;
}());
var FiberMultiRenderTargetPropsHandler = /** @class */ (function () {
    function FiberMultiRenderTargetPropsHandler() {
    }
    FiberMultiRenderTargetPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        checkPrimitiveDiff(oldProps.wrapU, newProps.wrapU, 'wrapU', changedProps);
        checkPrimitiveDiff(oldProps.wrapV, newProps.wrapV, 'wrapV', changedProps);
        checkMethodDiff(oldProps.setInternalTexture, newProps.setInternalTexture, 'setInternalTexture', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMultiRenderTargetPropsHandler;
}());
/**
 * A multi render target, like a render target provides the ability to render to a texture.
 * Unlike the render target, it can render to several draw buffers in one draw.
 * This is specially interesting in deferred rendering or for any effects requiring more than
 * just one color from a single pass.
 *
 * This code has been generated
 */
var FiberMultiRenderTarget = /** @class */ (function () {
    function FiberMultiRenderTarget() {
        this.propsHandlers = [
            new FiberMultiRenderTargetPropsHandler(),
            new FiberRenderTargetTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberMultiRenderTarget.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMultiRenderTarget.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMultiRenderTarget.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MultiRenderTarget',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'any',
                optional: false,
            },
            {
                name: 'count',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreIMultiRenderTargetOptions',
                optional: true,
            },
            {
                name: 'textureNames',
                type: 'string[]',
                optional: true,
            },
        ],
    };
    FiberMultiRenderTarget.Metadata = {
        isTexture: true,
        className: 'FiberMultiRenderTarget',
    };
    return FiberMultiRenderTarget;
}());
var FiberPrePassRenderTargetPropsHandler = /** @class */ (function () {
    function FiberPrePassRenderTargetPropsHandler() {
    }
    FiberPrePassRenderTargetPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.enabled, newProps.enabled, 'enabled', changedProps);
        // type: 'BabylonjsCoreImageProcessingPostProcess' property (not coded) BabylonjsCorePrePassRenderTarget.imageProcessingPostProcess.
        // type: 'BabylonjsCoreRenderTargetTexture' property (not coded) BabylonjsCorePrePassRenderTarget.renderTargetTexture.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPrePassRenderTargetPropsHandler;
}());
/**
 * A multi render target designed to render the prepass.
 * Prepass is a scene component used to render information in multiple textures
 * alongside with the scene materials rendering.
 * Note : This is an internal class, and you should NOT need to instanciate this.
 * Only the `PrePassRenderer` should instanciate this class.
 * It is more likely that you need a regular `MultiRenderTarget`
 *
 * This code has been generated
 */
var FiberPrePassRenderTarget = /** @class */ (function () {
    function FiberPrePassRenderTarget() {
        this.propsHandlers = [
            new FiberPrePassRenderTargetPropsHandler(),
            new FiberMultiRenderTargetPropsHandler(),
            new FiberRenderTargetTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberPrePassRenderTarget.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPrePassRenderTarget.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPrePassRenderTarget.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PrePassRenderTarget',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'renderTargetTexture',
                type: 'BabylonjsCoreRenderTargetTexture',
                optional: false,
            },
            {
                name: 'size',
                type: 'any',
                optional: false,
            },
            {
                name: 'count',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreIMultiRenderTargetOptions',
                optional: true,
            },
        ],
    };
    FiberPrePassRenderTarget.Metadata = {
        isTexture: true,
        className: 'FiberPrePassRenderTarget',
    };
    return FiberPrePassRenderTarget;
}());
var FiberRefractionTexturePropsHandler = /** @class */ (function () {
    function FiberRefractionTexturePropsHandler() {
    }
    FiberRefractionTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.depth, newProps.depth, 'depth', changedProps);
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreRefractionTexture.refractionPlane.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRefractionTexturePropsHandler;
}());
/**
 * Creates a refraction texture used by refraction channel of the standard material.
 * It is like a mirror but to see through a material.
 *
 * This code has been generated
 */
var FiberRefractionTexture = /** @class */ (function () {
    function FiberRefractionTexture() {
        this.propsHandlers = [
            new FiberRefractionTexturePropsHandler(),
            new FiberRenderTargetTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberRefractionTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRefractionTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRefractionTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RefractionTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'size',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberRefractionTexture.Metadata = {
        isTexture: true,
        className: 'FiberRefractionTexture',
    };
    return FiberRefractionTexture;
}());
var FiberMultiviewRenderTargetPropsHandler = /** @class */ (function () {
    function FiberMultiviewRenderTargetPropsHandler() {
    }
    FiberMultiviewRenderTargetPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMultiviewRenderTargetPropsHandler;
}());
/**
 * Renders to multiple views with a single draw call
 *
 * This code has been generated
 */
var FiberMultiviewRenderTarget = /** @class */ (function () {
    function FiberMultiviewRenderTarget() {
        this.propsHandlers = [
            new FiberMultiviewRenderTargetPropsHandler(),
            new FiberRenderTargetTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberMultiviewRenderTarget.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMultiviewRenderTarget.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMultiviewRenderTarget.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MultiviewRenderTarget',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'size',
                type: 'number | { width: number; height: number; } | { ratio: number; }',
                optional: true,
            },
        ],
    };
    FiberMultiviewRenderTarget.Metadata = {
        isTexture: true,
        className: 'FiberMultiviewRenderTarget',
    };
    return FiberMultiviewRenderTarget;
}());
var FiberVideoTexturePropsHandler = /** @class */ (function () {
    function FiberVideoTexturePropsHandler() {
    }
    FiberVideoTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVideoTexturePropsHandler;
}());
/**
 * If you want to display a video in your scene, this is the special texture for that.
 * This special texture works similar to other textures, with the exception of a few parameters.
 *
 * This code has been generated
 */
var FiberVideoTexture = /** @class */ (function () {
    function FiberVideoTexture() {
        this.propsHandlers = [
            new FiberVideoTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberVideoTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVideoTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVideoTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VideoTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'src',
                type: 'string | string[] | HTMLVideoElement',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'settings',
                type: 'Partial<BabylonjsCoreVideoTextureSettings>',
                optional: true,
            },
            {
                name: 'onError',
                type: '(message?: string, exception?: any) => void',
                optional: true,
            },
        ],
    };
    FiberVideoTexture.Metadata = {
        isTexture: true,
        className: 'FiberVideoTexture',
    };
    return FiberVideoTexture;
}());
var FiberDynamicTexturePropsHandler = /** @class */ (function () {
    function FiberDynamicTexturePropsHandler() {
    }
    FiberDynamicTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberDynamicTexturePropsHandler;
}());
/**
 * A class extending Texture allowing drawing on a texture
 *
 * This code has been generated
 */
var FiberDynamicTexture = /** @class */ (function () {
    function FiberDynamicTexture() {
        this.propsHandlers = [
            new FiberDynamicTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberDynamicTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDynamicTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDynamicTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DynamicTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'any',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'format',
                type: 'number',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberDynamicTexture.Metadata = {
        isTexture: true,
        className: 'FiberDynamicTexture',
    };
    return FiberDynamicTexture;
}());
var FiberAdvancedDynamicTexturePropsHandler = /** @class */ (function () {
    function FiberAdvancedDynamicTexturePropsHandler() {
    }
    FiberAdvancedDynamicTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.applyYInversionOnUpdate, newProps.applyYInversionOnUpdate, 'applyYInversionOnUpdate', changedProps);
        checkPrimitiveDiff(oldProps.background, newProps.background, 'background', changedProps);
        checkPrimitiveDiff(oldProps.checkPointerEveryFrame, newProps.checkPointerEveryFrame, 'checkPointerEveryFrame', changedProps);
        checkPrimitiveDiff(oldProps.clipboardData, newProps.clipboardData, 'clipboardData', changedProps);
        // type: 'BabylonjsGuiIFocusableControl' property (not coded) BabylonjsGuiAdvancedDynamicTexture.focusedControl.
        checkPrimitiveDiff(oldProps.idealHeight, newProps.idealHeight, 'idealHeight', changedProps);
        checkPrimitiveDiff(oldProps.idealWidth, newProps.idealWidth, 'idealWidth', changedProps);
        checkPrimitiveDiff(oldProps.isForeground, newProps.isForeground, 'isForeground', changedProps);
        checkObservableDiff(oldProps.onBeginLayoutObservable, newProps.onBeginLayoutObservable, 'onBeginLayoutObservable', changedProps);
        checkObservableDiff(oldProps.onBeginRenderObservable, newProps.onBeginRenderObservable, 'onBeginRenderObservable', changedProps);
        checkObservableDiff(oldProps.onClipboardObservable, newProps.onClipboardObservable, 'onClipboardObservable', changedProps);
        checkObservableDiff(oldProps.onControlPickedObservable, newProps.onControlPickedObservable, 'onControlPickedObservable', changedProps);
        checkObservableDiff(oldProps.onEndLayoutObservable, newProps.onEndLayoutObservable, 'onEndLayoutObservable', changedProps);
        checkObservableDiff(oldProps.onEndRenderObservable, newProps.onEndRenderObservable, 'onEndRenderObservable', changedProps);
        checkPrimitiveDiff(oldProps.premulAlpha, newProps.premulAlpha, 'premulAlpha', changedProps);
        checkPrimitiveDiff(oldProps.renderAtIdealSize, newProps.renderAtIdealSize, 'renderAtIdealSize', changedProps);
        checkPrimitiveDiff(oldProps.renderScale, newProps.renderScale, 'renderScale', changedProps);
        checkPrimitiveDiff(oldProps.snippetId, newProps.snippetId, 'snippetId', changedProps);
        checkPrimitiveDiff(oldProps.useInvalidateRectOptimization, newProps.useInvalidateRectOptimization, 'useInvalidateRectOptimization', changedProps);
        checkPrimitiveDiff(oldProps.useSmallestIdeal, newProps.useSmallestIdeal, 'useSmallestIdeal', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberAdvancedDynamicTexturePropsHandler;
}());
/**
 * Class used to create texture to support 2D GUI elements
 *
 * This code has been generated
 */
var FiberAdvancedDynamicTexture = /** @class */ (function () {
    function FiberAdvancedDynamicTexture() {
        this.propsHandlers = [
            new FiberAdvancedDynamicTexturePropsHandler(),
            new FiberDynamicTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberAdvancedDynamicTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAdvancedDynamicTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAdvancedDynamicTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AdvancedDynamicTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: true,
            },
            {
                name: 'height',
                type: 'number',
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberAdvancedDynamicTexture.Metadata = {
        isGUI2DControl: true,
        isTexture: true,
        className: 'FiberAdvancedDynamicTexture',
    };
    return FiberAdvancedDynamicTexture;
}());
/**
 * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)
 *
 * This code has been generated
 */
var FiberADTForMesh = /** @class */ (function () {
    function FiberADTForMesh() {
        this.propsHandlers = [
            new FiberAdvancedDynamicTexturePropsHandler(),
            new FiberDynamicTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberADTForMesh.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberADTForMesh.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberADTForMesh.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'advancedDynamicTexture',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateForMesh',
        parameters: [
            {
                name: 'mesh',
                type: 'BabylonjsCoreAbstractMesh',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: true,
            },
            {
                name: 'height',
                type: 'number',
                optional: true,
            },
            {
                name: 'supportPointerMove',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'onlyAlphaTesting',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'materialSetupCallback',
                type: '(mesh: BabylonjsCoreAbstractMesh, uniqueId: string, texture: BabylonjsGuiAdvancedDynamicTexture, onlyAlphaTesting: boolean) => void',
                optional: true,
            },
        ],
    };
    FiberADTForMesh.Metadata = {
        isTexture: true,
        isGUI2DControl: true,
        className: 'FiberADTForMesh',
    };
    return FiberADTForMesh;
}());
/**
 * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture
 *
 * This code has been generated
 */
var FiberADTForMeshTexture = /** @class */ (function () {
    function FiberADTForMeshTexture() {
        this.propsHandlers = [
            new FiberAdvancedDynamicTexturePropsHandler(),
            new FiberDynamicTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberADTForMeshTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberADTForMeshTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberADTForMeshTexture.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'advancedDynamicTexture',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateForMeshTexture',
        parameters: [
            {
                name: 'mesh',
                type: 'BabylonjsCoreAbstractMesh',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: true,
            },
            {
                name: 'height',
                type: 'number',
                optional: true,
            },
            {
                name: 'supportPointerMove',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberADTForMeshTexture.Metadata = {
        isTexture: true,
        isGUI2DControl: true,
        className: 'FiberADTForMeshTexture',
    };
    return FiberADTForMeshTexture;
}());
/**
 * Creates a new AdvancedDynamicTexture in fullscreen mode.
 * In this mode the texture will rely on a layer for its rendering.
 * This allows it to be treated like any other layer.
 * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.
 * LayerMask is set through advancedTexture.layer.layerMask
 *
 * This code has been generated
 */
var FiberADTFullscreenUI = /** @class */ (function () {
    function FiberADTFullscreenUI() {
        this.propsHandlers = [
            new FiberAdvancedDynamicTexturePropsHandler(),
            new FiberDynamicTexturePropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberADTFullscreenUI.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberADTFullscreenUI.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberADTFullscreenUI.CreateInfo = {
        creationType: 'FactoryMethod',
        libraryLocation: 'advancedDynamicTexture',
        namespace: '@babylonjs/core',
        factoryMethod: 'CreateFullscreenUI',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'foreground',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'sampling',
                type: 'number',
                optional: true,
            },
            {
                name: 'adaptiveScaling',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberADTFullscreenUI.Metadata = {
        isTexture: true,
        isGUI2DControl: true,
        className: 'FiberADTFullscreenUI',
    };
    return FiberADTFullscreenUI;
}());
var FiberRawTexture3DPropsHandler = /** @class */ (function () {
    function FiberRawTexture3DPropsHandler() {
    }
    FiberRawTexture3DPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.format, newProps.format, 'format', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRawTexture3DPropsHandler;
}());
/**
 * Class used to store 3D textures containing user data
 *
 * This code has been generated
 */
var FiberRawTexture3D = /** @class */ (function () {
    function FiberRawTexture3D() {
        this.propsHandlers = [
            new FiberRawTexture3DPropsHandler(),
            new FiberTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberRawTexture3D.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRawTexture3D.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRawTexture3D.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RawTexture3D',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'data',
                type: 'ArrayBufferView',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: false,
            },
            {
                name: 'height',
                type: 'number',
                optional: false,
            },
            {
                name: 'depth',
                type: 'number',
                optional: false,
            },
            {
                name: 'format',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'generateMipMaps',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'invertY',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberRawTexture3D.Metadata = {
        isTexture: true,
        className: 'FiberRawTexture3D',
    };
    return FiberRawTexture3D;
}());
var FiberColorGradingTexturePropsHandler = /** @class */ (function () {
    function FiberColorGradingTexturePropsHandler() {
    }
    FiberColorGradingTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.url, newProps.url, 'url', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberColorGradingTexturePropsHandler;
}());
/**
 * This represents a color grading texture. This acts as a lookup table LUT, useful during post process
 * It can help converting any input color in a desired output one. This can then be used to create effects
 * from sepia, black and white to sixties or futuristic rendering...
 *
 * The only supported format is currently 3dl.
 * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table
 *
 * This code has been generated
 */
var FiberColorGradingTexture = /** @class */ (function () {
    function FiberColorGradingTexture() {
        this.propsHandlers = [
            new FiberColorGradingTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberColorGradingTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberColorGradingTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberColorGradingTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ColorGradingTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'url',
                type: 'string',
                optional: false,
            },
            {
                name: 'sceneOrEngine',
                type: 'BabylonjsCoreScene | BabylonjsCoreThinEngine',
                optional: false,
            },
            {
                name: 'onLoad',
                type: '() => void',
                optional: true,
            },
        ],
    };
    FiberColorGradingTexture.Metadata = {
        isTexture: true,
        className: 'FiberColorGradingTexture',
    };
    return FiberColorGradingTexture;
}());
var FiberEquiRectangularCubeTexturePropsHandler = /** @class */ (function () {
    function FiberEquiRectangularCubeTexturePropsHandler() {
    }
    FiberEquiRectangularCubeTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.url, newProps.url, 'url', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberEquiRectangularCubeTexturePropsHandler;
}());
/**
 * This represents a texture coming from an equirectangular image supported by the web browser canvas.
 *
 * This code has been generated
 */
var FiberEquiRectangularCubeTexture = /** @class */ (function () {
    function FiberEquiRectangularCubeTexture() {
        this.propsHandlers = [
            new FiberEquiRectangularCubeTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberEquiRectangularCubeTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberEquiRectangularCubeTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberEquiRectangularCubeTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'EquiRectangularCubeTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'url',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'size',
                type: 'number',
                optional: false,
            },
            {
                name: 'noMipmap',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'gammaSpace',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'onLoad',
                type: '() => void',
                optional: true,
            },
            {
                name: 'onError',
                type: '(message?: string, exception?: any) => void',
                optional: true,
            },
        ],
    };
    FiberEquiRectangularCubeTexture.Metadata = {
        isTexture: true,
        className: 'FiberEquiRectangularCubeTexture',
    };
    return FiberEquiRectangularCubeTexture;
}());
var FiberHDRCubeTexturePropsHandler = /** @class */ (function () {
    function FiberHDRCubeTexturePropsHandler() {
    }
    FiberHDRCubeTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.boundingBoxPosition, newProps.boundingBoxPosition, 'boundingBoxPosition', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-x'], newProps['boundingBoxPosition-x'], 'boundingBoxPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-y'], newProps['boundingBoxPosition-y'], 'boundingBoxPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxPosition-z'], newProps['boundingBoxPosition-z'], 'boundingBoxPosition.z', changedProps);
        checkVector3Diff(oldProps.boundingBoxSize, newProps.boundingBoxSize, 'boundingBoxSize', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-x'], newProps['boundingBoxSize-x'], 'boundingBoxSize.x', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-y'], newProps['boundingBoxSize-y'], 'boundingBoxSize.y', changedProps);
        checkPrimitiveDiff(oldProps['boundingBoxSize-z'], newProps['boundingBoxSize-z'], 'boundingBoxSize.z', changedProps);
        checkPrimitiveDiff(oldProps.isBlocking, newProps.isBlocking, 'isBlocking', changedProps);
        checkObservableDiff(oldProps.onLoadObservable, newProps.onLoadObservable, 'onLoadObservable', changedProps);
        checkPrimitiveDiff(oldProps.rotationY, newProps.rotationY, 'rotationY', changedProps);
        checkPrimitiveDiff(oldProps.url, newProps.url, 'url', changedProps);
        checkMethodDiff(oldProps.setReflectionTextureMatrix, newProps.setReflectionTextureMatrix, 'setReflectionTextureMatrix', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHDRCubeTexturePropsHandler;
}());
/**
 * This represents a texture coming from an HDR input.
 *
 * The only supported format is currently panorama picture stored in RGBE format.
 * Example of such files can be found on Poly Haven: https://polyhaven.com/hdris
 *
 * This code has been generated
 */
var FiberHDRCubeTexture = /** @class */ (function () {
    function FiberHDRCubeTexture() {
        this.propsHandlers = [
            new FiberHDRCubeTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberHDRCubeTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHDRCubeTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHDRCubeTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HDRCubeTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'url',
                type: 'string',
                optional: false,
            },
            {
                name: 'sceneOrEngine',
                type: 'BabylonjsCoreScene | BabylonjsCoreThinEngine',
                optional: false,
            },
            {
                name: 'size',
                type: 'number',
                optional: false,
            },
            {
                name: 'noMipmap',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'generateHarmonics',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'gammaSpace',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'prefilterOnLoad',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'onLoad',
                type: '() => void',
                optional: true,
            },
            {
                name: 'onError',
                type: '(message?: string, exception?: any) => void',
                optional: true,
            },
        ],
    };
    FiberHDRCubeTexture.Metadata = {
        isTexture: true,
        className: 'FiberHDRCubeTexture',
    };
    return FiberHDRCubeTexture;
}());
var FiberHtmlElementTexturePropsHandler = /** @class */ (function () {
    function FiberHtmlElementTexturePropsHandler() {
    }
    FiberHtmlElementTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        // skipping type: 'HTMLVideoElement | HTMLCanvasElement' property (not coded) BabylonjsCoreHtmlElementTexture.element.
        return null; // no props to check
    };
    return FiberHtmlElementTexturePropsHandler;
}());
/**
 * This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.
 * To be as efficient as possible depending on your constraints nothing aside the first upload
 * is automatically managed.
 * It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements
 * in your application.
 *
 * As the update is not automatic, you need to call them manually.
 *
 * This code has been generated
 */
var FiberHtmlElementTexture = /** @class */ (function () {
    function FiberHtmlElementTexture() {
        this.propsHandlers = [
            new FiberHtmlElementTexturePropsHandler(),
            new FiberBaseTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberHtmlElementTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHtmlElementTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHtmlElementTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HtmlElementTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'element',
                type: 'HTMLVideoElement | HTMLCanvasElement',
                optional: false,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreIHtmlElementTextureOptions',
                optional: false,
            },
        ],
    };
    FiberHtmlElementTexture.Metadata = {
        isTexture: true,
        className: 'FiberHtmlElementTexture',
    };
    return FiberHtmlElementTexture;
}());
var FiberThinRenderTargetTexturePropsHandler = /** @class */ (function () {
    function FiberThinRenderTargetTexturePropsHandler() {
    }
    FiberThinRenderTargetTexturePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberThinRenderTargetTexturePropsHandler;
}());
/**
 * This is a tiny helper class to wrap a RenderTargetWrapper in a texture
 * usable as the input of an effect.
 *
 * This code has been generated
 */
var FiberThinRenderTargetTexture = /** @class */ (function () {
    function FiberThinRenderTargetTexture() {
        this.propsHandlers = [
            new FiberThinRenderTargetTexturePropsHandler(),
            new FiberThinTexturePropsHandler(),
        ];
    }
    FiberThinRenderTargetTexture.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberThinRenderTargetTexture.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberThinRenderTargetTexture.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ThinRenderTargetTexture',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'engine',
                type: 'BabylonjsCoreThinEngine',
                optional: false,
            },
            {
                name: 'size',
                type: 'BabylonjsCoreTextureSize',
                optional: false,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreRenderTargetCreationOptions',
                optional: false,
            },
        ],
    };
    FiberThinRenderTargetTexture.Metadata = {
        isTexture: true,
        className: 'FiberThinRenderTargetTexture',
    };
    return FiberThinRenderTargetTexture;
}());
var FiberPostProcessRenderPipelinePropsHandler = /** @class */ (function () {
    function FiberPostProcessRenderPipelinePropsHandler() {
    }
    FiberPostProcessRenderPipelinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreIInspectable[]' property (not coded) BabylonjsCorePostProcessRenderPipeline.inspectableCustomProperties.
        checkMethodDiff(oldProps.addEffect, newProps.addEffect, 'addEffect', changedProps);
        checkMethodDiff(oldProps.setPrePassRenderer, newProps.setPrePassRenderer, 'setPrePassRenderer', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPostProcessRenderPipelinePropsHandler;
}());
/**
 * PostProcessRenderPipeline
 *
 * This code has been generated
 */
var FiberPostProcessRenderPipeline = /** @class */ (function () {
    function FiberPostProcessRenderPipeline() {
        this.propsHandlers = [new FiberPostProcessRenderPipelinePropsHandler()];
    }
    FiberPostProcessRenderPipeline.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPostProcessRenderPipeline.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPostProcessRenderPipeline.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PostProcessRenderPipeline',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: '_engine',
                type: 'BabylonjsCoreEngine',
                optional: false,
            },
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
        ],
    };
    FiberPostProcessRenderPipeline.Metadata = {
        className: 'FiberPostProcessRenderPipeline',
    };
    return FiberPostProcessRenderPipeline;
}());
var FiberDefaultRenderingPipelinePropsHandler = /** @class */ (function () {
    function FiberDefaultRenderingPipelinePropsHandler() {
    }
    FiberDefaultRenderingPipelinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAnimation[]' property (not coded) BabylonjsCoreDefaultRenderingPipeline.animations.
        // type: 'any' property (not coded) BabylonjsCoreDefaultRenderingPipeline.bloom.
        checkPrimitiveDiff(oldProps.bloomEnabled, newProps.bloomEnabled, 'bloomEnabled', changedProps);
        checkPrimitiveDiff(oldProps.bloomKernel, newProps.bloomKernel, 'bloomKernel', changedProps);
        checkPrimitiveDiff(oldProps.bloomScale, newProps.bloomScale, 'bloomScale', changedProps);
        checkPrimitiveDiff(oldProps.bloomThreshold, newProps.bloomThreshold, 'bloomThreshold', changedProps);
        checkPrimitiveDiff(oldProps.bloomWeight, newProps.bloomWeight, 'bloomWeight', changedProps);
        // type: 'BabylonjsCoreChromaticAberrationPostProcess' property (not coded) BabylonjsCoreDefaultRenderingPipeline.chromaticAberration.
        checkPrimitiveDiff(oldProps.chromaticAberrationEnabled, newProps.chromaticAberrationEnabled, 'chromaticAberrationEnabled', changedProps);
        // type: 'BabylonjsCoreDepthOfFieldEffect' property (not coded) BabylonjsCoreDefaultRenderingPipeline.depthOfField.
        checkPrimitiveDiff(oldProps.depthOfFieldBlurLevel, newProps.depthOfFieldBlurLevel, 'depthOfFieldBlurLevel', changedProps);
        checkPrimitiveDiff(oldProps.depthOfFieldEnabled, newProps.depthOfFieldEnabled, 'depthOfFieldEnabled', changedProps);
        // type: 'BabylonjsCoreFxaaPostProcess' property (not coded) BabylonjsCoreDefaultRenderingPipeline.fxaa.
        checkPrimitiveDiff(oldProps.fxaaEnabled, newProps.fxaaEnabled, 'fxaaEnabled', changedProps);
        checkPrimitiveDiff(oldProps.glowLayerEnabled, newProps.glowLayerEnabled, 'glowLayerEnabled', changedProps);
        // type: 'BabylonjsCoreGrainPostProcess' property (not coded) BabylonjsCoreDefaultRenderingPipeline.grain.
        checkPrimitiveDiff(oldProps.grainEnabled, newProps.grainEnabled, 'grainEnabled', changedProps);
        // type: 'BabylonjsCoreImageProcessingPostProcess' property (not coded) BabylonjsCoreDefaultRenderingPipeline.imageProcessing.
        checkPrimitiveDiff(oldProps.imageProcessingEnabled, newProps.imageProcessingEnabled, 'imageProcessingEnabled', changedProps);
        checkObservableDiff(oldProps.onBuildObservable, newProps.onBuildObservable, 'onBuildObservable', changedProps);
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        // type: 'BabylonjsCoreSharpenPostProcess' property (not coded) BabylonjsCoreDefaultRenderingPipeline.sharpen.
        checkPrimitiveDiff(oldProps.sharpenEnabled, newProps.sharpenEnabled, 'sharpenEnabled', changedProps);
        checkMethodDiff(oldProps.addCamera, newProps.addCamera, 'addCamera', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDefaultRenderingPipelinePropsHandler;
}());
/**
 * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
 * See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
 *
 * This code has been generated
 */
var FiberDefaultRenderingPipeline = /** @class */ (function () {
    function FiberDefaultRenderingPipeline() {
        this.propsHandlers = [
            new FiberDefaultRenderingPipelinePropsHandler(),
            new FiberPostProcessRenderPipelinePropsHandler(),
        ];
    }
    FiberDefaultRenderingPipeline.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDefaultRenderingPipeline.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDefaultRenderingPipeline.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DefaultRenderingPipeline',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: true,
            },
            {
                name: 'hdr',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
            {
                name: 'cameras',
                type: 'BabylonjsCoreCamera[]',
                optional: true,
            },
            {
                name: 'automaticBuild',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberDefaultRenderingPipeline.Metadata = {
        className: 'FiberDefaultRenderingPipeline',
    };
    return FiberDefaultRenderingPipeline;
}());
var FiberLensRenderingPipelinePropsHandler = /** @class */ (function () {
    function FiberLensRenderingPipelinePropsHandler() {
    }
    FiberLensRenderingPipelinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.blurNoise, newProps.blurNoise, 'blurNoise', changedProps);
        checkPrimitiveDiff(oldProps.chromaticAberration, newProps.chromaticAberration, 'chromaticAberration', changedProps);
        checkPrimitiveDiff(oldProps.darkenOutOfFocus, newProps.darkenOutOfFocus, 'darkenOutOfFocus', changedProps);
        checkPrimitiveDiff(oldProps.dofAperture, newProps.dofAperture, 'dofAperture', changedProps);
        checkPrimitiveDiff(oldProps.dofDistortion, newProps.dofDistortion, 'dofDistortion', changedProps);
        checkPrimitiveDiff(oldProps.edgeBlur, newProps.edgeBlur, 'edgeBlur', changedProps);
        checkPrimitiveDiff(oldProps.edgeDistortion, newProps.edgeDistortion, 'edgeDistortion', changedProps);
        checkPrimitiveDiff(oldProps.grainAmount, newProps.grainAmount, 'grainAmount', changedProps);
        checkPrimitiveDiff(oldProps.HighlightsEnhancingEffect, newProps.HighlightsEnhancingEffect, 'HighlightsEnhancingEffect', changedProps);
        checkPrimitiveDiff(oldProps.highlightsGain, newProps.highlightsGain, 'highlightsGain', changedProps);
        checkPrimitiveDiff(oldProps.highlightsThreshold, newProps.highlightsThreshold, 'highlightsThreshold', changedProps);
        checkPrimitiveDiff(oldProps.LensChromaticAberrationEffect, newProps.LensChromaticAberrationEffect, 'LensChromaticAberrationEffect', changedProps);
        checkPrimitiveDiff(oldProps.LensDepthOfFieldEffect, newProps.LensDepthOfFieldEffect, 'LensDepthOfFieldEffect', changedProps);
        checkPrimitiveDiff(oldProps.pentagonBokeh, newProps.pentagonBokeh, 'pentagonBokeh', changedProps);
        checkMethodDiff(oldProps.setAperture, newProps.setAperture, 'setAperture', changedProps);
        checkMethodDiff(oldProps.setChromaticAberration, newProps.setChromaticAberration, 'setChromaticAberration', changedProps);
        checkMethodDiff(oldProps.setDarkenOutOfFocus, newProps.setDarkenOutOfFocus, 'setDarkenOutOfFocus', changedProps);
        checkMethodDiff(oldProps.setEdgeBlur, newProps.setEdgeBlur, 'setEdgeBlur', changedProps);
        checkMethodDiff(oldProps.setEdgeDistortion, newProps.setEdgeDistortion, 'setEdgeDistortion', changedProps);
        checkMethodDiff(oldProps.setFocusDistance, newProps.setFocusDistance, 'setFocusDistance', changedProps);
        checkMethodDiff(oldProps.setGrainAmount, newProps.setGrainAmount, 'setGrainAmount', changedProps);
        checkMethodDiff(oldProps.setHighlightsGain, newProps.setHighlightsGain, 'setHighlightsGain', changedProps);
        checkMethodDiff(oldProps.setHighlightsThreshold, newProps.setHighlightsThreshold, 'setHighlightsThreshold', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberLensRenderingPipelinePropsHandler;
}());
/**
 * BABYLON.JS Chromatic Aberration GLSL Shader
 * Author: Olivier Guyot
 * Separates very slightly R, G and B colors on the edges of the screen
 * Inspired by Francois Tarlier & Martins Upitis
 *
 * This code has been generated
 */
var FiberLensRenderingPipeline = /** @class */ (function () {
    function FiberLensRenderingPipeline() {
        this.propsHandlers = [
            new FiberLensRenderingPipelinePropsHandler(),
            new FiberPostProcessRenderPipelinePropsHandler(),
        ];
    }
    FiberLensRenderingPipeline.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLensRenderingPipeline.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLensRenderingPipeline.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'LensRenderingPipeline',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'parameters',
                type: 'any',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'ratio',
                type: 'number',
                optional: true,
            },
            {
                name: 'cameras',
                type: 'BabylonjsCoreCamera[]',
                optional: true,
            },
        ],
    };
    FiberLensRenderingPipeline.Metadata = {
        className: 'FiberLensRenderingPipeline',
    };
    return FiberLensRenderingPipeline;
}());
var FiberSSAO2RenderingPipelinePropsHandler = /** @class */ (function () {
    function FiberSSAO2RenderingPipelinePropsHandler() {
    }
    FiberSSAO2RenderingPipelinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.base, newProps.base, 'base', changedProps);
        checkPrimitiveDiff(oldProps.expensiveBlur, newProps.expensiveBlur, 'expensiveBlur', changedProps);
        checkPrimitiveDiff(oldProps.maxZ, newProps.maxZ, 'maxZ', changedProps);
        checkPrimitiveDiff(oldProps.minZAspect, newProps.minZAspect, 'minZAspect', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        checkPrimitiveDiff(oldProps.SSAOBlurHRenderEffect, newProps.SSAOBlurHRenderEffect, 'SSAOBlurHRenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAOBlurVRenderEffect, newProps.SSAOBlurVRenderEffect, 'SSAOBlurVRenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAOCombineRenderEffect, newProps.SSAOCombineRenderEffect, 'SSAOCombineRenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAOOriginalSceneColorEffect, newProps.SSAOOriginalSceneColorEffect, 'SSAOOriginalSceneColorEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAORenderEffect, newProps.SSAORenderEffect, 'SSAORenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.textureSamples, newProps.textureSamples, 'textureSamples', changedProps);
        checkPrimitiveDiff(oldProps.totalStrength, newProps.totalStrength, 'totalStrength', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSSAO2RenderingPipelinePropsHandler;
}());
/**
 * Render pipeline to produce ssao effect
 *
 * This code has been generated
 */
var FiberSSAO2RenderingPipeline = /** @class */ (function () {
    function FiberSSAO2RenderingPipeline() {
        this.propsHandlers = [
            new FiberSSAO2RenderingPipelinePropsHandler(),
            new FiberPostProcessRenderPipelinePropsHandler(),
        ];
    }
    FiberSSAO2RenderingPipeline.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSSAO2RenderingPipeline.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSSAO2RenderingPipeline.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SSAO2RenderingPipeline',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'ratio',
                type: 'any',
                optional: false,
            },
            {
                name: 'cameras',
                type: 'BabylonjsCoreCamera[]',
                optional: true,
            },
            {
                name: 'forceGeometryBuffer',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberSSAO2RenderingPipeline.Metadata = {
        className: 'FiberSSAO2RenderingPipeline',
    };
    return FiberSSAO2RenderingPipeline;
}());
var FiberSSAORenderingPipelinePropsHandler = /** @class */ (function () {
    function FiberSSAORenderingPipelinePropsHandler() {
    }
    FiberSSAORenderingPipelinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.area, newProps.area, 'area', changedProps);
        checkPrimitiveDiff(oldProps.base, newProps.base, 'base', changedProps);
        checkPrimitiveDiff(oldProps.fallOff, newProps.fallOff, 'fallOff', changedProps);
        checkPrimitiveDiff(oldProps.radius, newProps.radius, 'radius', changedProps);
        checkPrimitiveDiff(oldProps.SSAOBlurHRenderEffect, newProps.SSAOBlurHRenderEffect, 'SSAOBlurHRenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAOBlurVRenderEffect, newProps.SSAOBlurVRenderEffect, 'SSAOBlurVRenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAOCombineRenderEffect, newProps.SSAOCombineRenderEffect, 'SSAOCombineRenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAOOriginalSceneColorEffect, newProps.SSAOOriginalSceneColorEffect, 'SSAOOriginalSceneColorEffect', changedProps);
        checkPrimitiveDiff(oldProps.SSAORenderEffect, newProps.SSAORenderEffect, 'SSAORenderEffect', changedProps);
        checkPrimitiveDiff(oldProps.totalStrength, newProps.totalStrength, 'totalStrength', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSSAORenderingPipelinePropsHandler;
}());
/**
 * Render pipeline to produce ssao effect
 *
 * This code has been generated
 */
var FiberSSAORenderingPipeline = /** @class */ (function () {
    function FiberSSAORenderingPipeline() {
        this.propsHandlers = [
            new FiberSSAORenderingPipelinePropsHandler(),
            new FiberPostProcessRenderPipelinePropsHandler(),
        ];
    }
    FiberSSAORenderingPipeline.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSSAORenderingPipeline.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSSAORenderingPipeline.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SSAORenderingPipeline',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'ratio',
                type: 'any',
                optional: false,
            },
            {
                name: 'cameras',
                type: 'BabylonjsCoreCamera[]',
                optional: true,
            },
        ],
    };
    FiberSSAORenderingPipeline.Metadata = {
        className: 'FiberSSAORenderingPipeline',
    };
    return FiberSSAORenderingPipeline;
}());
var FiberStandardRenderingPipelinePropsHandler = /** @class */ (function () {
    function FiberStandardRenderingPipelinePropsHandler() {
    }
    FiberStandardRenderingPipelinePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAnimation[]' property (not coded) BabylonjsCoreStandardRenderingPipeline.animations.
        checkPrimitiveDiff(oldProps.BloomEnabled, newProps.BloomEnabled, 'BloomEnabled', changedProps);
        // type: 'BabylonjsCorePostProcess[]' property (not coded) BabylonjsCoreStandardRenderingPipeline.blurHPostProcesses.
        // type: 'BabylonjsCorePostProcess[]' property (not coded) BabylonjsCoreStandardRenderingPipeline.blurVPostProcesses.
        checkPrimitiveDiff(oldProps.blurWidth, newProps.blurWidth, 'blurWidth', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.brightPassPostProcess.
        checkPrimitiveDiff(oldProps.brightThreshold, newProps.brightThreshold, 'brightThreshold', changedProps);
        checkPrimitiveDiff(oldProps.depthOfFieldBlurWidth, newProps.depthOfFieldBlurWidth, 'depthOfFieldBlurWidth', changedProps);
        checkPrimitiveDiff(oldProps.depthOfFieldDistance, newProps.depthOfFieldDistance, 'depthOfFieldDistance', changedProps);
        checkPrimitiveDiff(oldProps.DepthOfFieldEnabled, newProps.DepthOfFieldEnabled, 'DepthOfFieldEnabled', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.depthOfFieldPostProcess.
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.downSampleX4PostProcess.
        checkPrimitiveDiff(oldProps.exposure, newProps.exposure, 'exposure', changedProps);
        checkPrimitiveDiff(oldProps.fxaaEnabled, newProps.fxaaEnabled, 'fxaaEnabled', changedProps);
        // type: 'BabylonjsCoreFxaaPostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.fxaaPostProcess.
        checkPrimitiveDiff(oldProps.hdrAutoExposure, newProps.hdrAutoExposure, 'hdrAutoExposure', changedProps);
        checkPrimitiveDiff(oldProps.hdrDecreaseRate, newProps.hdrDecreaseRate, 'hdrDecreaseRate', changedProps);
        checkPrimitiveDiff(oldProps.HDREnabled, newProps.HDREnabled, 'HDREnabled', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.hdrFinalPostProcess.
        checkPrimitiveDiff(oldProps.hdrIncreaseRate, newProps.hdrIncreaseRate, 'hdrIncreaseRate', changedProps);
        checkPrimitiveDiff(oldProps.hdrMinimumLuminance, newProps.hdrMinimumLuminance, 'hdrMinimumLuminance', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.hdrPostProcess.
        checkPrimitiveDiff(oldProps.horizontalBlur, newProps.horizontalBlur, 'horizontalBlur', changedProps);
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensColorTexture.
        checkPrimitiveDiff(oldProps.lensFlareBlurWidth, newProps.lensFlareBlurWidth, 'lensFlareBlurWidth', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensFlareComposePostProcess.
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensFlareDirtTexture.
        checkPrimitiveDiff(oldProps.lensFlareDistortionStrength, newProps.lensFlareDistortionStrength, 'lensFlareDistortionStrength', changedProps);
        checkPrimitiveDiff(oldProps.LensFlareEnabled, newProps.LensFlareEnabled, 'LensFlareEnabled', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensFlareFinalPostProcess.
        checkPrimitiveDiff(oldProps.lensFlareGhostDispersal, newProps.lensFlareGhostDispersal, 'lensFlareGhostDispersal', changedProps);
        checkPrimitiveDiff(oldProps.lensFlareHaloWidth, newProps.lensFlareHaloWidth, 'lensFlareHaloWidth', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensFlarePostProcess.
        checkPrimitiveDiff(oldProps.lensFlareStrength, newProps.lensFlareStrength, 'lensFlareStrength', changedProps);
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensStarTexture.
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsCoreStandardRenderingPipeline.lensTexture.
        // type: 'BabylonjsCorePostProcess[]' property (not coded) BabylonjsCoreStandardRenderingPipeline.luminanceDownSamplePostProcesses.
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.luminancePostProcess.
        checkPrimitiveDiff(oldProps.MotionBlurEnabled, newProps.MotionBlurEnabled, 'MotionBlurEnabled', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.motionBlurPostProcess.
        checkPrimitiveDiff(oldProps.motionBlurSamples, newProps.motionBlurSamples, 'motionBlurSamples', changedProps);
        checkPrimitiveDiff(oldProps.motionStrength, newProps.motionStrength, 'motionStrength', changedProps);
        checkPrimitiveDiff(oldProps.objectBasedMotionBlur, newProps.objectBasedMotionBlur, 'objectBasedMotionBlur', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.originalPostProcess.
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        // type: 'BabylonjsCoreScreenSpaceReflectionPostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.screenSpaceReflectionPostProcess.
        checkPrimitiveDiff(oldProps.screenSpaceReflectionsEnabled, newProps.screenSpaceReflectionsEnabled, 'screenSpaceReflectionsEnabled', changedProps);
        // type: 'BabylonjsCoreDirectionalLight | BabylonjsCoreSpotLight' property (not coded) BabylonjsCoreStandardRenderingPipeline.sourceLight.
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.textureAdderFinalPostProcess.
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.textureAdderPostProcess.
        checkPrimitiveDiff(oldProps.VLSEnabled, newProps.VLSEnabled, 'VLSEnabled', changedProps);
        checkPrimitiveDiff(oldProps.volumetricLightBlurScale, newProps.volumetricLightBlurScale, 'volumetricLightBlurScale', changedProps);
        checkPrimitiveDiff(oldProps.volumetricLightCoefficient, newProps.volumetricLightCoefficient, 'volumetricLightCoefficient', changedProps);
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.volumetricLightFinalPostProcess.
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.volumetricLightMergePostProces.
        // type: 'BabylonjsCorePostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.volumetricLightPostProcess.
        checkPrimitiveDiff(oldProps.volumetricLightPower, newProps.volumetricLightPower, 'volumetricLightPower', changedProps);
        // type: 'BabylonjsCoreBlurPostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.volumetricLightSmoothXPostProcess.
        // type: 'BabylonjsCoreBlurPostProcess' property (not coded) BabylonjsCoreStandardRenderingPipeline.volumetricLightSmoothYPostProcess.
        checkPrimitiveDiff(oldProps.volumetricLightStepsCount, newProps.volumetricLightStepsCount, 'volumetricLightStepsCount', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberStandardRenderingPipelinePropsHandler;
}());
/**
 * Standard rendering pipeline
 * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.
 *
 * This code has been generated
 */
var FiberStandardRenderingPipeline = /** @class */ (function () {
    function FiberStandardRenderingPipeline() {
        this.propsHandlers = [
            new FiberStandardRenderingPipelinePropsHandler(),
            new FiberPostProcessRenderPipelinePropsHandler(),
        ];
    }
    FiberStandardRenderingPipeline.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStandardRenderingPipeline.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStandardRenderingPipeline.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StandardRenderingPipeline',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'ratio',
                type: 'number',
                optional: false,
            },
            {
                name: 'originalPostProcess',
                type: 'BabylonjsCorePostProcess',
                optional: true,
            },
            {
                name: 'cameras',
                type: 'BabylonjsCoreCamera[]',
                optional: true,
            },
        ],
    };
    FiberStandardRenderingPipeline.Metadata = {
        className: 'FiberStandardRenderingPipeline',
    };
    return FiberStandardRenderingPipeline;
}());
var FiberPostProcessPropsHandler = /** @class */ (function () {
    function FiberPostProcessPropsHandler() {
    }
    FiberPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.adaptScaleToCurrentViewport, newProps.adaptScaleToCurrentViewport, 'adaptScaleToCurrentViewport', changedProps);
        checkColor4Diff(oldProps.alphaConstants, newProps.alphaConstants, 'alphaConstants', changedProps);
        checkPrimitiveDiff(oldProps.alphaMode, newProps.alphaMode, 'alphaMode', changedProps);
        checkPrimitiveDiff(oldProps.alwaysForcePOT, newProps.alwaysForcePOT, 'alwaysForcePOT', changedProps);
        // type: 'BabylonjsCoreAnimation[]' property (not coded) BabylonjsCorePostProcess.animations.
        checkPrimitiveDiff(oldProps.autoClear, newProps.autoClear, 'autoClear', changedProps);
        checkColor4Diff(oldProps.clearColor, newProps.clearColor, 'clearColor', changedProps);
        checkPrimitiveDiff(oldProps.enablePixelPerfectMode, newProps.enablePixelPerfectMode, 'enablePixelPerfectMode', changedProps);
        checkPrimitiveDiff(oldProps.externalTextureSamplerBinding, newProps.externalTextureSamplerBinding, 'externalTextureSamplerBinding', changedProps);
        checkPrimitiveDiff(oldProps.forceFullscreenViewport, newProps.forceFullscreenViewport, 'forceFullscreenViewport', changedProps);
        checkPrimitiveDiff(oldProps.height, newProps.height, 'height', changedProps);
        // type: 'BabylonjsCoreRenderTargetWrapper' property (not coded) BabylonjsCorePostProcess.inputTexture.
        // type: 'BabylonjsCoreIInspectable[]' property (not coded) BabylonjsCorePostProcess.inspectableCustomProperties.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        // type: 'BabylonjsCoreNodeMaterial' property (not coded) BabylonjsCorePostProcess.nodeMaterialSource.
        checkLambdaDiff(oldProps.onActivate, newProps.onActivate, 'onActivate', changedProps);
        checkObservableDiff(oldProps.onActivateObservable, newProps.onActivateObservable, 'onActivateObservable', changedProps);
        checkLambdaDiff(oldProps.onAfterRender, newProps.onAfterRender, 'onAfterRender', changedProps);
        checkObservableDiff(oldProps.onAfterRenderObservable, newProps.onAfterRenderObservable, 'onAfterRenderObservable', changedProps);
        checkLambdaDiff(oldProps.onApply, newProps.onApply, 'onApply', changedProps);
        checkObservableDiff(oldProps.onApplyObservable, newProps.onApplyObservable, 'onApplyObservable', changedProps);
        checkLambdaDiff(oldProps.onBeforeRender, newProps.onBeforeRender, 'onBeforeRender', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderObservable, newProps.onBeforeRenderObservable, 'onBeforeRenderObservable', changedProps);
        checkLambdaDiff(oldProps.onSizeChanged, newProps.onSizeChanged, 'onSizeChanged', changedProps);
        checkObservableDiff(oldProps.onSizeChangedObservable, newProps.onSizeChangedObservable, 'onSizeChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.renderTargetSamplingMode, newProps.renderTargetSamplingMode, 'renderTargetSamplingMode', changedProps);
        checkPrimitiveDiff(oldProps.samples, newProps.samples, 'samples', changedProps);
        checkPrimitiveDiff(oldProps.scaleMode, newProps.scaleMode, 'scaleMode', changedProps);
        checkPrimitiveDiff(oldProps.uniqueId, newProps.uniqueId, 'uniqueId', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        checkMethodDiff(oldProps.setPrePassRenderer, newProps.setPrePassRenderer, 'setPrePassRenderer', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPostProcessPropsHandler;
}());
/**
 * PostProcess can be used to apply a shader to a texture after it has been rendered
 * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
 *
 * This code has been generated
 */
var FiberPostProcess = /** @class */ (function () {
    function FiberPostProcess() {
        this.propsHandlers = [new FiberPostProcessPropsHandler()];
    }
    FiberPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'fragmentUrl',
                type: 'string',
                optional: false,
            },
            {
                name: 'parameters',
                type: 'string[]',
                optional: false,
            },
            {
                name: 'samplers',
                type: 'string[]',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'defines',
                type: 'string',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'vertexUrl',
                type: 'string',
                optional: true,
            },
            {
                name: 'indexParameters',
                type: 'any',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureFormat',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberPostProcess.Metadata = {
        className: 'FiberPostProcess',
    };
    return FiberPostProcess;
}());
var FiberImageProcessingPostProcessPropsHandler = /** @class */ (function () {
    function FiberImageProcessingPostProcessPropsHandler() {
    }
    FiberImageProcessingPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreColorCurves' property (not coded) BabylonjsCoreImageProcessingPostProcess.colorCurves.
        checkPrimitiveDiff(oldProps.colorCurvesEnabled, newProps.colorCurvesEnabled, 'colorCurvesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.colorGradingEnabled, newProps.colorGradingEnabled, 'colorGradingEnabled', changedProps);
        checkTextureDiff(oldProps.colorGradingTexture, newProps.colorGradingTexture, 'colorGradingTexture', changedProps);
        checkPrimitiveDiff(oldProps.contrast, newProps.contrast, 'contrast', changedProps);
        checkPrimitiveDiff(oldProps.exposure, newProps.exposure, 'exposure', changedProps);
        checkPrimitiveDiff(oldProps.fromLinearSpace, newProps.fromLinearSpace, 'fromLinearSpace', changedProps);
        // type: 'BabylonjsCoreImageProcessingConfiguration' property (not coded) BabylonjsCoreImageProcessingPostProcess.imageProcessingConfiguration.
        checkPrimitiveDiff(oldProps.toneMappingEnabled, newProps.toneMappingEnabled, 'toneMappingEnabled', changedProps);
        checkPrimitiveDiff(oldProps.toneMappingType, newProps.toneMappingType, 'toneMappingType', changedProps);
        checkPrimitiveDiff(oldProps.vignetteBlendMode, newProps.vignetteBlendMode, 'vignetteBlendMode', changedProps);
        checkPrimitiveDiff(oldProps.vignetteCameraFov, newProps.vignetteCameraFov, 'vignetteCameraFov', changedProps);
        checkPrimitiveDiff(oldProps.vignetteCentreX, newProps.vignetteCentreX, 'vignetteCentreX', changedProps);
        checkPrimitiveDiff(oldProps.vignetteCentreY, newProps.vignetteCentreY, 'vignetteCentreY', changedProps);
        checkColor4Diff(oldProps.vignetteColor, newProps.vignetteColor, 'vignetteColor', changedProps);
        checkPrimitiveDiff(oldProps.vignetteEnabled, newProps.vignetteEnabled, 'vignetteEnabled', changedProps);
        checkPrimitiveDiff(oldProps.vignetteStretch, newProps.vignetteStretch, 'vignetteStretch', changedProps);
        checkPrimitiveDiff(oldProps.vignetteWeight, newProps.vignetteWeight, 'vignetteWeight', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberImageProcessingPostProcessPropsHandler;
}());
/**
 * ImageProcessingPostProcess
 *
 * This code has been generated
 */
var FiberImageProcessingPostProcess = /** @class */ (function () {
    function FiberImageProcessingPostProcess() {
        this.propsHandlers = [
            new FiberImageProcessingPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberImageProcessingPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberImageProcessingPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberImageProcessingPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ImageProcessingPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'imageProcessingConfiguration',
                type: 'BabylonjsCoreImageProcessingConfiguration',
                optional: true,
            },
        ],
    };
    FiberImageProcessingPostProcess.Metadata = {
        className: 'FiberImageProcessingPostProcess',
    };
    return FiberImageProcessingPostProcess;
}());
var FiberAnaglyphPostProcessPropsHandler = /** @class */ (function () {
    function FiberAnaglyphPostProcessPropsHandler() {
    }
    FiberAnaglyphPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberAnaglyphPostProcessPropsHandler;
}());
/**
 * Postprocess used to generate anaglyphic rendering
 *
 * This code has been generated
 */
var FiberAnaglyphPostProcess = /** @class */ (function () {
    function FiberAnaglyphPostProcess() {
        this.propsHandlers = [
            new FiberAnaglyphPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberAnaglyphPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAnaglyphPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAnaglyphPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AnaglyphPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'rigCameras',
                type: 'BabylonjsCoreCamera[]',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberAnaglyphPostProcess.Metadata = {
        className: 'FiberAnaglyphPostProcess',
    };
    return FiberAnaglyphPostProcess;
}());
var FiberBlackAndWhitePostProcessPropsHandler = /** @class */ (function () {
    function FiberBlackAndWhitePostProcessPropsHandler() {
    }
    FiberBlackAndWhitePostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.degree, newProps.degree, 'degree', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBlackAndWhitePostProcessPropsHandler;
}());
/**
 * Post process used to render in black and white
 *
 * This code has been generated
 */
var FiberBlackAndWhitePostProcess = /** @class */ (function () {
    function FiberBlackAndWhitePostProcess() {
        this.propsHandlers = [
            new FiberBlackAndWhitePostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberBlackAndWhitePostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBlackAndWhitePostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBlackAndWhitePostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BlackAndWhitePostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberBlackAndWhitePostProcess.Metadata = {
        className: 'FiberBlackAndWhitePostProcess',
    };
    return FiberBlackAndWhitePostProcess;
}());
var FiberExtractHighlightsPostProcessPropsHandler = /** @class */ (function () {
    function FiberExtractHighlightsPostProcessPropsHandler() {
    }
    FiberExtractHighlightsPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.threshold, newProps.threshold, 'threshold', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberExtractHighlightsPostProcessPropsHandler;
}());
/**
 * The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
 *
 * This code has been generated
 */
var FiberExtractHighlightsPostProcess = /** @class */ (function () {
    function FiberExtractHighlightsPostProcess() {
        this.propsHandlers = [
            new FiberExtractHighlightsPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberExtractHighlightsPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberExtractHighlightsPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberExtractHighlightsPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ExtractHighlightsPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberExtractHighlightsPostProcess.Metadata = {
        className: 'FiberExtractHighlightsPostProcess',
    };
    return FiberExtractHighlightsPostProcess;
}());
var FiberBloomMergePostProcessPropsHandler = /** @class */ (function () {
    function FiberBloomMergePostProcessPropsHandler() {
    }
    FiberBloomMergePostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.weight, newProps.weight, 'weight', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBloomMergePostProcessPropsHandler;
}());
/**
 * The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
 *
 * This code has been generated
 */
var FiberBloomMergePostProcess = /** @class */ (function () {
    function FiberBloomMergePostProcess() {
        this.propsHandlers = [
            new FiberBloomMergePostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberBloomMergePostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBloomMergePostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBloomMergePostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BloomMergePostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'originalFromInput',
                type: 'BabylonjsCorePostProcess',
                optional: false,
            },
            {
                name: 'blurred',
                type: 'BabylonjsCorePostProcess',
                optional: false,
            },
            {
                name: 'weight',
                type: 'number',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberBloomMergePostProcess.Metadata = {
        className: 'FiberBloomMergePostProcess',
    };
    return FiberBloomMergePostProcess;
}());
var FiberBlurPostProcessPropsHandler = /** @class */ (function () {
    function FiberBlurPostProcessPropsHandler() {
    }
    FiberBlurPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreBlurPostProcess.direction.
        checkPrimitiveDiff(oldProps.kernel, newProps.kernel, 'kernel', changedProps);
        checkPrimitiveDiff(oldProps.packedFloat, newProps.packedFloat, 'packedFloat', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBlurPostProcessPropsHandler;
}());
/**
 * The Blur Post Process which blurs an image based on a kernel and direction.
 * Can be used twice in x and y directions to perform a gaussian blur in two passes.
 *
 * This code has been generated
 */
var FiberBlurPostProcess = /** @class */ (function () {
    function FiberBlurPostProcess() {
        this.propsHandlers = [
            new FiberBlurPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberBlurPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBlurPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBlurPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BlurPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'direction',
                type: 'BabylonjsCoreVector2',
                optional: false,
            },
            {
                name: 'kernel',
                type: 'number',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'defines',
                type: 'string',
                optional: true,
            },
            {
                name: '_blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberBlurPostProcess.Metadata = {
        className: 'FiberBlurPostProcess',
    };
    return FiberBlurPostProcess;
}());
var FiberDepthOfFieldBlurPostProcessPropsHandler = /** @class */ (function () {
    function FiberDepthOfFieldBlurPostProcessPropsHandler() {
    }
    FiberDepthOfFieldBlurPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        // skipping type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreDepthOfFieldBlurPostProcess.direction.
        return null; // no props to check
    };
    return FiberDepthOfFieldBlurPostProcessPropsHandler;
}());
/**
 * The DepthOfFieldBlurPostProcess applied a blur in a give direction.
 * This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
 * based on samples that have a large difference in distance than the center pixel.
 * See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
 *
 * This code has been generated
 */
var FiberDepthOfFieldBlurPostProcess = /** @class */ (function () {
    function FiberDepthOfFieldBlurPostProcess() {
        this.propsHandlers = [
            new FiberDepthOfFieldBlurPostProcessPropsHandler(),
            new FiberBlurPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberDepthOfFieldBlurPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDepthOfFieldBlurPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDepthOfFieldBlurPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DepthOfFieldBlurPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'direction',
                type: 'BabylonjsCoreVector2',
                optional: false,
            },
            {
                name: 'kernel',
                type: 'number',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'circleOfConfusion',
                type: 'BabylonjsCorePostProcess',
                optional: false,
            },
            {
                name: 'imageToBlur',
                type: 'BabylonjsCorePostProcess',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberDepthOfFieldBlurPostProcess.Metadata = {
        className: 'FiberDepthOfFieldBlurPostProcess',
    };
    return FiberDepthOfFieldBlurPostProcess;
}());
var FiberChromaticAberrationPostProcessPropsHandler = /** @class */ (function () {
    function FiberChromaticAberrationPostProcessPropsHandler() {
    }
    FiberChromaticAberrationPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.aberrationAmount, newProps.aberrationAmount, 'aberrationAmount', changedProps);
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreChromaticAberrationPostProcess.centerPosition.
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreChromaticAberrationPostProcess.direction.
        checkPrimitiveDiff(oldProps.radialIntensity, newProps.radialIntensity, 'radialIntensity', changedProps);
        checkPrimitiveDiff(oldProps.screenHeight, newProps.screenHeight, 'screenHeight', changedProps);
        checkPrimitiveDiff(oldProps.screenWidth, newProps.screenWidth, 'screenWidth', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberChromaticAberrationPostProcessPropsHandler;
}());
/**
 * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
 *
 * This code has been generated
 */
var FiberChromaticAberrationPostProcess = /** @class */ (function () {
    function FiberChromaticAberrationPostProcess() {
        this.propsHandlers = [
            new FiberChromaticAberrationPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberChromaticAberrationPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberChromaticAberrationPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberChromaticAberrationPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ChromaticAberrationPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'screenWidth',
                type: 'number',
                optional: false,
            },
            {
                name: 'screenHeight',
                type: 'number',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberChromaticAberrationPostProcess.Metadata = {
        className: 'FiberChromaticAberrationPostProcess',
    };
    return FiberChromaticAberrationPostProcess;
}());
var FiberCircleOfConfusionPostProcessPropsHandler = /** @class */ (function () {
    function FiberCircleOfConfusionPostProcessPropsHandler() {
    }
    FiberCircleOfConfusionPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreRenderTargetTexture' property (not coded) BabylonjsCoreCircleOfConfusionPostProcess.depthTexture.
        checkPrimitiveDiff(oldProps.focalLength, newProps.focalLength, 'focalLength', changedProps);
        checkPrimitiveDiff(oldProps.focusDistance, newProps.focusDistance, 'focusDistance', changedProps);
        checkPrimitiveDiff(oldProps.fStop, newProps.fStop, 'fStop', changedProps);
        checkPrimitiveDiff(oldProps.lensSize, newProps.lensSize, 'lensSize', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCircleOfConfusionPostProcessPropsHandler;
}());
/**
 * The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
 *
 * This code has been generated
 */
var FiberCircleOfConfusionPostProcess = /** @class */ (function () {
    function FiberCircleOfConfusionPostProcess() {
        this.propsHandlers = [
            new FiberCircleOfConfusionPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberCircleOfConfusionPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCircleOfConfusionPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCircleOfConfusionPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'CircleOfConfusionPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'depthTexture',
                type: 'BabylonjsCoreRenderTargetTexture',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberCircleOfConfusionPostProcess.Metadata = {
        className: 'FiberCircleOfConfusionPostProcess',
    };
    return FiberCircleOfConfusionPostProcess;
}());
var FiberColorCorrectionPostProcessPropsHandler = /** @class */ (function () {
    function FiberColorCorrectionPostProcessPropsHandler() {
    }
    FiberColorCorrectionPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.colorTableUrl, newProps.colorTableUrl, 'colorTableUrl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberColorCorrectionPostProcessPropsHandler;
}());
/**
 * This post-process allows the modification of rendered colors by using
 * a 'look-up table' (LUT). This effect is also called Color Grading.
 *
 * The object needs to be provided an url to a texture containing the color
 * look-up table: the texture must be 256 pixels wide and 16 pixels high.
 * Use an image editing software to tweak the LUT to match your needs.
 *
 * For an example of a color LUT, see here:
 *
 * This code has been generated
 */
var FiberColorCorrectionPostProcess = /** @class */ (function () {
    function FiberColorCorrectionPostProcess() {
        this.propsHandlers = [
            new FiberColorCorrectionPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberColorCorrectionPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberColorCorrectionPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberColorCorrectionPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ColorCorrectionPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'colorTableUrl',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberColorCorrectionPostProcess.Metadata = {
        className: 'FiberColorCorrectionPostProcess',
    };
    return FiberColorCorrectionPostProcess;
}());
var FiberConvolutionPostProcessPropsHandler = /** @class */ (function () {
    function FiberConvolutionPostProcessPropsHandler() {
    }
    FiberConvolutionPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkNumericArrayDiff(oldProps.kernel, newProps.kernel, 'kernel', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberConvolutionPostProcessPropsHandler;
}());
/**
 * The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
 * input texture to perform effects such as edge detection or sharpening
 * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
 *
 * This code has been generated
 */
var FiberConvolutionPostProcess = /** @class */ (function () {
    function FiberConvolutionPostProcess() {
        this.propsHandlers = [
            new FiberConvolutionPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberConvolutionPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberConvolutionPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberConvolutionPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ConvolutionPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'kernel',
                type: 'number[]',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberConvolutionPostProcess.Metadata = {
        className: 'FiberConvolutionPostProcess',
    };
    return FiberConvolutionPostProcess;
}());
var FiberDepthOfFieldMergePostProcessPropsHandler = /** @class */ (function () {
    function FiberDepthOfFieldMergePostProcessPropsHandler() {
    }
    FiberDepthOfFieldMergePostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberDepthOfFieldMergePostProcessPropsHandler;
}());
/**
 * The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
 *
 * This code has been generated
 */
var FiberDepthOfFieldMergePostProcess = /** @class */ (function () {
    function FiberDepthOfFieldMergePostProcess() {
        this.propsHandlers = [
            new FiberDepthOfFieldMergePostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberDepthOfFieldMergePostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDepthOfFieldMergePostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDepthOfFieldMergePostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DepthOfFieldMergePostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'originalFromInput',
                type: 'BabylonjsCorePostProcess',
                optional: false,
            },
            {
                name: 'circleOfConfusion',
                type: 'BabylonjsCorePostProcess',
                optional: false,
            },
            {
                name: '_blurSteps',
                type: 'BabylonjsCorePostProcess[]',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberDepthOfFieldMergePostProcess.Metadata = {
        className: 'FiberDepthOfFieldMergePostProcess',
    };
    return FiberDepthOfFieldMergePostProcess;
}());
var FiberDisplayPassPostProcessPropsHandler = /** @class */ (function () {
    function FiberDisplayPassPostProcessPropsHandler() {
    }
    FiberDisplayPassPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberDisplayPassPostProcessPropsHandler;
}());
/**
 * DisplayPassPostProcess which produces an output the same as it's input
 *
 * This code has been generated
 */
var FiberDisplayPassPostProcess = /** @class */ (function () {
    function FiberDisplayPassPostProcess() {
        this.propsHandlers = [
            new FiberDisplayPassPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberDisplayPassPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDisplayPassPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDisplayPassPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DisplayPassPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberDisplayPassPostProcess.Metadata = {
        className: 'FiberDisplayPassPostProcess',
    };
    return FiberDisplayPassPostProcess;
}());
var FiberFilterPostProcessPropsHandler = /** @class */ (function () {
    function FiberFilterPostProcessPropsHandler() {
    }
    FiberFilterPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        // skipping type: 'BabylonjsCoreMatrix' property (not coded) BabylonjsCoreFilterPostProcess.kernelMatrix.
        return null; // no props to check
    };
    return FiberFilterPostProcessPropsHandler;
}());
/**
 * Applies a kernel filter to the image
 *
 * This code has been generated
 */
var FiberFilterPostProcess = /** @class */ (function () {
    function FiberFilterPostProcess() {
        this.propsHandlers = [
            new FiberFilterPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberFilterPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFilterPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFilterPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FilterPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'kernelMatrix',
                type: 'BabylonjsCoreMatrix',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberFilterPostProcess.Metadata = {
        className: 'FiberFilterPostProcess',
    };
    return FiberFilterPostProcess;
}());
var FiberFxaaPostProcessPropsHandler = /** @class */ (function () {
    function FiberFxaaPostProcessPropsHandler() {
    }
    FiberFxaaPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberFxaaPostProcessPropsHandler;
}());
/**
 * Fxaa post process
 *
 * This code has been generated
 */
var FiberFxaaPostProcess = /** @class */ (function () {
    function FiberFxaaPostProcess() {
        this.propsHandlers = [
            new FiberFxaaPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberFxaaPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFxaaPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFxaaPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FxaaPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberFxaaPostProcess.Metadata = {
        className: 'FiberFxaaPostProcess',
    };
    return FiberFxaaPostProcess;
}());
var FiberGrainPostProcessPropsHandler = /** @class */ (function () {
    function FiberGrainPostProcessPropsHandler() {
    }
    FiberGrainPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.animated, newProps.animated, 'animated', changedProps);
        checkPrimitiveDiff(oldProps.intensity, newProps.intensity, 'intensity', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGrainPostProcessPropsHandler;
}());
/**
 * The GrainPostProcess adds noise to the image at mid luminance levels
 *
 * This code has been generated
 */
var FiberGrainPostProcess = /** @class */ (function () {
    function FiberGrainPostProcess() {
        this.propsHandlers = [
            new FiberGrainPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberGrainPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGrainPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGrainPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GrainPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberGrainPostProcess.Metadata = {
        className: 'FiberGrainPostProcess',
    };
    return FiberGrainPostProcess;
}());
var FiberHighlightsPostProcessPropsHandler = /** @class */ (function () {
    function FiberHighlightsPostProcessPropsHandler() {
    }
    FiberHighlightsPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberHighlightsPostProcessPropsHandler;
}());
/**
 * Extracts highlights from the image
 *
 * This code has been generated
 */
var FiberHighlightsPostProcess = /** @class */ (function () {
    function FiberHighlightsPostProcess() {
        this.propsHandlers = [
            new FiberHighlightsPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberHighlightsPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHighlightsPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHighlightsPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HighlightsPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberHighlightsPostProcess.Metadata = {
        className: 'FiberHighlightsPostProcess',
    };
    return FiberHighlightsPostProcess;
}());
var FiberMotionBlurPostProcessPropsHandler = /** @class */ (function () {
    function FiberMotionBlurPostProcessPropsHandler() {
    }
    FiberMotionBlurPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.isObjectBased, newProps.isObjectBased, 'isObjectBased', changedProps);
        checkPrimitiveDiff(oldProps.motionBlurSamples, newProps.motionBlurSamples, 'motionBlurSamples', changedProps);
        checkPrimitiveDiff(oldProps.motionStrength, newProps.motionStrength, 'motionStrength', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMotionBlurPostProcessPropsHandler;
}());
/**
 * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.
 * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.
 * As an example, all you have to do is to create the post-process:
 *  var mb = new BABYLON.MotionBlurPostProcess(
 *      'mb', // The name of the effect.
 *      scene, // The scene containing the objects to blur according to their velocity.
 *      1.0, // The required width/height ratio to downsize to before computing the render pass.
 *      camera // The camera to apply the render pass to.
 * );
 * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.
 *
 * This code has been generated
 */
var FiberMotionBlurPostProcess = /** @class */ (function () {
    function FiberMotionBlurPostProcess() {
        this.propsHandlers = [
            new FiberMotionBlurPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberMotionBlurPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMotionBlurPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMotionBlurPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MotionBlurPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'forceGeometryBuffer',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberMotionBlurPostProcess.Metadata = {
        className: 'FiberMotionBlurPostProcess',
    };
    return FiberMotionBlurPostProcess;
}());
var FiberPassPostProcessPropsHandler = /** @class */ (function () {
    function FiberPassPostProcessPropsHandler() {
    }
    FiberPassPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberPassPostProcessPropsHandler;
}());
/**
 * PassPostProcess which produces an output the same as it's input
 *
 * This code has been generated
 */
var FiberPassPostProcess = /** @class */ (function () {
    function FiberPassPostProcess() {
        this.propsHandlers = [
            new FiberPassPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberPassPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPassPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPassPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PassPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPassPostProcess.Metadata = {
        className: 'FiberPassPostProcess',
    };
    return FiberPassPostProcess;
}());
var FiberPassCubePostProcessPropsHandler = /** @class */ (function () {
    function FiberPassCubePostProcessPropsHandler() {
    }
    FiberPassCubePostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.face, newProps.face, 'face', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPassCubePostProcessPropsHandler;
}());
/**
 * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)
 *
 * This code has been generated
 */
var FiberPassCubePostProcess = /** @class */ (function () {
    function FiberPassCubePostProcess() {
        this.propsHandlers = [
            new FiberPassCubePostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberPassCubePostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPassCubePostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPassCubePostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PassCubePostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPassCubePostProcess.Metadata = {
        className: 'FiberPassCubePostProcess',
    };
    return FiberPassCubePostProcess;
}());
var FiberRefractionPostProcessPropsHandler = /** @class */ (function () {
    function FiberRefractionPostProcessPropsHandler() {
    }
    FiberRefractionPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.color, newProps.color, 'color', changedProps);
        checkPrimitiveDiff(oldProps.colorLevel, newProps.colorLevel, 'colorLevel', changedProps);
        checkPrimitiveDiff(oldProps.depth, newProps.depth, 'depth', changedProps);
        // type: 'BabylonjsCoreTexture' property (not coded) BabylonjsCoreRefractionPostProcess.refractionTexture.
        checkPrimitiveDiff(oldProps.refractionTextureUrl, newProps.refractionTextureUrl, 'refractionTextureUrl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRefractionPostProcessPropsHandler;
}());
/**
 * Post process which applies a refraction texture
 *
 * This code has been generated
 */
var FiberRefractionPostProcess = /** @class */ (function () {
    function FiberRefractionPostProcess() {
        this.propsHandlers = [
            new FiberRefractionPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberRefractionPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRefractionPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRefractionPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RefractionPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'refractionTextureUrl',
                type: 'string',
                optional: false,
            },
            {
                name: 'color',
                type: 'BabylonjsCoreColor3',
                optional: false,
            },
            {
                name: 'depth',
                type: 'number',
                optional: false,
            },
            {
                name: 'colorLevel',
                type: 'number',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberRefractionPostProcess.Metadata = {
        className: 'FiberRefractionPostProcess',
    };
    return FiberRefractionPostProcess;
}());
var FiberSharpenPostProcessPropsHandler = /** @class */ (function () {
    function FiberSharpenPostProcessPropsHandler() {
    }
    FiberSharpenPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.colorAmount, newProps.colorAmount, 'colorAmount', changedProps);
        checkPrimitiveDiff(oldProps.edgeAmount, newProps.edgeAmount, 'edgeAmount', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSharpenPostProcessPropsHandler;
}());
/**
 * The SharpenPostProcess applies a sharpen kernel to every pixel
 * See http://en.wikipedia.org/wiki/Kernel_(image_processing)
 *
 * This code has been generated
 */
var FiberSharpenPostProcess = /** @class */ (function () {
    function FiberSharpenPostProcess() {
        this.propsHandlers = [
            new FiberSharpenPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberSharpenPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSharpenPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSharpenPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SharpenPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberSharpenPostProcess.Metadata = {
        className: 'FiberSharpenPostProcess',
    };
    return FiberSharpenPostProcess;
}());
var FiberScreenSpaceReflectionPostProcessPropsHandler = /** @class */ (function () {
    function FiberScreenSpaceReflectionPostProcessPropsHandler() {
    }
    FiberScreenSpaceReflectionPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.enableSmoothReflections, newProps.enableSmoothReflections, 'enableSmoothReflections', changedProps);
        checkPrimitiveDiff(oldProps.reflectionSamples, newProps.reflectionSamples, 'reflectionSamples', changedProps);
        checkPrimitiveDiff(oldProps.reflectionSpecularFalloffExponent, newProps.reflectionSpecularFalloffExponent, 'reflectionSpecularFalloffExponent', changedProps);
        checkPrimitiveDiff(oldProps.roughnessFactor, newProps.roughnessFactor, 'roughnessFactor', changedProps);
        checkPrimitiveDiff(oldProps.smoothSteps, newProps.smoothSteps, 'smoothSteps', changedProps);
        checkPrimitiveDiff(oldProps.step, newProps.step, 'step', changedProps);
        checkPrimitiveDiff(oldProps.strength, newProps.strength, 'strength', changedProps);
        checkPrimitiveDiff(oldProps.threshold, newProps.threshold, 'threshold', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScreenSpaceReflectionPostProcessPropsHandler;
}());
/**
 * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).
 * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.
 *
 * This code has been generated
 */
var FiberScreenSpaceReflectionPostProcess = /** @class */ (function () {
    function FiberScreenSpaceReflectionPostProcess() {
        this.propsHandlers = [
            new FiberScreenSpaceReflectionPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberScreenSpaceReflectionPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberScreenSpaceReflectionPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberScreenSpaceReflectionPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ScreenSpaceReflectionPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'forceGeometryBuffer',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberScreenSpaceReflectionPostProcess.Metadata = {
        className: 'FiberScreenSpaceReflectionPostProcess',
    };
    return FiberScreenSpaceReflectionPostProcess;
}());
var FiberStereoscopicInterlacePostProcessIPropsHandler = /** @class */ (function () {
    function FiberStereoscopicInterlacePostProcessIPropsHandler() {
    }
    FiberStereoscopicInterlacePostProcessIPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberStereoscopicInterlacePostProcessIPropsHandler;
}());
/**
 * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing
 *
 * This code has been generated
 */
var FiberStereoscopicInterlacePostProcessI = /** @class */ (function () {
    function FiberStereoscopicInterlacePostProcessI() {
        this.propsHandlers = [
            new FiberStereoscopicInterlacePostProcessIPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberStereoscopicInterlacePostProcessI.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicInterlacePostProcessI.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicInterlacePostProcessI.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicInterlacePostProcessI',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'rigCameras',
                type: 'BabylonjsCoreCamera[]',
                optional: false,
            },
            {
                name: 'isStereoscopicHoriz',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'isStereoscopicInterlaced',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberStereoscopicInterlacePostProcessI.Metadata = {
        className: 'FiberStereoscopicInterlacePostProcessI',
    };
    return FiberStereoscopicInterlacePostProcessI;
}());
var FiberStereoscopicInterlacePostProcessPropsHandler = /** @class */ (function () {
    function FiberStereoscopicInterlacePostProcessPropsHandler() {
    }
    FiberStereoscopicInterlacePostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberStereoscopicInterlacePostProcessPropsHandler;
}());
/**
 * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera
 *
 * This code has been generated
 */
var FiberStereoscopicInterlacePostProcess = /** @class */ (function () {
    function FiberStereoscopicInterlacePostProcess() {
        this.propsHandlers = [
            new FiberStereoscopicInterlacePostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberStereoscopicInterlacePostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberStereoscopicInterlacePostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberStereoscopicInterlacePostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'StereoscopicInterlacePostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'rigCameras',
                type: 'BabylonjsCoreCamera[]',
                optional: false,
            },
            {
                name: 'isStereoscopicHoriz',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberStereoscopicInterlacePostProcess.Metadata = {
        className: 'FiberStereoscopicInterlacePostProcess',
    };
    return FiberStereoscopicInterlacePostProcess;
}());
var FiberTonemapPostProcessPropsHandler = /** @class */ (function () {
    function FiberTonemapPostProcessPropsHandler() {
    }
    FiberTonemapPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.exposureAdjustment, newProps.exposureAdjustment, 'exposureAdjustment', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberTonemapPostProcessPropsHandler;
}());
/**
 * Defines a post process to apply tone mapping
 *
 * This code has been generated
 */
var FiberTonemapPostProcess = /** @class */ (function () {
    function FiberTonemapPostProcess() {
        this.propsHandlers = [
            new FiberTonemapPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberTonemapPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberTonemapPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberTonemapPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'TonemapPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: '_operator',
                type: 'BabylonjsCoreTonemappingOperator',
                optional: false,
            },
            {
                name: 'exposureAdjustment',
                type: 'number',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'textureFormat',
                type: 'number',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberTonemapPostProcess.Metadata = {
        className: 'FiberTonemapPostProcess',
    };
    return FiberTonemapPostProcess;
}());
var FiberVolumetricLightScatteringPostProcessPropsHandler = /** @class */ (function () {
    function FiberVolumetricLightScatteringPostProcessPropsHandler() {
    }
    FiberVolumetricLightScatteringPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: '{ position: BabylonjsCoreVector3; }' property (not coded) BabylonjsCoreVolumetricLightScatteringPostProcess.attachedNode.
        checkVector3Diff(oldProps.customMeshPosition, newProps.customMeshPosition, 'customMeshPosition', changedProps);
        checkPrimitiveDiff(oldProps['customMeshPosition-x'], newProps['customMeshPosition-x'], 'customMeshPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['customMeshPosition-y'], newProps['customMeshPosition-y'], 'customMeshPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['customMeshPosition-z'], newProps['customMeshPosition-z'], 'customMeshPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.decay, newProps.decay, 'decay', changedProps);
        checkPrimitiveDiff(oldProps.density, newProps.density, 'density', changedProps);
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreVolumetricLightScatteringPostProcess.excludedMeshes.
        checkPrimitiveDiff(oldProps.exposure, newProps.exposure, 'exposure', changedProps);
        checkPrimitiveDiff(oldProps.invert, newProps.invert, 'invert', changedProps);
        // type: 'BabylonjsCoreMesh' property (not coded) BabylonjsCoreVolumetricLightScatteringPostProcess.mesh.
        checkPrimitiveDiff(oldProps.useCustomMeshPosition, newProps.useCustomMeshPosition, 'useCustomMeshPosition', changedProps);
        checkPrimitiveDiff(oldProps.useDiffuseColor, newProps.useDiffuseColor, 'useDiffuseColor', changedProps);
        checkPrimitiveDiff(oldProps.weight, newProps.weight, 'weight', changedProps);
        checkMethodDiff(oldProps.setCustomMeshPosition, newProps.setCustomMeshPosition, 'setCustomMeshPosition', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberVolumetricLightScatteringPostProcessPropsHandler;
}());
/**
 * Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html
 *
 * This code has been generated
 */
var FiberVolumetricLightScatteringPostProcess = /** @class */ (function () {
    function FiberVolumetricLightScatteringPostProcess() {
        this.propsHandlers = [
            new FiberVolumetricLightScatteringPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberVolumetricLightScatteringPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVolumetricLightScatteringPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVolumetricLightScatteringPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VolumetricLightScatteringPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'ratio',
                type: 'any',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'mesh',
                type: 'BabylonjsCoreMesh',
                optional: true,
            },
            {
                name: 'samples',
                type: 'number',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberVolumetricLightScatteringPostProcess.Metadata = {
        className: 'FiberVolumetricLightScatteringPostProcess',
    };
    return FiberVolumetricLightScatteringPostProcess;
}());
var FiberVRDistortionCorrectionPostProcessPropsHandler = /** @class */ (function () {
    function FiberVRDistortionCorrectionPostProcessPropsHandler() {
    }
    FiberVRDistortionCorrectionPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVRDistortionCorrectionPostProcessPropsHandler;
}());
/**
 * VRDistortionCorrectionPostProcess used for mobile VR
 *
 * This code has been generated
 */
var FiberVRDistortionCorrectionPostProcess = /** @class */ (function () {
    function FiberVRDistortionCorrectionPostProcess() {
        this.propsHandlers = [
            new FiberVRDistortionCorrectionPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberVRDistortionCorrectionPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVRDistortionCorrectionPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVRDistortionCorrectionPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VRDistortionCorrectionPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'isRightEye',
                type: 'boolean',
                optional: false,
            },
            {
                name: 'vrMetrics',
                type: 'BabylonjsCoreVRCameraMetrics',
                optional: false,
            },
        ],
    };
    FiberVRDistortionCorrectionPostProcess.Metadata = {
        className: 'FiberVRDistortionCorrectionPostProcess',
    };
    return FiberVRDistortionCorrectionPostProcess;
}());
var FiberVRMultiviewToSingleviewPostProcessPropsHandler = /** @class */ (function () {
    function FiberVRMultiviewToSingleviewPostProcessPropsHandler() {
    }
    FiberVRMultiviewToSingleviewPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberVRMultiviewToSingleviewPostProcessPropsHandler;
}());
/**
 * VRMultiviewToSingleview used to convert multiview texture arrays to standard textures for scenarios such as webVR
 * This will not be used for webXR as it supports displaying texture arrays directly
 *
 * This code has been generated
 */
var FiberVRMultiviewToSingleviewPostProcess = /** @class */ (function () {
    function FiberVRMultiviewToSingleviewPostProcess() {
        this.propsHandlers = [
            new FiberVRMultiviewToSingleviewPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberVRMultiviewToSingleviewPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVRMultiviewToSingleviewPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVRMultiviewToSingleviewPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VRMultiviewToSingleviewPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'scaleFactor',
                type: 'number',
                optional: false,
            },
        ],
    };
    FiberVRMultiviewToSingleviewPostProcess.Metadata = {
        className: 'FiberVRMultiviewToSingleviewPostProcess',
    };
    return FiberVRMultiviewToSingleviewPostProcess;
}());
var FiberScreenSpaceCurvaturePostProcessPropsHandler = /** @class */ (function () {
    function FiberScreenSpaceCurvaturePostProcessPropsHandler() {
    }
    FiberScreenSpaceCurvaturePostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.ridge, newProps.ridge, 'ridge', changedProps);
        checkPrimitiveDiff(oldProps.valley, newProps.valley, 'valley', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScreenSpaceCurvaturePostProcessPropsHandler;
}());
/**
 * The Screen Space curvature effect can help highlighting ridge and valley of a model.
 *
 * This code has been generated
 */
var FiberScreenSpaceCurvaturePostProcess = /** @class */ (function () {
    function FiberScreenSpaceCurvaturePostProcess() {
        this.propsHandlers = [
            new FiberScreenSpaceCurvaturePostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberScreenSpaceCurvaturePostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberScreenSpaceCurvaturePostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberScreenSpaceCurvaturePostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ScreenSpaceCurvaturePostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: false,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
            {
                name: 'blockCompilation',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberScreenSpaceCurvaturePostProcess.Metadata = {
        className: 'FiberScreenSpaceCurvaturePostProcess',
    };
    return FiberScreenSpaceCurvaturePostProcess;
}());
var FiberSubSurfaceScatteringPostProcessPropsHandler = /** @class */ (function () {
    function FiberSubSurfaceScatteringPostProcessPropsHandler() {
    }
    FiberSubSurfaceScatteringPostProcessPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberSubSurfaceScatteringPostProcessPropsHandler;
}());
/**
 * Sub surface scattering post process
 *
 * This code has been generated
 */
var FiberSubSurfaceScatteringPostProcess = /** @class */ (function () {
    function FiberSubSurfaceScatteringPostProcess() {
        this.propsHandlers = [
            new FiberSubSurfaceScatteringPostProcessPropsHandler(),
            new FiberPostProcessPropsHandler(),
        ];
    }
    FiberSubSurfaceScatteringPostProcess.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSubSurfaceScatteringPostProcess.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSubSurfaceScatteringPostProcess.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SubSurfaceScatteringPostProcess',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'options',
                type: 'number | BabylonjsCorePostProcessOptions',
                optional: false,
            },
            {
                name: 'camera',
                type: 'BabylonjsCoreCamera',
                optional: true,
            },
            {
                name: 'samplingMode',
                type: 'number',
                optional: true,
            },
            {
                name: 'engine',
                type: 'BabylonjsCoreEngine',
                optional: true,
            },
            {
                name: 'reusable',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'textureType',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberSubSurfaceScatteringPostProcess.Metadata = {
        className: 'FiberSubSurfaceScatteringPostProcess',
    };
    return FiberSubSurfaceScatteringPostProcess;
}());
var FiberGizmoPropsHandler = /** @class */ (function () {
    function FiberGizmoPropsHandler() {
    }
    FiberGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCoreGizmo.attachedMesh.
        // type: 'BabylonjsCoreNode' property (not coded) BabylonjsCoreGizmo.attachedNode.
        checkQuaternionDiff(oldProps.customRotationQuaternion, newProps.customRotationQuaternion, 'customRotationQuaternion', changedProps);
        // type: 'BabylonjsCoreUtilityLayerRenderer' property (not coded) BabylonjsCoreGizmo.gizmoLayer.
        checkPrimitiveDiff(oldProps.scaleRatio, newProps.scaleRatio, 'scaleRatio', changedProps);
        checkPrimitiveDiff(oldProps.updateGizmoPositionToMatchAttachedMesh, newProps.updateGizmoPositionToMatchAttachedMesh, 'updateGizmoPositionToMatchAttachedMesh', changedProps);
        checkPrimitiveDiff(oldProps.updateGizmoRotationToMatchAttachedMesh, newProps.updateGizmoRotationToMatchAttachedMesh, 'updateGizmoRotationToMatchAttachedMesh', changedProps);
        checkPrimitiveDiff(oldProps.updateScale, newProps.updateScale, 'updateScale', changedProps);
        checkMethodDiff(oldProps.setCustomMesh, newProps.setCustomMesh, 'setCustomMesh', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGizmoPropsHandler;
}());
/**
 * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
 *
 * This code has been generated
 */
var FiberGizmo = /** @class */ (function () {
    function FiberGizmo() {
        this.propsHandlers = [new FiberGizmoPropsHandler()];
    }
    FiberGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Gizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
        ],
    };
    FiberGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberGizmo',
    };
    return FiberGizmo;
}());
var FiberPlaneDragGizmoPropsHandler = /** @class */ (function () {
    function FiberPlaneDragGizmoPropsHandler() {
    }
    FiberPlaneDragGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCorePointerDragBehavior' property (not coded) BabylonjsCorePlaneDragGizmo.dragBehavior.
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkObservableDiff(oldProps.onSnapObservable, newProps.onSnapObservable, 'onSnapObservable', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPlaneDragGizmoPropsHandler;
}());
/**
 * Single plane drag gizmo
 *
 * This code has been generated
 */
var FiberPlaneDragGizmo = /** @class */ (function () {
    function FiberPlaneDragGizmo() {
        this.propsHandlers = [new FiberPlaneDragGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberPlaneDragGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPlaneDragGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPlaneDragGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PlaneDragGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'dragPlaneNormal',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'color',
                type: 'BabylonjsCoreColor3',
                optional: true,
            },
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'parent',
                type: 'BabylonjsCorePositionGizmo',
                optional: true,
            },
        ],
    };
    FiberPlaneDragGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberPlaneDragGizmo',
    };
    return FiberPlaneDragGizmo;
}());
var FiberPlaneRotationGizmoPropsHandler = /** @class */ (function () {
    function FiberPlaneRotationGizmoPropsHandler() {
    }
    FiberPlaneRotationGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.angle, newProps.angle, 'angle', changedProps);
        // type: 'BabylonjsCorePointerDragBehavior' property (not coded) BabylonjsCorePlaneRotationGizmo.dragBehavior.
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkObservableDiff(oldProps.onSnapObservable, newProps.onSnapObservable, 'onSnapObservable', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPlaneRotationGizmoPropsHandler;
}());
/**
 * Single plane rotation gizmo
 *
 * This code has been generated
 */
var FiberPlaneRotationGizmo = /** @class */ (function () {
    function FiberPlaneRotationGizmo() {
        this.propsHandlers = [new FiberPlaneRotationGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberPlaneRotationGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPlaneRotationGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPlaneRotationGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PlaneRotationGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'planeNormal',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'color',
                type: 'BabylonjsCoreColor3',
                optional: true,
            },
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'tessellation',
                type: 'number',
                optional: true,
            },
            {
                name: 'parent',
                type: 'BabylonjsCoreRotationGizmo',
                optional: true,
            },
            {
                name: 'useEulerRotation',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberPlaneRotationGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberPlaneRotationGizmo',
    };
    return FiberPlaneRotationGizmo;
}());
var FiberRotationGizmoPropsHandler = /** @class */ (function () {
    function FiberRotationGizmoPropsHandler() {
    }
    FiberRotationGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCoreRotationGizmo.attachedMesh.
        // type: 'BabylonjsCoreNode' property (not coded) BabylonjsCoreRotationGizmo.attachedNode.
        checkObservableDiff(oldProps.onDragEndObservable, newProps.onDragEndObservable, 'onDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onDragStartObservable, newProps.onDragStartObservable, 'onDragStartObservable', changedProps);
        checkPrimitiveDiff(oldProps.scaleRatio, newProps.scaleRatio, 'scaleRatio', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        checkPrimitiveDiff(oldProps.updateGizmoRotationToMatchAttachedMesh, newProps.updateGizmoRotationToMatchAttachedMesh, 'updateGizmoRotationToMatchAttachedMesh', changedProps);
        // type: 'BabylonjsCorePlaneRotationGizmo' property (not coded) BabylonjsCoreRotationGizmo.xGizmo.
        // type: 'BabylonjsCorePlaneRotationGizmo' property (not coded) BabylonjsCoreRotationGizmo.yGizmo.
        // type: 'BabylonjsCorePlaneRotationGizmo' property (not coded) BabylonjsCoreRotationGizmo.zGizmo.
        checkMethodDiff(oldProps.addToAxisCache, newProps.addToAxisCache, 'addToAxisCache', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberRotationGizmoPropsHandler;
}());
/**
 * Gizmo that enables rotating a mesh along 3 axis
 *
 * This code has been generated
 */
var FiberRotationGizmo = /** @class */ (function () {
    function FiberRotationGizmo() {
        this.propsHandlers = [new FiberRotationGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberRotationGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberRotationGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberRotationGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'RotationGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'tessellation',
                type: 'number',
                optional: true,
            },
            {
                name: 'useEulerRotation',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
            {
                name: 'gizmoManager',
                type: 'BabylonjsCoreGizmoManager',
                optional: true,
            },
            {
                name: 'options',
                type: 'BabylonjsCoreRotationGizmoOptions',
                optional: true,
            },
        ],
    };
    FiberRotationGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberRotationGizmo',
    };
    return FiberRotationGizmo;
}());
var FiberAxisScaleGizmoPropsHandler = /** @class */ (function () {
    function FiberAxisScaleGizmoPropsHandler() {
    }
    FiberAxisScaleGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCorePointerDragBehavior' property (not coded) BabylonjsCoreAxisScaleGizmo.dragBehavior.
        checkPrimitiveDiff(oldProps.dragScale, newProps.dragScale, 'dragScale', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkObservableDiff(oldProps.onSnapObservable, newProps.onSnapObservable, 'onSnapObservable', changedProps);
        checkPrimitiveDiff(oldProps.sensitivity, newProps.sensitivity, 'sensitivity', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        checkPrimitiveDiff(oldProps.uniformScaling, newProps.uniformScaling, 'uniformScaling', changedProps);
        checkMethodDiff(oldProps.setCustomMesh, newProps.setCustomMesh, 'setCustomMesh', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberAxisScaleGizmoPropsHandler;
}());
/**
 * Single axis scale gizmo
 *
 * This code has been generated
 */
var FiberAxisScaleGizmo = /** @class */ (function () {
    function FiberAxisScaleGizmo() {
        this.propsHandlers = [new FiberAxisScaleGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberAxisScaleGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAxisScaleGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAxisScaleGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AxisScaleGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'dragAxis',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'color',
                type: 'BabylonjsCoreColor3',
                optional: true,
            },
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'parent',
                type: 'BabylonjsCoreScaleGizmo',
                optional: true,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberAxisScaleGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberAxisScaleGizmo',
    };
    return FiberAxisScaleGizmo;
}());
var FiberScaleGizmoPropsHandler = /** @class */ (function () {
    function FiberScaleGizmoPropsHandler() {
    }
    FiberScaleGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCoreScaleGizmo.attachedMesh.
        // type: 'BabylonjsCoreNode' property (not coded) BabylonjsCoreScaleGizmo.attachedNode.
        checkObservableDiff(oldProps.onDragEndObservable, newProps.onDragEndObservable, 'onDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onDragStartObservable, newProps.onDragStartObservable, 'onDragStartObservable', changedProps);
        checkPrimitiveDiff(oldProps.scaleRatio, newProps.scaleRatio, 'scaleRatio', changedProps);
        checkPrimitiveDiff(oldProps.sensitivity, newProps.sensitivity, 'sensitivity', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        // type: 'BabylonjsCoreAxisScaleGizmo' property (not coded) BabylonjsCoreScaleGizmo.uniformScaleGizmo.
        checkPrimitiveDiff(oldProps.updateGizmoRotationToMatchAttachedMesh, newProps.updateGizmoRotationToMatchAttachedMesh, 'updateGizmoRotationToMatchAttachedMesh', changedProps);
        // type: 'BabylonjsCoreAxisScaleGizmo' property (not coded) BabylonjsCoreScaleGizmo.xGizmo.
        // type: 'BabylonjsCoreAxisScaleGizmo' property (not coded) BabylonjsCoreScaleGizmo.yGizmo.
        // type: 'BabylonjsCoreAxisScaleGizmo' property (not coded) BabylonjsCoreScaleGizmo.zGizmo.
        checkMethodDiff(oldProps.addToAxisCache, newProps.addToAxisCache, 'addToAxisCache', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScaleGizmoPropsHandler;
}());
/**
 * Gizmo that enables scaling a mesh along 3 axis
 *
 * This code has been generated
 */
var FiberScaleGizmo = /** @class */ (function () {
    function FiberScaleGizmo() {
        this.propsHandlers = [new FiberScaleGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberScaleGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberScaleGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberScaleGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ScaleGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
            {
                name: 'gizmoManager',
                type: 'BabylonjsCoreGizmoManager',
                optional: true,
            },
        ],
    };
    FiberScaleGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberScaleGizmo',
    };
    return FiberScaleGizmo;
}());
var FiberBoundingBoxGizmoPropsHandler = /** @class */ (function () {
    function FiberBoundingBoxGizmoPropsHandler() {
    }
    FiberBoundingBoxGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkVector3Diff(oldProps.axisFactor, newProps.axisFactor, 'axisFactor', changedProps);
        checkPrimitiveDiff(oldProps['axisFactor-x'], newProps['axisFactor-x'], 'axisFactor.x', changedProps);
        checkPrimitiveDiff(oldProps['axisFactor-y'], newProps['axisFactor-y'], 'axisFactor.y', changedProps);
        checkPrimitiveDiff(oldProps['axisFactor-z'], newProps['axisFactor-z'], 'axisFactor.z', changedProps);
        checkPrimitiveDiff(oldProps.fixedDragMeshBoundsSize, newProps.fixedDragMeshBoundsSize, 'fixedDragMeshBoundsSize', changedProps);
        checkPrimitiveDiff(oldProps.fixedDragMeshScreenSize, newProps.fixedDragMeshScreenSize, 'fixedDragMeshScreenSize', changedProps);
        checkPrimitiveDiff(oldProps.fixedDragMeshScreenSizeDistanceFactor, newProps.fixedDragMeshScreenSizeDistanceFactor, 'fixedDragMeshScreenSizeDistanceFactor', changedProps);
        checkPrimitiveDiff(oldProps.ignoreChildren, newProps.ignoreChildren, 'ignoreChildren', changedProps);
        checkLambdaDiff(oldProps.includeChildPredicate, newProps.includeChildPredicate, 'includeChildPredicate', changedProps);
        checkObservableDiff(oldProps.onDragStartObservable, newProps.onDragStartObservable, 'onDragStartObservable', changedProps);
        checkObservableDiff(oldProps.onRotationSphereDragEndObservable, newProps.onRotationSphereDragEndObservable, 'onRotationSphereDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onRotationSphereDragObservable, newProps.onRotationSphereDragObservable, 'onRotationSphereDragObservable', changedProps);
        checkObservableDiff(oldProps.onScaleBoxDragEndObservable, newProps.onScaleBoxDragEndObservable, 'onScaleBoxDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onScaleBoxDragObservable, newProps.onScaleBoxDragObservable, 'onScaleBoxDragObservable', changedProps);
        checkPrimitiveDiff(oldProps.rotationSphereSize, newProps.rotationSphereSize, 'rotationSphereSize', changedProps);
        checkPrimitiveDiff(oldProps.scaleBoxSize, newProps.scaleBoxSize, 'scaleBoxSize', changedProps);
        checkPrimitiveDiff(oldProps.scaleDragSpeed, newProps.scaleDragSpeed, 'scaleDragSpeed', changedProps);
        checkVector3Diff(oldProps.scalePivot, newProps.scalePivot, 'scalePivot', changedProps);
        checkPrimitiveDiff(oldProps['scalePivot-x'], newProps['scalePivot-x'], 'scalePivot.x', changedProps);
        checkPrimitiveDiff(oldProps['scalePivot-y'], newProps['scalePivot-y'], 'scalePivot.y', changedProps);
        checkPrimitiveDiff(oldProps['scalePivot-z'], newProps['scalePivot-z'], 'scalePivot.z', changedProps);
        checkMethodDiff(oldProps.setColor, newProps.setColor, 'setColor', changedProps);
        checkMethodDiff(oldProps.setEnabledRotationAxis, newProps.setEnabledRotationAxis, 'setEnabledRotationAxis', changedProps);
        checkMethodDiff(oldProps.setEnabledScaling, newProps.setEnabledScaling, 'setEnabledScaling', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBoundingBoxGizmoPropsHandler;
}());
/**
 * Bounding box gizmo
 *
 * This code has been generated
 */
var FiberBoundingBoxGizmo = /** @class */ (function () {
    function FiberBoundingBoxGizmo() {
        this.propsHandlers = [new FiberBoundingBoxGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberBoundingBoxGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBoundingBoxGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBoundingBoxGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BoundingBoxGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'color',
                type: 'BabylonjsCoreColor3',
                optional: true,
            },
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
        ],
    };
    FiberBoundingBoxGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberBoundingBoxGizmo',
    };
    return FiberBoundingBoxGizmo;
}());
var FiberPositionGizmoPropsHandler = /** @class */ (function () {
    function FiberPositionGizmoPropsHandler() {
    }
    FiberPositionGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCorePositionGizmo.attachedMesh.
        // type: 'BabylonjsCoreNode' property (not coded) BabylonjsCorePositionGizmo.attachedNode.
        checkObservableDiff(oldProps.onDragEndObservable, newProps.onDragEndObservable, 'onDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onDragStartObservable, newProps.onDragStartObservable, 'onDragStartObservable', changedProps);
        checkPrimitiveDiff(oldProps.planarGizmoEnabled, newProps.planarGizmoEnabled, 'planarGizmoEnabled', changedProps);
        checkPrimitiveDiff(oldProps.scaleRatio, newProps.scaleRatio, 'scaleRatio', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        checkPrimitiveDiff(oldProps.updateGizmoRotationToMatchAttachedMesh, newProps.updateGizmoRotationToMatchAttachedMesh, 'updateGizmoRotationToMatchAttachedMesh', changedProps);
        // type: 'BabylonjsCoreAxisDragGizmo' property (not coded) BabylonjsCorePositionGizmo.xGizmo.
        // type: 'BabylonjsCorePlaneDragGizmo' property (not coded) BabylonjsCorePositionGizmo.xPlaneGizmo.
        // type: 'BabylonjsCoreAxisDragGizmo' property (not coded) BabylonjsCorePositionGizmo.yGizmo.
        // type: 'BabylonjsCorePlaneDragGizmo' property (not coded) BabylonjsCorePositionGizmo.yPlaneGizmo.
        // type: 'BabylonjsCoreAxisDragGizmo' property (not coded) BabylonjsCorePositionGizmo.zGizmo.
        // type: 'BabylonjsCorePlaneDragGizmo' property (not coded) BabylonjsCorePositionGizmo.zPlaneGizmo.
        checkMethodDiff(oldProps.addToAxisCache, newProps.addToAxisCache, 'addToAxisCache', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPositionGizmoPropsHandler;
}());
/**
 * Gizmo that enables dragging a mesh along 3 axis
 *
 * This code has been generated
 */
var FiberPositionGizmo = /** @class */ (function () {
    function FiberPositionGizmo() {
        this.propsHandlers = [new FiberPositionGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberPositionGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPositionGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPositionGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PositionGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
            {
                name: 'gizmoManager',
                type: 'BabylonjsCoreGizmoManager',
                optional: true,
            },
        ],
    };
    FiberPositionGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberPositionGizmo',
    };
    return FiberPositionGizmo;
}());
var FiberAxisDragGizmoPropsHandler = /** @class */ (function () {
    function FiberAxisDragGizmoPropsHandler() {
    }
    FiberAxisDragGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCorePointerDragBehavior' property (not coded) BabylonjsCoreAxisDragGizmo.dragBehavior.
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkObservableDiff(oldProps.onSnapObservable, newProps.onSnapObservable, 'onSnapObservable', changedProps);
        checkPrimitiveDiff(oldProps.snapDistance, newProps.snapDistance, 'snapDistance', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberAxisDragGizmoPropsHandler;
}());
/**
 * Single axis drag gizmo
 *
 * This code has been generated
 */
var FiberAxisDragGizmo = /** @class */ (function () {
    function FiberAxisDragGizmo() {
        this.propsHandlers = [new FiberAxisDragGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberAxisDragGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAxisDragGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAxisDragGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AxisDragGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'dragAxis',
                type: 'BabylonjsCoreVector3',
                optional: false,
            },
            {
                name: 'color',
                type: 'BabylonjsCoreColor3',
                optional: true,
            },
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'parent',
                type: 'BabylonjsCorePositionGizmo',
                optional: true,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
        ],
    };
    FiberAxisDragGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberAxisDragGizmo',
    };
    return FiberAxisDragGizmo;
}());
var FiberLightGizmoPropsHandler = /** @class */ (function () {
    function FiberLightGizmoPropsHandler() {
    }
    FiberLightGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreNode' property (not coded) BabylonjsCoreLightGizmo.attachedNode.
        checkObjectDiff(oldProps.light, newProps.light, 'light', changedProps);
        checkObservableDiff(oldProps.onClickedObservable, newProps.onClickedObservable, 'onClickedObservable', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberLightGizmoPropsHandler;
}());
/**
 * Gizmo that enables viewing a light
 *
 * This code has been generated
 */
var FiberLightGizmo = /** @class */ (function () {
    function FiberLightGizmo() {
        this.propsHandlers = [new FiberLightGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberLightGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLightGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLightGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'LightGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
        ],
    };
    FiberLightGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberLightGizmo',
    };
    return FiberLightGizmo;
}());
var FiberCameraGizmoPropsHandler = /** @class */ (function () {
    function FiberCameraGizmoPropsHandler() {
    }
    FiberCameraGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreCameraGizmo.camera.
        checkPrimitiveDiff(oldProps.displayFrustum, newProps.displayFrustum, 'displayFrustum', changedProps);
        checkObservableDiff(oldProps.onClickedObservable, newProps.onClickedObservable, 'onClickedObservable', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCameraGizmoPropsHandler;
}());
/**
 * Gizmo that enables viewing a camera
 *
 * This code has been generated
 */
var FiberCameraGizmo = /** @class */ (function () {
    function FiberCameraGizmo() {
        this.propsHandlers = [new FiberCameraGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberCameraGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCameraGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCameraGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'CameraGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'gizmoLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
        ],
    };
    FiberCameraGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberCameraGizmo',
    };
    return FiberCameraGizmo;
}());
var FiberSlateGizmoPropsHandler = /** @class */ (function () {
    function FiberSlateGizmoPropsHandler() {
    }
    FiberSlateGizmoPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsGuiHolographicSlate' property (not coded) BabylonjsGuiSlateGizmo.attachedSlate.
        checkPrimitiveDiff(oldProps.fixedScreenSize, newProps.fixedScreenSize, 'fixedScreenSize', changedProps);
        checkPrimitiveDiff(oldProps.fixedScreenSizeDistanceFactor, newProps.fixedScreenSizeDistanceFactor, 'fixedScreenSizeDistanceFactor', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSlateGizmoPropsHandler;
}());
/**
 * Gizmo to resize 2D slates
 *
 * This code has been generated
 */
var FiberSlateGizmo = /** @class */ (function () {
    function FiberSlateGizmo() {
        this.propsHandlers = [new FiberSlateGizmoPropsHandler(), new FiberGizmoPropsHandler()];
    }
    FiberSlateGizmo.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSlateGizmo.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSlateGizmo.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SlateGizmo',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'utilityLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
        ],
    };
    FiberSlateGizmo.Metadata = {
        isGizmo: true,
        className: 'FiberSlateGizmo',
    };
    return FiberSlateGizmo;
}());
var FiberGUI3DManagerPropsHandler = /** @class */ (function () {
    function FiberGUI3DManagerPropsHandler() {
    }
    FiberGUI3DManagerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.controlScaling, newProps.controlScaling, 'controlScaling', changedProps);
        checkObservableDiff(oldProps.onPickedPointChangedObservable, newProps.onPickedPointChangedObservable, 'onPickedPointChangedObservable', changedProps);
        checkObservableDiff(oldProps.onPickingObservable, newProps.onPickingObservable, 'onPickingObservable', changedProps);
        checkPrimitiveDiff(oldProps.useRealisticScaling, newProps.useRealisticScaling, 'useRealisticScaling', changedProps);
        checkMethodDiff(oldProps.addControl, newProps.addControl, 'addControl', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGUI3DManagerPropsHandler;
}());
/**
 * Class used to manage 3D user interface
 *
 * This code has been generated
 */
var FiberGUI3DManager = /** @class */ (function () {
    function FiberGUI3DManager() {
        this.propsHandlers = [new FiberGUI3DManagerPropsHandler()];
    }
    FiberGUI3DManager.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGUI3DManager.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGUI3DManager.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GUI3DManager',
        namespace: '@babylonjs/gui',
        parameters: [
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberGUI3DManager.Metadata = {
        isGUI3DControl: true,
        className: 'FiberGUI3DManager',
    };
    return FiberGUI3DManager;
}());
var FiberEnvironmentHelperPropsHandler = /** @class */ (function () {
    function FiberEnvironmentHelperPropsHandler() {
    }
    FiberEnvironmentHelperPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkObservableDiff(oldProps.onErrorObservable, newProps.onErrorObservable, 'onErrorObservable', changedProps);
        checkMethodDiff(oldProps.setMainColor, newProps.setMainColor, 'setMainColor', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberEnvironmentHelperPropsHandler;
}());
/**
 * The Environment helper class can be used to add a fully featured none expensive background to your scene.
 * It includes by default a skybox and a ground relying on the BackgroundMaterial.
 * It also helps with the default setup of your imageProcessing configuration.
 *
 * This code has been generated
 */
var FiberEnvironmentHelper = /** @class */ (function () {
    function FiberEnvironmentHelper() {
        this.propsHandlers = [new FiberEnvironmentHelperPropsHandler()];
    }
    FiberEnvironmentHelper.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberEnvironmentHelper.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberEnvironmentHelper.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'EnvironmentHelper',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'options',
                type: 'Partial<BabylonjsCoreIEnvironmentHelperOptions>',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
        ],
    };
    FiberEnvironmentHelper.Metadata = {
        isEnvironment: true,
        className: 'FiberEnvironmentHelper',
    };
    return FiberEnvironmentHelper;
}());
var FiberPhysicsImpostorPropsHandler = /** @class */ (function () {
    function FiberPhysicsImpostorPropsHandler() {
    }
    FiberPhysicsImpostorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkLambdaDiff(oldProps.afterStep, newProps.afterStep, 'afterStep', changedProps);
        checkLambdaDiff(oldProps.beforeStep, newProps.beforeStep, 'beforeStep', changedProps);
        checkPrimitiveDiff(oldProps.friction, newProps.friction, 'friction', changedProps);
        checkPrimitiveDiff(oldProps.mass, newProps.mass, 'mass', changedProps);
        // type: 'BabylonjsCoreIPhysicsEnabledObject' property (not coded) BabylonjsCorePhysicsImpostor.object.
        checkLambdaDiff(oldProps.onCollide, newProps.onCollide, 'onCollide', changedProps);
        checkLambdaDiff(oldProps.onCollideEvent, newProps.onCollideEvent, 'onCollideEvent', changedProps);
        // type: 'BabylonjsCorePhysicsImpostor' property (not coded) BabylonjsCorePhysicsImpostor.parent.
        // type: 'any' property (not coded) BabylonjsCorePhysicsImpostor.physicsBody.
        checkPrimitiveDiff(oldProps.positionIterations, newProps.positionIterations, 'positionIterations', changedProps);
        checkPrimitiveDiff(oldProps.pressure, newProps.pressure, 'pressure', changedProps);
        checkPrimitiveDiff(oldProps.restitution, newProps.restitution, 'restitution', changedProps);
        checkPrimitiveDiff(oldProps.segments, newProps.segments, 'segments', changedProps);
        checkPrimitiveDiff(oldProps.soft, newProps.soft, 'soft', changedProps);
        checkPrimitiveDiff(oldProps.stiffness, newProps.stiffness, 'stiffness', changedProps);
        checkPrimitiveDiff(oldProps.type, newProps.type, 'type', changedProps);
        checkPrimitiveDiff(oldProps.uniqueId, newProps.uniqueId, 'uniqueId', changedProps);
        checkPrimitiveDiff(oldProps.velocityIterations, newProps.velocityIterations, 'velocityIterations', changedProps);
        checkMethodDiff(oldProps.addAnchor, newProps.addAnchor, 'addAnchor', changedProps);
        checkMethodDiff(oldProps.addHook, newProps.addHook, 'addHook', changedProps);
        checkMethodDiff(oldProps.addJoint, newProps.addJoint, 'addJoint', changedProps);
        checkMethodDiff(oldProps.setAngularVelocity, newProps.setAngularVelocity, 'setAngularVelocity', changedProps);
        checkMethodDiff(oldProps.setDeltaPosition, newProps.setDeltaPosition, 'setDeltaPosition', changedProps);
        checkMethodDiff(oldProps.setDeltaRotation, newProps.setDeltaRotation, 'setDeltaRotation', changedProps);
        checkMethodDiff(oldProps.setLinearVelocity, newProps.setLinearVelocity, 'setLinearVelocity', changedProps);
        checkMethodDiff(oldProps.setMass, newProps.setMass, 'setMass', changedProps);
        checkMethodDiff(oldProps.setParam, newProps.setParam, 'setParam', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPhysicsImpostorPropsHandler;
}());
/**
 * Represents a physics imposter
 *
 * This code has been generated
 */
var FiberPhysicsImpostor = /** @class */ (function () {
    function FiberPhysicsImpostor() {
        this.propsHandlers = [new FiberPhysicsImpostorPropsHandler()];
    }
    FiberPhysicsImpostor.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPhysicsImpostor.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPhysicsImpostor.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PhysicsImpostor',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'object',
                type: 'BabylonjsCoreIPhysicsEnabledObject',
                optional: true,
            },
            {
                name: 'type',
                type: 'number',
                optional: false,
            },
            {
                name: '_options',
                type: 'BabylonjsCorePhysicsImpostorParameters',
                optional: true,
            },
            {
                name: '_scene',
                type: 'BabylonjsCoreScene',
                optional: true,
            },
        ],
    };
    FiberPhysicsImpostor.Metadata = {
        delayCreation: true,
        className: 'FiberPhysicsImpostor',
    };
    return FiberPhysicsImpostor;
}());
var FiberVRExperienceHelperPropsHandler = /** @class */ (function () {
    function FiberVRExperienceHelperPropsHandler() {
    }
    FiberVRExperienceHelperPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.displayGaze, newProps.displayGaze, 'displayGaze', changedProps);
        checkPrimitiveDiff(oldProps.displayLaserPointer, newProps.displayLaserPointer, 'displayLaserPointer', changedProps);
        checkPrimitiveDiff(oldProps.enableGazeEvenWhenNoPointerLock, newProps.enableGazeEvenWhenNoPointerLock, 'enableGazeEvenWhenNoPointerLock', changedProps);
        checkPrimitiveDiff(oldProps.exitVROnDoubleTap, newProps.exitVROnDoubleTap, 'exitVROnDoubleTap', changedProps);
        // type: 'BabylonjsCoreMesh' property (not coded) BabylonjsCoreVRExperienceHelper.gazeTrackerMesh.
        checkLambdaDiff(oldProps.meshSelectionPredicate, newProps.meshSelectionPredicate, 'meshSelectionPredicate', changedProps);
        checkObservableDiff(oldProps.onAfterCameraTeleport, newProps.onAfterCameraTeleport, 'onAfterCameraTeleport', changedProps);
        checkObservableDiff(oldProps.onAfterEnteringVRObservable, newProps.onAfterEnteringVRObservable, 'onAfterEnteringVRObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeCameraTeleport, newProps.onBeforeCameraTeleport, 'onBeforeCameraTeleport', changedProps);
        checkObservableDiff(oldProps.onControllerMeshLoadedObservable, newProps.onControllerMeshLoadedObservable, 'onControllerMeshLoadedObservable', changedProps);
        checkObservableDiff(oldProps.onEnteringVRObservable, newProps.onEnteringVRObservable, 'onEnteringVRObservable', changedProps);
        checkObservableDiff(oldProps.onExitingVRObservable, newProps.onExitingVRObservable, 'onExitingVRObservable', changedProps);
        checkObservableDiff(oldProps.onMeshSelectedWithController, newProps.onMeshSelectedWithController, 'onMeshSelectedWithController', changedProps);
        checkObservableDiff(oldProps.onNewMeshPicked, newProps.onNewMeshPicked, 'onNewMeshPicked', changedProps);
        checkObservableDiff(oldProps.onNewMeshSelected, newProps.onNewMeshSelected, 'onNewMeshSelected', changedProps);
        checkObservableDiff(oldProps.onSelectedMeshUnselected, newProps.onSelectedMeshUnselected, 'onSelectedMeshUnselected', changedProps);
        checkVector3Diff(oldProps.position, newProps.position, 'position', changedProps);
        checkPrimitiveDiff(oldProps['position-x'], newProps['position-x'], 'position.x', changedProps);
        checkPrimitiveDiff(oldProps['position-y'], newProps['position-y'], 'position.y', changedProps);
        checkPrimitiveDiff(oldProps['position-z'], newProps['position-z'], 'position.z', changedProps);
        checkLambdaDiff(oldProps.raySelectionPredicate, newProps.raySelectionPredicate, 'raySelectionPredicate', changedProps);
        checkPrimitiveDiff(oldProps.requestPointerLockOnFullScreen, newProps.requestPointerLockOnFullScreen, 'requestPointerLockOnFullScreen', changedProps);
        checkPrimitiveDiff(oldProps.teleportationEnabled, newProps.teleportationEnabled, 'teleportationEnabled', changedProps);
        // type: 'BabylonjsCoreMesh' property (not coded) BabylonjsCoreVRExperienceHelper.teleportationTarget.
        checkPrimitiveDiff(oldProps.updateControllerLaserColor, newProps.updateControllerLaserColor, 'updateControllerLaserColor', changedProps);
        checkPrimitiveDiff(oldProps.updateGazeTrackerColor, newProps.updateGazeTrackerColor, 'updateGazeTrackerColor', changedProps);
        checkPrimitiveDiff(oldProps.updateGazeTrackerScale, newProps.updateGazeTrackerScale, 'updateGazeTrackerScale', changedProps);
        // type: 'BabylonjsCoreVRExperienceHelperOptions' property (not coded) BabylonjsCoreVRExperienceHelper.webVROptions.
        // type: 'BabylonjsCoreWebXRDefaultExperience' property (not coded) BabylonjsCoreVRExperienceHelper.xr.
        checkPrimitiveDiff(oldProps.xrTestDone, newProps.xrTestDone, 'xrTestDone', changedProps);
        checkMethodDiff(oldProps.addFloorMesh, newProps.addFloorMesh, 'addFloorMesh', changedProps);
        checkMethodDiff(oldProps.enableTeleportation, newProps.enableTeleportation, 'enableTeleportation', changedProps);
        checkMethodDiff(oldProps.setGazeColor, newProps.setGazeColor, 'setGazeColor', changedProps);
        checkMethodDiff(oldProps.setLaserColor, newProps.setLaserColor, 'setLaserColor', changedProps);
        checkMethodDiff(oldProps.setLaserLightingState, newProps.setLaserLightingState, 'setLaserLightingState', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberVRExperienceHelperPropsHandler;
}());
/**
 * Helps to quickly add VR support to an existing scene.
 * See https://doc.babylonjs.com/divingDeeper/cameras/webVRHelper
 *
 * This code has been generated
 */
var FiberVRExperienceHelper = /** @class */ (function () {
    function FiberVRExperienceHelper() {
        this.propsHandlers = [new FiberVRExperienceHelperPropsHandler()];
    }
    FiberVRExperienceHelper.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberVRExperienceHelper.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberVRExperienceHelper.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'VRExperienceHelper',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'webVROptions',
                type: 'BabylonjsCoreVRExperienceHelperOptions',
                optional: true,
            },
        ],
    };
    FiberVRExperienceHelper.Metadata = {
        className: 'FiberVRExperienceHelper',
    };
    return FiberVRExperienceHelper;
}());
var FiberDynamicTerrainPropsHandler = /** @class */ (function () {
    function FiberDynamicTerrainPropsHandler() {
    }
    FiberDynamicTerrainPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreCamera' property (not coded) ExtensionsDynamicTerrain.camera.
        checkPrimitiveDiff(oldProps.cameraLODCorrection, newProps.cameraLODCorrection, 'cameraLODCorrection', changedProps);
        checkPrimitiveDiff(oldProps.computeNormals, newProps.computeNormals, 'computeNormals', changedProps);
        checkPrimitiveDiff(oldProps.initialLOD, newProps.initialLOD, 'initialLOD', changedProps);
        checkPrimitiveDiff(oldProps.isAlwaysVisible, newProps.isAlwaysVisible, 'isAlwaysVisible', changedProps);
        checkNumericArrayDiff(oldProps.LODLimits, newProps.LODLimits, 'LODLimits', changedProps);
        checkPrimitiveDiff(oldProps.LODNegativeX, newProps.LODNegativeX, 'LODNegativeX', changedProps);
        checkPrimitiveDiff(oldProps.LODNegativeZ, newProps.LODNegativeZ, 'LODNegativeZ', changedProps);
        checkPrimitiveDiff(oldProps.LODPositiveX, newProps.LODPositiveX, 'LODPositiveX', changedProps);
        checkPrimitiveDiff(oldProps.LODPositiveZ, newProps.LODPositiveZ, 'LODPositiveZ', changedProps);
        // type: 'number[] | Float32Array' property (not coded) ExtensionsDynamicTerrain.mapColors.
        // type: 'number[] | Float32Array' property (not coded) ExtensionsDynamicTerrain.mapData.
        // type: 'number[] | Float32Array' property (not coded) ExtensionsDynamicTerrain.mapNormals.
        checkPrimitiveDiff(oldProps.mapSubX, newProps.mapSubX, 'mapSubX', changedProps);
        checkPrimitiveDiff(oldProps.mapSubZ, newProps.mapSubZ, 'mapSubZ', changedProps);
        // type: 'number[] | Float32Array' property (not coded) ExtensionsDynamicTerrain.mapUVs.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.precomputeNormalsFromMap, newProps.precomputeNormalsFromMap, 'precomputeNormalsFromMap', changedProps);
        checkPrimitiveDiff(oldProps.refreshEveryFrame, newProps.refreshEveryFrame, 'refreshEveryFrame', changedProps);
        // type: '{ x: number; z: number; }' property (not coded) ExtensionsDynamicTerrain.shiftFromCamera.
        checkPrimitiveDiff(oldProps.subToleranceX, newProps.subToleranceX, 'subToleranceX', changedProps);
        checkPrimitiveDiff(oldProps.subToleranceZ, newProps.subToleranceZ, 'subToleranceZ', changedProps);
        checkPrimitiveDiff(oldProps.useCustomVertexFunction, newProps.useCustomVertexFunction, 'useCustomVertexFunction', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDynamicTerrainPropsHandler;
}());
/** This code has been generated */
var FiberDynamicTerrain = /** @class */ (function () {
    function FiberDynamicTerrain() {
        this.propsHandlers = [new FiberDynamicTerrainPropsHandler()];
    }
    FiberDynamicTerrain.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDynamicTerrain.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDynamicTerrain.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DynamicTerrain',
        namespace: './extensions/DynamicTerrain',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'terrainSub',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'mapData',
                        type: 'number[] | Float32Array',
                        optional: true,
                    },
                    {
                        name: 'mapSubX',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'mapSubZ',
                        type: 'number',
                        optional: true,
                    },
                    {
                        name: 'mapUVs',
                        type: 'number[] | Float32Array',
                        optional: true,
                    },
                    {
                        name: 'mapColors',
                        type: 'number[] | Float32Array',
                        optional: true,
                    },
                    {
                        name: 'mapNormals',
                        type: 'number[] | Float32Array',
                        optional: true,
                    },
                    {
                        name: 'invertSide',
                        type: 'boolean',
                        optional: true,
                    },
                    {
                        name: 'camera',
                        type: 'BabylonjsCoreCamera',
                        optional: true,
                    },
                    {
                        name: 'SPmapData',
                        type: 'number[][] | Float32Array[]',
                        optional: true,
                    },
                    {
                        name: 'sps',
                        type: 'BabylonjsCoreSolidParticleSystem',
                        optional: true,
                    },
                    {
                        name: 'SPcolorData',
                        type: 'number[][] | Float32Array[]',
                        optional: true,
                    },
                    {
                        name: 'SPuvData',
                        type: 'number[][] | Float32Array[]',
                        optional: true,
                    },
                    {
                        name: 'intializedCallback',
                        type: 'any',
                        optional: true,
                    },
                ],
                optional: true,
            },
        ],
    };
    FiberDynamicTerrain.Metadata = {
        acceptsMaterials: true,
        className: 'FiberDynamicTerrain',
    };
    return FiberDynamicTerrain;
}());
var FiberPointsCloudSystemPropsHandler = /** @class */ (function () {
    function FiberPointsCloudSystemPropsHandler() {
    }
    FiberPointsCloudSystemPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.computeBoundingBox, newProps.computeBoundingBox, 'computeBoundingBox', changedProps);
        checkPrimitiveDiff(oldProps.computeParticleColor, newProps.computeParticleColor, 'computeParticleColor', changedProps);
        checkPrimitiveDiff(oldProps.computeParticleRotation, newProps.computeParticleRotation, 'computeParticleRotation', changedProps);
        checkPrimitiveDiff(oldProps.computeParticleTexture, newProps.computeParticleTexture, 'computeParticleTexture', changedProps);
        checkPrimitiveDiff(oldProps.counter, newProps.counter, 'counter', changedProps);
        checkPrimitiveDiff(oldProps.isAlwaysVisible, newProps.isAlwaysVisible, 'isAlwaysVisible', changedProps);
        // type: 'BabylonjsCoreMesh' property (not coded) BabylonjsCorePointsCloudSystem.mesh.
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.nbParticles, newProps.nbParticles, 'nbParticles', changedProps);
        // type: 'BabylonjsCoreCloudPoint[]' property (not coded) BabylonjsCorePointsCloudSystem.particles.
        // type: 'any' property (not coded) BabylonjsCorePointsCloudSystem.vars.
        checkMethodDiff(oldProps.addPoints, newProps.addPoints, 'addPoints', changedProps);
        checkMethodDiff(oldProps.addSurfacePoints, newProps.addSurfacePoints, 'addSurfacePoints', changedProps);
        checkMethodDiff(oldProps.addVolumePoints, newProps.addVolumePoints, 'addVolumePoints', changedProps);
        checkMethodDiff(oldProps.setParticles, newProps.setParticles, 'setParticles', changedProps);
        checkMethodDiff(oldProps.setVisibilityBox, newProps.setVisibilityBox, 'setVisibilityBox', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPointsCloudSystemPropsHandler;
}());
/**
 * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.
 * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
 *
 * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.
 * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
 *
 * Full documentation here : TO BE ENTERED
 *
 * This code has been generated
 */
var FiberPointsCloudSystem = /** @class */ (function () {
    function FiberPointsCloudSystem() {
        this.propsHandlers = [new FiberPointsCloudSystemPropsHandler()];
    }
    FiberPointsCloudSystem.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPointsCloudSystem.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPointsCloudSystem.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PointsCloudSystem',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'pointSize',
                type: 'number',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'options',
                type: [
                    {
                        name: 'updatable',
                        type: 'boolean',
                        optional: true,
                    },
                ],
                optional: true,
            },
        ],
    };
    FiberPointsCloudSystem.Metadata = {
        className: 'FiberPointsCloudSystem',
    };
    return FiberPointsCloudSystem;
}());
var FiberViewportPropsHandler = /** @class */ (function () {
    function FiberViewportPropsHandler() {
    }
    FiberViewportPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.height, newProps.height, 'height', changedProps);
        checkPrimitiveDiff(oldProps.width, newProps.width, 'width', changedProps);
        checkPrimitiveDiff(oldProps.x, newProps.x, 'x', changedProps);
        checkPrimitiveDiff(oldProps.y, newProps.y, 'y', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberViewportPropsHandler;
}());
/**
 * Class used to represent a viewport on screen
 *
 * This code has been generated
 */
var FiberViewport = /** @class */ (function () {
    function FiberViewport() {
        this.propsHandlers = [new FiberViewportPropsHandler()];
    }
    FiberViewport.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberViewport.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberViewport.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Viewport',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'x',
                type: 'number',
                optional: false,
            },
            {
                name: 'y',
                type: 'number',
                optional: false,
            },
            {
                name: 'width',
                type: 'number',
                optional: false,
            },
            {
                name: 'height',
                type: 'number',
                optional: false,
            },
        ],
    };
    FiberViewport.Metadata = {
        className: 'FiberViewport',
    };
    return FiberViewport;
}());
var FiberUtilityLayerRendererPropsHandler = /** @class */ (function () {
    function FiberUtilityLayerRendererPropsHandler() {
    }
    FiberUtilityLayerRendererPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkLambdaDiff(oldProps.mainSceneTrackerPredicate, newProps.mainSceneTrackerPredicate, 'mainSceneTrackerPredicate', changedProps);
        checkPrimitiveDiff(oldProps.onlyCheckPointerDownEvents, newProps.onlyCheckPointerDownEvents, 'onlyCheckPointerDownEvents', changedProps);
        checkObservableDiff(oldProps.onPointerOutObservable, newProps.onPointerOutObservable, 'onPointerOutObservable', changedProps);
        // type: 'BabylonjsCoreScene' property (not coded) BabylonjsCoreUtilityLayerRenderer.originalScene.
        checkPrimitiveDiff(oldProps.pickingEnabled, newProps.pickingEnabled, 'pickingEnabled', changedProps);
        checkPrimitiveDiff(oldProps.pickUtilitySceneFirst, newProps.pickUtilitySceneFirst, 'pickUtilitySceneFirst', changedProps);
        checkPrimitiveDiff(oldProps.processAllEvents, newProps.processAllEvents, 'processAllEvents', changedProps);
        checkPrimitiveDiff(oldProps.shouldRender, newProps.shouldRender, 'shouldRender', changedProps);
        // type: 'BabylonjsCoreScene' property (not coded) BabylonjsCoreUtilityLayerRenderer.utilityLayerScene.
        checkMethodDiff(oldProps.setRenderCamera, newProps.setRenderCamera, 'setRenderCamera', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberUtilityLayerRendererPropsHandler;
}());
/**
 * Renders a layer on top of an existing scene
 *
 * This code has been generated
 */
var FiberUtilityLayerRenderer = /** @class */ (function () {
    function FiberUtilityLayerRenderer() {
        this.propsHandlers = [new FiberUtilityLayerRendererPropsHandler()];
    }
    FiberUtilityLayerRenderer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberUtilityLayerRenderer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberUtilityLayerRenderer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'UtilityLayerRenderer',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'originalScene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'handleEvents',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberUtilityLayerRenderer.Metadata = {
        isUtilityLayerRenderer: true,
        className: 'FiberUtilityLayerRenderer',
    };
    return FiberUtilityLayerRenderer;
}());
var FiberMaterialPluginBasePropsHandler = /** @class */ (function () {
    function FiberMaterialPluginBasePropsHandler() {
    }
    FiberMaterialPluginBasePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        checkPrimitiveDiff(oldProps.priority, newProps.priority, 'priority', changedProps);
        checkPrimitiveDiff(oldProps.registerForExtraEvents, newProps.registerForExtraEvents, 'registerForExtraEvents', changedProps);
        checkMethodDiff(oldProps.addFallbacks, newProps.addFallbacks, 'addFallbacks', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberMaterialPluginBasePropsHandler;
}());
/**
 * Base class for material plugins.
 *
 * This code has been generated
 */
var FiberMaterialPluginBase = /** @class */ (function () {
    function FiberMaterialPluginBase() {
        this.propsHandlers = [new FiberMaterialPluginBasePropsHandler()];
    }
    FiberMaterialPluginBase.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMaterialPluginBase.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMaterialPluginBase.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MaterialPluginBase',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCoreMaterial',
                optional: false,
            },
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'priority',
                type: 'number',
                optional: false,
            },
            {
                name: 'defines',
                type: '{ [key: string]: any; }',
                optional: true,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'enable',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberMaterialPluginBase.Metadata = {
        className: 'FiberMaterialPluginBase',
    };
    return FiberMaterialPluginBase;
}());
var FiberShadowGeneratorPropsHandler = /** @class */ (function () {
    function FiberShadowGeneratorPropsHandler() {
    }
    FiberShadowGeneratorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.bias, newProps.bias, 'bias', changedProps);
        checkPrimitiveDiff(oldProps.blurBoxOffset, newProps.blurBoxOffset, 'blurBoxOffset', changedProps);
        checkPrimitiveDiff(oldProps.blurKernel, newProps.blurKernel, 'blurKernel', changedProps);
        checkPrimitiveDiff(oldProps.blurScale, newProps.blurScale, 'blurScale', changedProps);
        checkPrimitiveDiff(oldProps.contactHardeningLightSizeUVRatio, newProps.contactHardeningLightSizeUVRatio, 'contactHardeningLightSizeUVRatio', changedProps);
        checkLambdaDiff(oldProps.customAllowRendering, newProps.customAllowRendering, 'customAllowRendering', changedProps);
        // type: 'BabylonjsCoreICustomShaderOptions' property (not coded) BabylonjsCoreShadowGenerator.customShaderOptions.
        checkPrimitiveDiff(oldProps.darkness, newProps.darkness, 'darkness', changedProps);
        checkPrimitiveDiff(oldProps.depthScale, newProps.depthScale, 'depthScale', changedProps);
        checkPrimitiveDiff(oldProps.enableSoftTransparentShadow, newProps.enableSoftTransparentShadow, 'enableSoftTransparentShadow', changedProps);
        checkPrimitiveDiff(oldProps.filter, newProps.filter, 'filter', changedProps);
        checkPrimitiveDiff(oldProps.filteringQuality, newProps.filteringQuality, 'filteringQuality', changedProps);
        checkPrimitiveDiff(oldProps.forceBackFacesOnly, newProps.forceBackFacesOnly, 'forceBackFacesOnly', changedProps);
        checkPrimitiveDiff(oldProps.frustumEdgeFalloff, newProps.frustumEdgeFalloff, 'frustumEdgeFalloff', changedProps);
        checkPrimitiveDiff(oldProps.id, newProps.id, 'id', changedProps);
        checkPrimitiveDiff(oldProps.mapSize, newProps.mapSize, 'mapSize', changedProps);
        checkPrimitiveDiff(oldProps.normalBias, newProps.normalBias, 'normalBias', changedProps);
        checkObservableDiff(oldProps.onAfterShadowMapRenderMeshObservable, newProps.onAfterShadowMapRenderMeshObservable, 'onAfterShadowMapRenderMeshObservable', changedProps);
        checkObservableDiff(oldProps.onAfterShadowMapRenderObservable, newProps.onAfterShadowMapRenderObservable, 'onAfterShadowMapRenderObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeShadowMapRenderMeshObservable, newProps.onBeforeShadowMapRenderMeshObservable, 'onBeforeShadowMapRenderMeshObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeShadowMapRenderObservable, newProps.onBeforeShadowMapRenderObservable, 'onBeforeShadowMapRenderObservable', changedProps);
        checkPrimitiveDiff(oldProps.transparencyShadow, newProps.transparencyShadow, 'transparencyShadow', changedProps);
        checkPrimitiveDiff(oldProps.useBlurCloseExponentialShadowMap, newProps.useBlurCloseExponentialShadowMap, 'useBlurCloseExponentialShadowMap', changedProps);
        checkPrimitiveDiff(oldProps.useBlurExponentialShadowMap, newProps.useBlurExponentialShadowMap, 'useBlurExponentialShadowMap', changedProps);
        checkPrimitiveDiff(oldProps.useCloseExponentialShadowMap, newProps.useCloseExponentialShadowMap, 'useCloseExponentialShadowMap', changedProps);
        checkPrimitiveDiff(oldProps.useContactHardeningShadow, newProps.useContactHardeningShadow, 'useContactHardeningShadow', changedProps);
        checkPrimitiveDiff(oldProps.useExponentialShadowMap, newProps.useExponentialShadowMap, 'useExponentialShadowMap', changedProps);
        checkPrimitiveDiff(oldProps.useKernelBlur, newProps.useKernelBlur, 'useKernelBlur', changedProps);
        checkPrimitiveDiff(oldProps.usePercentageCloserFiltering, newProps.usePercentageCloserFiltering, 'usePercentageCloserFiltering', changedProps);
        checkPrimitiveDiff(oldProps.usePoissonSampling, newProps.usePoissonSampling, 'usePoissonSampling', changedProps);
        checkMethodDiff(oldProps.addShadowCaster, newProps.addShadowCaster, 'addShadowCaster', changedProps);
        checkMethodDiff(oldProps.setDarkness, newProps.setDarkness, 'setDarkness', changedProps);
        checkMethodDiff(oldProps.setTransparencyShadow, newProps.setTransparencyShadow, 'setTransparencyShadow', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberShadowGeneratorPropsHandler;
}());
/**
 * Default implementation IShadowGenerator.
 * This is the main object responsible of generating shadows in the framework.
 * Documentation: https://doc.babylonjs.com/babylon101/shadows
 *
 * This code has been generated
 */
var FiberShadowGenerator = /** @class */ (function () {
    function FiberShadowGenerator() {
        this.propsHandlers = [new FiberShadowGeneratorPropsHandler()];
    }
    FiberShadowGenerator.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberShadowGenerator.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberShadowGenerator.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ShadowGenerator',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'mapSize',
                type: 'number',
                optional: false,
            },
            {
                name: 'light',
                type: 'BabylonjsCoreIShadowLight',
                optional: true,
            },
            {
                name: 'usefullFloatFirst',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberShadowGenerator.Metadata = {
        delayCreation: true,
        isShadowGenerator: true,
        className: 'FiberShadowGenerator',
    };
    return FiberShadowGenerator;
}());
var FiberCascadedShadowGeneratorPropsHandler = /** @class */ (function () {
    function FiberCascadedShadowGeneratorPropsHandler() {
    }
    FiberCascadedShadowGeneratorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.autoCalcDepthBounds, newProps.autoCalcDepthBounds, 'autoCalcDepthBounds', changedProps);
        checkPrimitiveDiff(oldProps.autoCalcDepthBoundsRefreshRate, newProps.autoCalcDepthBoundsRefreshRate, 'autoCalcDepthBoundsRefreshRate', changedProps);
        checkPrimitiveDiff(oldProps.cascadeBlendPercentage, newProps.cascadeBlendPercentage, 'cascadeBlendPercentage', changedProps);
        checkPrimitiveDiff(oldProps.debug, newProps.debug, 'debug', changedProps);
        checkPrimitiveDiff(oldProps.depthClamp, newProps.depthClamp, 'depthClamp', changedProps);
        checkPrimitiveDiff(oldProps.freezeShadowCastersBoundingInfo, newProps.freezeShadowCastersBoundingInfo, 'freezeShadowCastersBoundingInfo', changedProps);
        checkPrimitiveDiff(oldProps.lambda, newProps.lambda, 'lambda', changedProps);
        checkPrimitiveDiff(oldProps.numCascades, newProps.numCascades, 'numCascades', changedProps);
        checkPrimitiveDiff(oldProps.penumbraDarkness, newProps.penumbraDarkness, 'penumbraDarkness', changedProps);
        // type: 'BabylonjsCoreBoundingInfo' property (not coded) BabylonjsCoreCascadedShadowGenerator.shadowCastersBoundingInfo.
        checkPrimitiveDiff(oldProps.shadowMaxZ, newProps.shadowMaxZ, 'shadowMaxZ', changedProps);
        checkPrimitiveDiff(oldProps.stabilizeCascades, newProps.stabilizeCascades, 'stabilizeCascades', changedProps);
        checkMethodDiff(oldProps.setDepthRenderer, newProps.setDepthRenderer, 'setDepthRenderer', changedProps);
        checkMethodDiff(oldProps.setMinMaxDistance, newProps.setMinMaxDistance, 'setMinMaxDistance', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberCascadedShadowGeneratorPropsHandler;
}());
/**
 * A CSM implementation allowing casting shadows on large scenes.
 * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
 * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/
 *
 * This code has been generated
 */
var FiberCascadedShadowGenerator = /** @class */ (function () {
    function FiberCascadedShadowGenerator() {
        this.propsHandlers = [
            new FiberCascadedShadowGeneratorPropsHandler(),
            new FiberShadowGeneratorPropsHandler(),
        ];
    }
    FiberCascadedShadowGenerator.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberCascadedShadowGenerator.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberCascadedShadowGenerator.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'CascadedShadowGenerator',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'mapSize',
                type: 'number',
                optional: false,
            },
            {
                name: 'light',
                type: 'BabylonjsCoreDirectionalLight',
                optional: true,
            },
            {
                name: 'usefulFloatFirst',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberCascadedShadowGenerator.Metadata = {
        delayCreation: true,
        isShadowGenerator: true,
        className: 'FiberCascadedShadowGenerator',
    };
    return FiberCascadedShadowGenerator;
}());
var FiberEngineViewPropsHandler = /** @class */ (function () {
    function FiberEngineViewPropsHandler() {
    }
    FiberEngineViewPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreEngineView.camera.
        checkPrimitiveDiff(oldProps.clearBeforeCopy, newProps.clearBeforeCopy, 'clearBeforeCopy', changedProps);
        checkLambdaDiff(oldProps.customResize, newProps.customResize, 'customResize', changedProps);
        checkPrimitiveDiff(oldProps.enabled, newProps.enabled, 'enabled', changedProps);
        // type: 'HTMLCanvasElement' property (not coded) BabylonjsCoreEngineView.target.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberEngineViewPropsHandler;
}());
/**
 * Class used to define an additional view for the engine
 *
 * This code has been generated
 */
var FiberEngineView = /** @class */ (function () {
    function FiberEngineView() {
        this.propsHandlers = [new FiberEngineViewPropsHandler()];
    }
    FiberEngineView.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberEngineView.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberEngineView.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'EngineView',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberEngineView.Metadata = {
        delayCreation: true,
        className: 'FiberEngineView',
    };
    return FiberEngineView;
}());
var FiberGizmoManagerPropsHandler = /** @class */ (function () {
    function FiberGizmoManagerPropsHandler() {
    }
    FiberGizmoManagerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreGizmoManager.attachableMeshes.
        // type: 'BabylonjsCoreNode[]' property (not coded) BabylonjsCoreGizmoManager.attachableNodes.
        // type: 'BabylonjsCoreSixDofDragBehavior' property (not coded) BabylonjsCoreGizmoManager.boundingBoxDragBehavior.
        checkPrimitiveDiff(oldProps.boundingBoxGizmoEnabled, newProps.boundingBoxGizmoEnabled, 'boundingBoxGizmoEnabled', changedProps);
        checkPrimitiveDiff(oldProps.clearGizmoOnEmptyPointerEvent, newProps.clearGizmoOnEmptyPointerEvent, 'clearGizmoOnEmptyPointerEvent', changedProps);
        checkPrimitiveDiff(oldProps.enableAutoPicking, newProps.enableAutoPicking, 'enableAutoPicking', changedProps);
        // type: '{ positionGizmo: BabylonjsCorePositionGizmo; rotationGizmo: BabylonjsCoreRotationGizmo; scaleGizmo: BabylonjsCoreScaleGizmo; boundingBoxGizmo: BabylonjsCoreBoundingBoxGizmo; }' property (not coded) BabylonjsCoreGizmoManager.gizmos.
        checkObservableDiff(oldProps.onAttachedToMeshObservable, newProps.onAttachedToMeshObservable, 'onAttachedToMeshObservable', changedProps);
        checkObservableDiff(oldProps.onAttachedToNodeObservable, newProps.onAttachedToNodeObservable, 'onAttachedToNodeObservable', changedProps);
        checkPrimitiveDiff(oldProps.positionGizmoEnabled, newProps.positionGizmoEnabled, 'positionGizmoEnabled', changedProps);
        checkPrimitiveDiff(oldProps.rotationGizmoEnabled, newProps.rotationGizmoEnabled, 'rotationGizmoEnabled', changedProps);
        checkPrimitiveDiff(oldProps.scaleGizmoEnabled, newProps.scaleGizmoEnabled, 'scaleGizmoEnabled', changedProps);
        checkPrimitiveDiff(oldProps.scaleRatio, newProps.scaleRatio, 'scaleRatio', changedProps);
        checkPrimitiveDiff(oldProps.usePointerToAttachGizmos, newProps.usePointerToAttachGizmos, 'usePointerToAttachGizmos', changedProps);
        checkMethodDiff(oldProps.addToAxisCache, newProps.addToAxisCache, 'addToAxisCache', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberGizmoManagerPropsHandler;
}());
/**
 * Helps setup gizmo's in the scene to rotate/scale/position nodes
 *
 * This code has been generated
 */
var FiberGizmoManager = /** @class */ (function () {
    function FiberGizmoManager() {
        this.propsHandlers = [new FiberGizmoManagerPropsHandler()];
    }
    FiberGizmoManager.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberGizmoManager.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberGizmoManager.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'GizmoManager',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: '_scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'thickness',
                type: 'number',
                optional: true,
            },
            {
                name: 'utilityLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
            {
                name: 'keepDepthUtilityLayer',
                type: 'BabylonjsCoreUtilityLayerRenderer',
                optional: true,
            },
        ],
    };
    FiberGizmoManager.Metadata = {
        className: 'FiberGizmoManager',
    };
    return FiberGizmoManager;
}());
var FiberLayerPropsHandler = /** @class */ (function () {
    function FiberLayerPropsHandler() {
    }
    FiberLayerPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.alphaBlendingMode, newProps.alphaBlendingMode, 'alphaBlendingMode', changedProps);
        checkPrimitiveDiff(oldProps.alphaTest, newProps.alphaTest, 'alphaTest', changedProps);
        checkColor4Diff(oldProps.color, newProps.color, 'color', changedProps);
        checkPrimitiveDiff(oldProps.isBackground, newProps.isBackground, 'isBackground', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkPrimitiveDiff(oldProps.layerMask, newProps.layerMask, 'layerMask', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreLayer.offset.
        checkLambdaDiff(oldProps.onAfterRender, newProps.onAfterRender, 'onAfterRender', changedProps);
        checkObservableDiff(oldProps.onAfterRenderObservable, newProps.onAfterRenderObservable, 'onAfterRenderObservable', changedProps);
        checkLambdaDiff(oldProps.onBeforeRender, newProps.onBeforeRender, 'onBeforeRender', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderObservable, newProps.onBeforeRenderObservable, 'onBeforeRenderObservable', changedProps);
        checkLambdaDiff(oldProps.onDispose, newProps.onDispose, 'onDispose', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        checkPrimitiveDiff(oldProps.renderOnlyInRenderTargetTextures, newProps.renderOnlyInRenderTargetTextures, 'renderOnlyInRenderTargetTextures', changedProps);
        // type: 'BabylonjsCoreRenderTargetTexture[]' property (not coded) BabylonjsCoreLayer.renderTargetTextures.
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCoreLayer.scale.
        checkTextureDiff(oldProps.texture, newProps.texture, 'texture', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberLayerPropsHandler;
}());
/**
 * This represents a full screen 2d layer.
 * This can be useful to display a picture in the  background of your scene for instance.
 *
 * This code has been generated
 */
var FiberLayer = /** @class */ (function () {
    function FiberLayer() {
        this.propsHandlers = [new FiberLayerPropsHandler()];
    }
    FiberLayer.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberLayer.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberLayer.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'Layer',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'name',
                type: 'string',
                optional: false,
            },
            {
                name: 'imgUrl',
                type: 'string',
                optional: false,
            },
            {
                name: 'scene',
                type: 'BabylonjsCoreScene',
                optional: false,
            },
            {
                name: 'isBackground',
                type: 'boolean',
                optional: true,
            },
            {
                name: 'color',
                type: 'BabylonjsCoreColor4',
                optional: true,
            },
        ],
    };
    FiberLayer.Metadata = {
        isLayer: true,
        className: 'FiberLayer',
    };
    return FiberLayer;
}());
var FiberImageProcessingConfigurationPropsHandler = /** @class */ (function () {
    function FiberImageProcessingConfigurationPropsHandler() {
    }
    FiberImageProcessingConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.applyByPostProcess, newProps.applyByPostProcess, 'applyByPostProcess', changedProps);
        // type: 'BabylonjsCoreColorCurves' property (not coded) BabylonjsCoreImageProcessingConfiguration.colorCurves.
        checkPrimitiveDiff(oldProps.colorCurvesEnabled, newProps.colorCurvesEnabled, 'colorCurvesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.colorGradingBGR, newProps.colorGradingBGR, 'colorGradingBGR', changedProps);
        checkPrimitiveDiff(oldProps.colorGradingEnabled, newProps.colorGradingEnabled, 'colorGradingEnabled', changedProps);
        checkTextureDiff(oldProps.colorGradingTexture, newProps.colorGradingTexture, 'colorGradingTexture', changedProps);
        checkPrimitiveDiff(oldProps.colorGradingWithGreenDepth, newProps.colorGradingWithGreenDepth, 'colorGradingWithGreenDepth', changedProps);
        checkPrimitiveDiff(oldProps.contrast, newProps.contrast, 'contrast', changedProps);
        checkPrimitiveDiff(oldProps.exposure, newProps.exposure, 'exposure', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkObservableDiff(oldProps.onUpdateParameters, newProps.onUpdateParameters, 'onUpdateParameters', changedProps);
        checkPrimitiveDiff(oldProps.skipFinalColorClamp, newProps.skipFinalColorClamp, 'skipFinalColorClamp', changedProps);
        checkPrimitiveDiff(oldProps.toneMappingEnabled, newProps.toneMappingEnabled, 'toneMappingEnabled', changedProps);
        checkPrimitiveDiff(oldProps.toneMappingType, newProps.toneMappingType, 'toneMappingType', changedProps);
        checkPrimitiveDiff(oldProps.vignetteBlendMode, newProps.vignetteBlendMode, 'vignetteBlendMode', changedProps);
        checkPrimitiveDiff(oldProps.vignetteCameraFov, newProps.vignetteCameraFov, 'vignetteCameraFov', changedProps);
        checkPrimitiveDiff(oldProps.vignetteCentreX, newProps.vignetteCentreX, 'vignetteCentreX', changedProps);
        checkPrimitiveDiff(oldProps.vignetteCentreY, newProps.vignetteCentreY, 'vignetteCentreY', changedProps);
        checkColor4Diff(oldProps.vignetteColor, newProps.vignetteColor, 'vignetteColor', changedProps);
        checkPrimitiveDiff(oldProps.vignetteEnabled, newProps.vignetteEnabled, 'vignetteEnabled', changedProps);
        checkPrimitiveDiff(oldProps.vignetteStretch, newProps.vignetteStretch, 'vignetteStretch', changedProps);
        checkPrimitiveDiff(oldProps.vignetteWeight, newProps.vignetteWeight, 'vignetteWeight', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberImageProcessingConfigurationPropsHandler;
}());
/**
 * This groups together the common properties used for image processing either in direct forward pass
 * or through post processing effect depending on the use of the image processing pipeline in your scene
 * or not.
 *
 * This code has been generated
 */
var FiberImageProcessingConfiguration = /** @class */ (function () {
    function FiberImageProcessingConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [new FiberImageProcessingConfigurationPropsHandler()];
    }
    FiberImageProcessingConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberImageProcessingConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberImageProcessingConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'ImageProcessingConfiguration',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberImageProcessingConfiguration.Metadata = {
        className: 'FiberImageProcessingConfiguration',
    };
    return FiberImageProcessingConfiguration;
}());
var FiberPBRClearCoatConfigurationPropsHandler = /** @class */ (function () {
    function FiberPBRClearCoatConfigurationPropsHandler() {
    }
    FiberPBRClearCoatConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkTextureDiff(oldProps.bumpTexture, newProps.bumpTexture, 'bumpTexture', changedProps);
        checkPrimitiveDiff(oldProps.indexOfRefraction, newProps.indexOfRefraction, 'indexOfRefraction', changedProps);
        checkPrimitiveDiff(oldProps.intensity, newProps.intensity, 'intensity', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkPrimitiveDiff(oldProps.isTintEnabled, newProps.isTintEnabled, 'isTintEnabled', changedProps);
        checkPrimitiveDiff(oldProps.remapF0OnInterfaceChange, newProps.remapF0OnInterfaceChange, 'remapF0OnInterfaceChange', changedProps);
        checkPrimitiveDiff(oldProps.roughness, newProps.roughness, 'roughness', changedProps);
        checkTextureDiff(oldProps.texture, newProps.texture, 'texture', changedProps);
        checkTextureDiff(oldProps.textureRoughness, newProps.textureRoughness, 'textureRoughness', changedProps);
        checkColor3Diff(oldProps.tintColor, newProps.tintColor, 'tintColor', changedProps);
        checkPrimitiveDiff(oldProps.tintColorAtDistance, newProps.tintColorAtDistance, 'tintColorAtDistance', changedProps);
        checkTextureDiff(oldProps.tintTexture, newProps.tintTexture, 'tintTexture', changedProps);
        checkPrimitiveDiff(oldProps.tintThickness, newProps.tintThickness, 'tintThickness', changedProps);
        checkPrimitiveDiff(oldProps.useRoughnessFromMainTexture, newProps.useRoughnessFromMainTexture, 'useRoughnessFromMainTexture', changedProps);
        checkMethodDiff(oldProps.addFallbacks, newProps.addFallbacks, 'addFallbacks', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRClearCoatConfigurationPropsHandler;
}());
/**
 * Plugin that implements the clear coat component of the PBR material
 *
 * This code has been generated
 */
var FiberPBRClearCoatConfiguration = /** @class */ (function () {
    function FiberPBRClearCoatConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [
            new FiberPBRClearCoatConfigurationPropsHandler(),
            new FiberMaterialPluginBasePropsHandler(),
        ];
    }
    FiberPBRClearCoatConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRClearCoatConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRClearCoatConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRClearCoatConfiguration',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCorePBRBaseMaterial',
                optional: false,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPBRClearCoatConfiguration.Metadata = {
        className: 'FiberPBRClearCoatConfiguration',
    };
    return FiberPBRClearCoatConfiguration;
}());
var FiberPBRAnisotropicConfigurationPropsHandler = /** @class */ (function () {
    function FiberPBRAnisotropicConfigurationPropsHandler() {
    }
    FiberPBRAnisotropicConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreVector2' property (not coded) BabylonjsCorePBRAnisotropicConfiguration.direction.
        checkPrimitiveDiff(oldProps.intensity, newProps.intensity, 'intensity', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkTextureDiff(oldProps.texture, newProps.texture, 'texture', changedProps);
        checkMethodDiff(oldProps.addFallbacks, newProps.addFallbacks, 'addFallbacks', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRAnisotropicConfigurationPropsHandler;
}());
/**
 * Plugin that implements the anisotropic component of the PBR material
 *
 * This code has been generated
 */
var FiberPBRAnisotropicConfiguration = /** @class */ (function () {
    function FiberPBRAnisotropicConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [
            new FiberPBRAnisotropicConfigurationPropsHandler(),
            new FiberMaterialPluginBasePropsHandler(),
        ];
    }
    FiberPBRAnisotropicConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRAnisotropicConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRAnisotropicConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRAnisotropicConfiguration',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCorePBRBaseMaterial',
                optional: false,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPBRAnisotropicConfiguration.Metadata = {
        className: 'FiberPBRAnisotropicConfiguration',
    };
    return FiberPBRAnisotropicConfiguration;
}());
var FiberPBRBRDFConfigurationPropsHandler = /** @class */ (function () {
    function FiberPBRBRDFConfigurationPropsHandler() {
    }
    FiberPBRBRDFConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.useEnergyConservation, newProps.useEnergyConservation, 'useEnergyConservation', changedProps);
        checkPrimitiveDiff(oldProps.useSmithVisibilityHeightCorrelated, newProps.useSmithVisibilityHeightCorrelated, 'useSmithVisibilityHeightCorrelated', changedProps);
        checkPrimitiveDiff(oldProps.useSpecularGlossinessInputEnergyConservation, newProps.useSpecularGlossinessInputEnergyConservation, 'useSpecularGlossinessInputEnergyConservation', changedProps);
        checkPrimitiveDiff(oldProps.useSphericalHarmonics, newProps.useSphericalHarmonics, 'useSphericalHarmonics', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRBRDFConfigurationPropsHandler;
}());
/**
 * Plugin that implements the BRDF component of the PBR material
 *
 * This code has been generated
 */
var FiberPBRBRDFConfiguration = /** @class */ (function () {
    function FiberPBRBRDFConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [
            new FiberPBRBRDFConfigurationPropsHandler(),
            new FiberMaterialPluginBasePropsHandler(),
        ];
    }
    FiberPBRBRDFConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRBRDFConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRBRDFConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRBRDFConfiguration',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCorePBRBaseMaterial',
                optional: false,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPBRBRDFConfiguration.Metadata = {
        className: 'FiberPBRBRDFConfiguration',
    };
    return FiberPBRBRDFConfiguration;
}());
var FiberPBRSheenConfigurationPropsHandler = /** @class */ (function () {
    function FiberPBRSheenConfigurationPropsHandler() {
    }
    FiberPBRSheenConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.albedoScaling, newProps.albedoScaling, 'albedoScaling', changedProps);
        checkColor3Diff(oldProps.color, newProps.color, 'color', changedProps);
        checkPrimitiveDiff(oldProps.intensity, newProps.intensity, 'intensity', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkPrimitiveDiff(oldProps.linkSheenWithAlbedo, newProps.linkSheenWithAlbedo, 'linkSheenWithAlbedo', changedProps);
        checkPrimitiveDiff(oldProps.roughness, newProps.roughness, 'roughness', changedProps);
        checkTextureDiff(oldProps.texture, newProps.texture, 'texture', changedProps);
        checkTextureDiff(oldProps.textureRoughness, newProps.textureRoughness, 'textureRoughness', changedProps);
        checkPrimitiveDiff(oldProps.useRoughnessFromMainTexture, newProps.useRoughnessFromMainTexture, 'useRoughnessFromMainTexture', changedProps);
        checkMethodDiff(oldProps.addFallbacks, newProps.addFallbacks, 'addFallbacks', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRSheenConfigurationPropsHandler;
}());
/**
 * Plugin that implements the sheen component of the PBR material.
 *
 * This code has been generated
 */
var FiberPBRSheenConfiguration = /** @class */ (function () {
    function FiberPBRSheenConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [
            new FiberPBRSheenConfigurationPropsHandler(),
            new FiberMaterialPluginBasePropsHandler(),
        ];
    }
    FiberPBRSheenConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRSheenConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRSheenConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRSheenConfiguration',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCorePBRBaseMaterial',
                optional: false,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPBRSheenConfiguration.Metadata = {
        className: 'FiberPBRSheenConfiguration',
    };
    return FiberPBRSheenConfiguration;
}());
var FiberPBRSubSurfaceConfigurationPropsHandler = /** @class */ (function () {
    function FiberPBRSubSurfaceConfigurationPropsHandler() {
    }
    FiberPBRSubSurfaceConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkColor3Diff(oldProps.diffusionDistance, newProps.diffusionDistance, 'diffusionDistance', changedProps);
        checkPrimitiveDiff(oldProps.indexOfRefraction, newProps.indexOfRefraction, 'indexOfRefraction', changedProps);
        checkPrimitiveDiff(oldProps.invertRefractionY, newProps.invertRefractionY, 'invertRefractionY', changedProps);
        checkPrimitiveDiff(oldProps.isRefractionEnabled, newProps.isRefractionEnabled, 'isRefractionEnabled', changedProps);
        checkPrimitiveDiff(oldProps.isScatteringEnabled, newProps.isScatteringEnabled, 'isScatteringEnabled', changedProps);
        checkPrimitiveDiff(oldProps.isTranslucencyEnabled, newProps.isTranslucencyEnabled, 'isTranslucencyEnabled', changedProps);
        checkPrimitiveDiff(oldProps.linkRefractionWithTransparency, newProps.linkRefractionWithTransparency, 'linkRefractionWithTransparency', changedProps);
        checkPrimitiveDiff(oldProps.maximumThickness, newProps.maximumThickness, 'maximumThickness', changedProps);
        checkPrimitiveDiff(oldProps.minimumThickness, newProps.minimumThickness, 'minimumThickness', changedProps);
        checkPrimitiveDiff(oldProps.refractionIntensity, newProps.refractionIntensity, 'refractionIntensity', changedProps);
        checkTextureDiff(oldProps.refractionIntensityTexture, newProps.refractionIntensityTexture, 'refractionIntensityTexture', changedProps);
        checkTextureDiff(oldProps.refractionTexture, newProps.refractionTexture, 'refractionTexture', changedProps);
        checkColor3Diff(oldProps.scatteringDiffusionProfile, newProps.scatteringDiffusionProfile, 'scatteringDiffusionProfile', changedProps);
        checkTextureDiff(oldProps.thicknessTexture, newProps.thicknessTexture, 'thicknessTexture', changedProps);
        checkColor3Diff(oldProps.tintColor, newProps.tintColor, 'tintColor', changedProps);
        checkPrimitiveDiff(oldProps.tintColorAtDistance, newProps.tintColorAtDistance, 'tintColorAtDistance', changedProps);
        checkPrimitiveDiff(oldProps.translucencyIntensity, newProps.translucencyIntensity, 'translucencyIntensity', changedProps);
        checkTextureDiff(oldProps.translucencyIntensityTexture, newProps.translucencyIntensityTexture, 'translucencyIntensityTexture', changedProps);
        checkPrimitiveDiff(oldProps.useAlbedoToTintRefraction, newProps.useAlbedoToTintRefraction, 'useAlbedoToTintRefraction', changedProps);
        checkPrimitiveDiff(oldProps.useAlbedoToTintTranslucency, newProps.useAlbedoToTintTranslucency, 'useAlbedoToTintTranslucency', changedProps);
        checkPrimitiveDiff(oldProps.useGltfStyleTextures, newProps.useGltfStyleTextures, 'useGltfStyleTextures', changedProps);
        checkPrimitiveDiff(oldProps.useMaskFromThicknessTexture, newProps.useMaskFromThicknessTexture, 'useMaskFromThicknessTexture', changedProps);
        checkPrimitiveDiff(oldProps.useThicknessAsDepth, newProps.useThicknessAsDepth, 'useThicknessAsDepth', changedProps);
        checkPrimitiveDiff(oldProps.volumeIndexOfRefraction, newProps.volumeIndexOfRefraction, 'volumeIndexOfRefraction', changedProps);
        checkMethodDiff(oldProps.addFallbacks, newProps.addFallbacks, 'addFallbacks', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPBRSubSurfaceConfigurationPropsHandler;
}());
/**
 * Plugin that implements the sub surface component of the PBR material
 *
 * This code has been generated
 */
var FiberPBRSubSurfaceConfiguration = /** @class */ (function () {
    function FiberPBRSubSurfaceConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [
            new FiberPBRSubSurfaceConfigurationPropsHandler(),
            new FiberMaterialPluginBasePropsHandler(),
        ];
    }
    FiberPBRSubSurfaceConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPBRSubSurfaceConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPBRSubSurfaceConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PBRSubSurfaceConfiguration',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCorePBRBaseMaterial',
                optional: false,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberPBRSubSurfaceConfiguration.Metadata = {
        className: 'FiberPBRSubSurfaceConfiguration',
    };
    return FiberPBRSubSurfaceConfiguration;
}());
var FiberPrePassConfigurationPropsHandler = /** @class */ (function () {
    function FiberPrePassConfigurationPropsHandler() {
    }
    FiberPrePassConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        // skipping type: 'BabylonjsCoreMatrix' property (not coded) BabylonjsCorePrePassConfiguration.currentViewProjection.
        // skipping type: '{ [index: number]: Float32Array; }' property (not coded) BabylonjsCorePrePassConfiguration.previousBones.
        // skipping type: 'BabylonjsCoreMatrix' property (not coded) BabylonjsCorePrePassConfiguration.previousViewProjection.
        // skipping type: '{ [index: number]: BabylonjsCoreMatrix; }' property (not coded) BabylonjsCorePrePassConfiguration.previousWorldMatrices.
        return null; // no props to check
    };
    return FiberPrePassConfigurationPropsHandler;
}());
/**
 * Configuration needed for prepass-capable materials
 *
 * This code has been generated
 */
var FiberPrePassConfiguration = /** @class */ (function () {
    function FiberPrePassConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [new FiberPrePassConfigurationPropsHandler()];
    }
    FiberPrePassConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPrePassConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPrePassConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PrePassConfiguration',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberPrePassConfiguration.Metadata = {
        className: 'FiberPrePassConfiguration',
    };
    return FiberPrePassConfiguration;
}());
var FiberDetailMapConfigurationPropsHandler = /** @class */ (function () {
    function FiberDetailMapConfigurationPropsHandler() {
    }
    FiberDetailMapConfigurationPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.bumpLevel, newProps.bumpLevel, 'bumpLevel', changedProps);
        checkPrimitiveDiff(oldProps.diffuseBlendLevel, newProps.diffuseBlendLevel, 'diffuseBlendLevel', changedProps);
        checkPrimitiveDiff(oldProps.isEnabled, newProps.isEnabled, 'isEnabled', changedProps);
        checkPrimitiveDiff(oldProps.normalBlendMethod, newProps.normalBlendMethod, 'normalBlendMethod', changedProps);
        checkPrimitiveDiff(oldProps.roughnessBlendLevel, newProps.roughnessBlendLevel, 'roughnessBlendLevel', changedProps);
        checkTextureDiff(oldProps.texture, newProps.texture, 'texture', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDetailMapConfigurationPropsHandler;
}());
/**
 * Plugin that implements the detail map component of a material
 *
 * Inspired from:
 *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html
 *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html
 *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps
 *
 * This code has been generated
 */
var FiberDetailMapConfiguration = /** @class */ (function () {
    function FiberDetailMapConfiguration() {
        this.isTargetable = false;
        this.propsHandlers = [
            new FiberDetailMapConfigurationPropsHandler(),
            new FiberMaterialPluginBasePropsHandler(),
        ];
    }
    FiberDetailMapConfiguration.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDetailMapConfiguration.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDetailMapConfiguration.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DetailMapConfiguration',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'material',
                type: 'BabylonjsCorePBRBaseMaterial | BabylonjsCoreStandardMaterial',
                optional: false,
            },
            {
                name: 'addToPluginList',
                type: 'boolean',
                optional: true,
            },
        ],
    };
    FiberDetailMapConfiguration.Metadata = {
        className: 'FiberDetailMapConfiguration',
    };
    return FiberDetailMapConfiguration;
}());
var FiberAutoRotationBehaviorPropsHandler = /** @class */ (function () {
    function FiberAutoRotationBehaviorPropsHandler() {
    }
    FiberAutoRotationBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.idleRotationSpeed, newProps.idleRotationSpeed, 'idleRotationSpeed', changedProps);
        checkPrimitiveDiff(oldProps.idleRotationSpinupTime, newProps.idleRotationSpinupTime, 'idleRotationSpinupTime', changedProps);
        checkPrimitiveDiff(oldProps.idleRotationWaitTime, newProps.idleRotationWaitTime, 'idleRotationWaitTime', changedProps);
        checkPrimitiveDiff(oldProps.zoomStopsAnimation, newProps.zoomStopsAnimation, 'zoomStopsAnimation', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberAutoRotationBehaviorPropsHandler;
}());
/**
 * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.
 *
 * This code has been generated
 */
var FiberAutoRotationBehavior = /** @class */ (function () {
    function FiberAutoRotationBehavior() {
        this.propsHandlers = [new FiberAutoRotationBehaviorPropsHandler()];
    }
    FiberAutoRotationBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAutoRotationBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAutoRotationBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AutoRotationBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberAutoRotationBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberAutoRotationBehavior',
    };
    return FiberAutoRotationBehavior;
}());
var FiberBouncingBehaviorPropsHandler = /** @class */ (function () {
    function FiberBouncingBehaviorPropsHandler() {
    }
    FiberBouncingBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.autoTransitionRange, newProps.autoTransitionRange, 'autoTransitionRange', changedProps);
        checkPrimitiveDiff(oldProps.lowerRadiusTransitionRange, newProps.lowerRadiusTransitionRange, 'lowerRadiusTransitionRange', changedProps);
        checkPrimitiveDiff(oldProps.transitionDuration, newProps.transitionDuration, 'transitionDuration', changedProps);
        checkPrimitiveDiff(oldProps.upperRadiusTransitionRange, newProps.upperRadiusTransitionRange, 'upperRadiusTransitionRange', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBouncingBehaviorPropsHandler;
}());
/**
 * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
 *
 * This code has been generated
 */
var FiberBouncingBehavior = /** @class */ (function () {
    function FiberBouncingBehavior() {
        this.propsHandlers = [new FiberBouncingBehaviorPropsHandler()];
    }
    FiberBouncingBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBouncingBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBouncingBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BouncingBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberBouncingBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberBouncingBehavior',
    };
    return FiberBouncingBehavior;
}());
var FiberFramingBehaviorPropsHandler = /** @class */ (function () {
    function FiberFramingBehaviorPropsHandler() {
    }
    FiberFramingBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.autoCorrectCameraLimitsAndSensibility, newProps.autoCorrectCameraLimitsAndSensibility, 'autoCorrectCameraLimitsAndSensibility', changedProps);
        checkPrimitiveDiff(oldProps.defaultElevation, newProps.defaultElevation, 'defaultElevation', changedProps);
        checkPrimitiveDiff(oldProps.elevationReturnTime, newProps.elevationReturnTime, 'elevationReturnTime', changedProps);
        checkPrimitiveDiff(oldProps.elevationReturnWaitTime, newProps.elevationReturnWaitTime, 'elevationReturnWaitTime', changedProps);
        checkPrimitiveDiff(oldProps.framingTime, newProps.framingTime, 'framingTime', changedProps);
        checkPrimitiveDiff(oldProps.mode, newProps.mode, 'mode', changedProps);
        checkObservableDiff(oldProps.onTargetFramingAnimationEndObservable, newProps.onTargetFramingAnimationEndObservable, 'onTargetFramingAnimationEndObservable', changedProps);
        checkPrimitiveDiff(oldProps.positionScale, newProps.positionScale, 'positionScale', changedProps);
        checkPrimitiveDiff(oldProps.radiusScale, newProps.radiusScale, 'radiusScale', changedProps);
        checkPrimitiveDiff(oldProps.zoomStopsAnimation, newProps.zoomStopsAnimation, 'zoomStopsAnimation', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFramingBehaviorPropsHandler;
}());
/**
 * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.
 *
 * This code has been generated
 */
var FiberFramingBehavior = /** @class */ (function () {
    function FiberFramingBehavior() {
        this.propsHandlers = [new FiberFramingBehaviorPropsHandler()];
    }
    FiberFramingBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFramingBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFramingBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FramingBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberFramingBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberFramingBehavior',
    };
    return FiberFramingBehavior;
}());
var FiberAttachToBoxBehaviorPropsHandler = /** @class */ (function () {
    function FiberAttachToBoxBehaviorPropsHandler() {
    }
    FiberAttachToBoxBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.distanceAwayFromBottomOfFace, newProps.distanceAwayFromBottomOfFace, 'distanceAwayFromBottomOfFace', changedProps);
        checkPrimitiveDiff(oldProps.distanceAwayFromFace, newProps.distanceAwayFromFace, 'distanceAwayFromFace', changedProps);
        checkPrimitiveDiff(oldProps.name, newProps.name, 'name', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberAttachToBoxBehaviorPropsHandler;
}());
/**
 * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera
 *
 * This code has been generated
 */
var FiberAttachToBoxBehavior = /** @class */ (function () {
    function FiberAttachToBoxBehavior() {
        this.propsHandlers = [new FiberAttachToBoxBehaviorPropsHandler()];
    }
    FiberAttachToBoxBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberAttachToBoxBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberAttachToBoxBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'AttachToBoxBehavior',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: '_ui',
                type: 'BabylonjsCoreTransformNode',
                optional: false,
            },
        ],
    };
    FiberAttachToBoxBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberAttachToBoxBehavior',
    };
    return FiberAttachToBoxBehavior;
}());
var FiberBaseSixDofDragBehaviorPropsHandler = /** @class */ (function () {
    function FiberBaseSixDofDragBehaviorPropsHandler() {
    }
    FiberBaseSixDofDragBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.allowMultiPointer, newProps.allowMultiPointer, 'allowMultiPointer', changedProps);
        checkPrimitiveDiff(oldProps.currentDraggingPointerId, newProps.currentDraggingPointerId, 'currentDraggingPointerId', changedProps);
        checkPrimitiveDiff(oldProps.currentDraggingPointerID, newProps.currentDraggingPointerID, 'currentDraggingPointerID', changedProps);
        checkNumericArrayDiff(oldProps.currentDraggingPointerIds, newProps.currentDraggingPointerIds, 'currentDraggingPointerIds', changedProps);
        checkPrimitiveDiff(oldProps.detachCameraControls, newProps.detachCameraControls, 'detachCameraControls', changedProps);
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreBaseSixDofDragBehavior.draggableMeshes.
        checkObservableDiff(oldProps.onDragEndObservable, newProps.onDragEndObservable, 'onDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onDragObservable, newProps.onDragObservable, 'onDragObservable', changedProps);
        checkObservableDiff(oldProps.onDragStartObservable, newProps.onDragStartObservable, 'onDragStartObservable', changedProps);
        checkPrimitiveDiff(oldProps.zDragFactor, newProps.zDragFactor, 'zDragFactor', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberBaseSixDofDragBehaviorPropsHandler;
}());
/**
 * Base behavior for six degrees of freedom interactions in XR experiences.
 * Creates virtual meshes that are dragged around
 * And observables for position/rotation changes
 *
 * This code has been generated
 */
var FiberBaseSixDofDragBehavior = /** @class */ (function () {
    function FiberBaseSixDofDragBehavior() {
        this.propsHandlers = [new FiberBaseSixDofDragBehaviorPropsHandler()];
    }
    FiberBaseSixDofDragBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberBaseSixDofDragBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberBaseSixDofDragBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'BaseSixDofDragBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberBaseSixDofDragBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberBaseSixDofDragBehavior',
    };
    return FiberBaseSixDofDragBehavior;
}());
var FiberFadeInOutBehaviorPropsHandler = /** @class */ (function () {
    function FiberFadeInOutBehaviorPropsHandler() {
    }
    FiberFadeInOutBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.delay, newProps.delay, 'delay', changedProps);
        checkPrimitiveDiff(oldProps.fadeInTime, newProps.fadeInTime, 'fadeInTime', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFadeInOutBehaviorPropsHandler;
}());
/**
 * A behavior that when attached to a mesh will allow the mesh to fade in and out
 *
 * This code has been generated
 */
var FiberFadeInOutBehavior = /** @class */ (function () {
    function FiberFadeInOutBehavior() {
        this.propsHandlers = [new FiberFadeInOutBehaviorPropsHandler()];
    }
    FiberFadeInOutBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFadeInOutBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFadeInOutBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FadeInOutBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberFadeInOutBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberFadeInOutBehavior',
    };
    return FiberFadeInOutBehavior;
}());
var FiberFollowBehaviorPropsHandler = /** @class */ (function () {
    function FiberFollowBehaviorPropsHandler() {
    }
    FiberFollowBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreTransformNode' property (not coded) BabylonjsCoreFollowBehavior.attachedNode.
        checkPrimitiveDiff(oldProps.defaultDistance, newProps.defaultDistance, 'defaultDistance', changedProps);
        checkPrimitiveDiff(oldProps.fixedVerticalOffset, newProps.fixedVerticalOffset, 'fixedVerticalOffset', changedProps);
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreFollowBehavior.followedCamera.
        checkPrimitiveDiff(oldProps.ignoreAngleClamp, newProps.ignoreAngleClamp, 'ignoreAngleClamp', changedProps);
        checkPrimitiveDiff(oldProps.ignoreCameraPitchAndRoll, newProps.ignoreCameraPitchAndRoll, 'ignoreCameraPitchAndRoll', changedProps);
        checkPrimitiveDiff(oldProps.ignoreDistanceClamp, newProps.ignoreDistanceClamp, 'ignoreDistanceClamp', changedProps);
        checkPrimitiveDiff(oldProps.interpolatePose, newProps.interpolatePose, 'interpolatePose', changedProps);
        checkPrimitiveDiff(oldProps.lerpTime, newProps.lerpTime, 'lerpTime', changedProps);
        checkPrimitiveDiff(oldProps.maximumDistance, newProps.maximumDistance, 'maximumDistance', changedProps);
        checkPrimitiveDiff(oldProps.maxViewHorizontalDegrees, newProps.maxViewHorizontalDegrees, 'maxViewHorizontalDegrees', changedProps);
        checkPrimitiveDiff(oldProps.maxViewVerticalDegrees, newProps.maxViewVerticalDegrees, 'maxViewVerticalDegrees', changedProps);
        checkPrimitiveDiff(oldProps.minimumDistance, newProps.minimumDistance, 'minimumDistance', changedProps);
        checkPrimitiveDiff(oldProps.orientToCameraDeadzoneDegrees, newProps.orientToCameraDeadzoneDegrees, 'orientToCameraDeadzoneDegrees', changedProps);
        checkPrimitiveDiff(oldProps.pitchOffset, newProps.pitchOffset, 'pitchOffset', changedProps);
        checkPrimitiveDiff(oldProps.useFixedVerticalOffset, newProps.useFixedVerticalOffset, 'useFixedVerticalOffset', changedProps);
        checkPrimitiveDiff(oldProps.verticalMaxDistance, newProps.verticalMaxDistance, 'verticalMaxDistance', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberFollowBehaviorPropsHandler;
}());
/**
 * A behavior that when attached to a mesh will follow a camera
 *
 * This code has been generated
 */
var FiberFollowBehavior = /** @class */ (function () {
    function FiberFollowBehavior() {
        this.propsHandlers = [new FiberFollowBehaviorPropsHandler()];
    }
    FiberFollowBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberFollowBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberFollowBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'FollowBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberFollowBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberFollowBehavior',
    };
    return FiberFollowBehavior;
}());
var FiberHandConstraintBehaviorPropsHandler = /** @class */ (function () {
    function FiberHandConstraintBehaviorPropsHandler() {
    }
    FiberHandConstraintBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.gazeProximityRadius, newProps.gazeProximityRadius, 'gazeProximityRadius', changedProps);
        checkPrimitiveDiff(oldProps.handConstraintVisibility, newProps.handConstraintVisibility, 'handConstraintVisibility', changedProps);
        // type: 'XRHandedness' property (not coded) BabylonjsCoreHandConstraintBehavior.handedness.
        checkPrimitiveDiff(oldProps.lerpTime, newProps.lerpTime, 'lerpTime', changedProps);
        checkPrimitiveDiff(oldProps.nodeOrientationMode, newProps.nodeOrientationMode, 'nodeOrientationMode', changedProps);
        checkPrimitiveDiff(oldProps.palmUpStrictness, newProps.palmUpStrictness, 'palmUpStrictness', changedProps);
        checkPrimitiveDiff(oldProps.targetOffset, newProps.targetOffset, 'targetOffset', changedProps);
        checkPrimitiveDiff(oldProps.targetZone, newProps.targetZone, 'targetZone', changedProps);
        checkPrimitiveDiff(oldProps.zoneOrientationMode, newProps.zoneOrientationMode, 'zoneOrientationMode', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberHandConstraintBehaviorPropsHandler;
}());
/**
 * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.
 *
 * This code has been generated
 */
var FiberHandConstraintBehavior = /** @class */ (function () {
    function FiberHandConstraintBehavior() {
        this.propsHandlers = [new FiberHandConstraintBehaviorPropsHandler()];
    }
    FiberHandConstraintBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberHandConstraintBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberHandConstraintBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'HandConstraintBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberHandConstraintBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberHandConstraintBehavior',
    };
    return FiberHandConstraintBehavior;
}());
var FiberMultiPointerScaleBehaviorPropsHandler = /** @class */ (function () {
    function FiberMultiPointerScaleBehaviorPropsHandler() {
    }
    FiberMultiPointerScaleBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        return null; // no props to check
    };
    return FiberMultiPointerScaleBehaviorPropsHandler;
}());
/**
 * A behavior that when attached to a mesh will allow the mesh to be scaled
 *
 * This code has been generated
 */
var FiberMultiPointerScaleBehavior = /** @class */ (function () {
    function FiberMultiPointerScaleBehavior() {
        this.propsHandlers = [new FiberMultiPointerScaleBehaviorPropsHandler()];
    }
    FiberMultiPointerScaleBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberMultiPointerScaleBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberMultiPointerScaleBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'MultiPointerScaleBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberMultiPointerScaleBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberMultiPointerScaleBehavior',
    };
    return FiberMultiPointerScaleBehavior;
}());
var FiberPointerDragBehaviorPropsHandler = /** @class */ (function () {
    function FiberPointerDragBehaviorPropsHandler() {
    }
    FiberPointerDragBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractMesh' property (not coded) BabylonjsCorePointerDragBehavior.attachedNode.
        checkPrimitiveDiff(oldProps.currentDraggingPointerId, newProps.currentDraggingPointerId, 'currentDraggingPointerId', changedProps);
        checkPrimitiveDiff(oldProps.currentDraggingPointerID, newProps.currentDraggingPointerID, 'currentDraggingPointerID', changedProps);
        checkPrimitiveDiff(oldProps.detachCameraControls, newProps.detachCameraControls, 'detachCameraControls', changedProps);
        checkPrimitiveDiff(oldProps.dragDeltaRatio, newProps.dragDeltaRatio, 'dragDeltaRatio', changedProps);
        checkPrimitiveDiff(oldProps.dragging, newProps.dragging, 'dragging', changedProps);
        checkPrimitiveDiff(oldProps.enabled, newProps.enabled, 'enabled', changedProps);
        checkVector3Diff(oldProps.lastDragPosition, newProps.lastDragPosition, 'lastDragPosition', changedProps);
        checkPrimitiveDiff(oldProps['lastDragPosition-x'], newProps['lastDragPosition-x'], 'lastDragPosition.x', changedProps);
        checkPrimitiveDiff(oldProps['lastDragPosition-y'], newProps['lastDragPosition-y'], 'lastDragPosition.y', changedProps);
        checkPrimitiveDiff(oldProps['lastDragPosition-z'], newProps['lastDragPosition-z'], 'lastDragPosition.z', changedProps);
        checkPrimitiveDiff(oldProps.maxDragAngle, newProps.maxDragAngle, 'maxDragAngle', changedProps);
        checkPrimitiveDiff(oldProps.moveAttached, newProps.moveAttached, 'moveAttached', changedProps);
        checkObservableDiff(oldProps.onDragEndObservable, newProps.onDragEndObservable, 'onDragEndObservable', changedProps);
        checkObservableDiff(oldProps.onDragObservable, newProps.onDragObservable, 'onDragObservable', changedProps);
        checkObservableDiff(oldProps.onDragStartObservable, newProps.onDragStartObservable, 'onDragStartObservable', changedProps);
        checkObservableDiff(oldProps.onEnabledObservable, newProps.onEnabledObservable, 'onEnabledObservable', changedProps);
        // type: '{ dragAxis?: BabylonjsCoreVector3; dragPlaneNormal?: BabylonjsCoreVector3; }' property (not coded) BabylonjsCorePointerDragBehavior.options.
        checkPrimitiveDiff(oldProps.startAndReleaseDragOnPointerEvents, newProps.startAndReleaseDragOnPointerEvents, 'startAndReleaseDragOnPointerEvents', changedProps);
        checkPrimitiveDiff(oldProps.updateDragPlane, newProps.updateDragPlane, 'updateDragPlane', changedProps);
        checkPrimitiveDiff(oldProps.useObjectOrientationForDragging, newProps.useObjectOrientationForDragging, 'useObjectOrientationForDragging', changedProps);
        checkLambdaDiff(oldProps.validateDrag, newProps.validateDrag, 'validateDrag', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberPointerDragBehaviorPropsHandler;
}());
/**
 * A behavior that when attached to a mesh will allow the mesh to be dragged around the screen based on pointer events
 *
 * This code has been generated
 */
var FiberPointerDragBehavior = /** @class */ (function () {
    function FiberPointerDragBehavior() {
        this.propsHandlers = [new FiberPointerDragBehaviorPropsHandler()];
    }
    FiberPointerDragBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberPointerDragBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberPointerDragBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'PointerDragBehavior',
        namespace: '@babylonjs/core',
        parameters: [
            {
                name: 'options',
                type: [
                    {
                        name: 'dragAxis',
                        type: 'BabylonjsCoreVector3',
                        optional: true,
                    },
                    {
                        name: 'dragPlaneNormal',
                        type: 'BabylonjsCoreVector3',
                        optional: true,
                    },
                ],
                optional: true,
            },
        ],
    };
    FiberPointerDragBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberPointerDragBehavior',
    };
    return FiberPointerDragBehavior;
}());
var FiberSixDofDragBehaviorPropsHandler = /** @class */ (function () {
    function FiberSixDofDragBehaviorPropsHandler() {
    }
    FiberSixDofDragBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.disableMovement, newProps.disableMovement, 'disableMovement', changedProps);
        checkPrimitiveDiff(oldProps.dragDeltaRatio, newProps.dragDeltaRatio, 'dragDeltaRatio', changedProps);
        checkPrimitiveDiff(oldProps.faceCameraOnDragStart, newProps.faceCameraOnDragStart, 'faceCameraOnDragStart', changedProps);
        checkObservableDiff(oldProps.onPositionChangedObservable, newProps.onPositionChangedObservable, 'onPositionChangedObservable', changedProps);
        checkPrimitiveDiff(oldProps.rotateAroundYOnly, newProps.rotateAroundYOnly, 'rotateAroundYOnly', changedProps);
        checkPrimitiveDiff(oldProps.rotateDraggedObject, newProps.rotateDraggedObject, 'rotateDraggedObject', changedProps);
        checkPrimitiveDiff(oldProps.rotateWithMotionController, newProps.rotateWithMotionController, 'rotateWithMotionController', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSixDofDragBehaviorPropsHandler;
}());
/**
 * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
 *
 * This code has been generated
 */
var FiberSixDofDragBehavior = /** @class */ (function () {
    function FiberSixDofDragBehavior() {
        this.propsHandlers = [
            new FiberSixDofDragBehaviorPropsHandler(),
            new FiberBaseSixDofDragBehaviorPropsHandler(),
        ];
    }
    FiberSixDofDragBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSixDofDragBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSixDofDragBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SixDofDragBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberSixDofDragBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberSixDofDragBehavior',
    };
    return FiberSixDofDragBehavior;
}());
var FiberSurfaceMagnetismBehaviorPropsHandler = /** @class */ (function () {
    function FiberSurfaceMagnetismBehaviorPropsHandler() {
    }
    FiberSurfaceMagnetismBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.enabled, newProps.enabled, 'enabled', changedProps);
        checkPrimitiveDiff(oldProps.hitNormalOffset, newProps.hitNormalOffset, 'hitNormalOffset', changedProps);
        checkPrimitiveDiff(oldProps.interpolatePose, newProps.interpolatePose, 'interpolatePose', changedProps);
        checkPrimitiveDiff(oldProps.keepOrientationVertical, newProps.keepOrientationVertical, 'keepOrientationVertical', changedProps);
        checkPrimitiveDiff(oldProps.lerpTime, newProps.lerpTime, 'lerpTime', changedProps);
        checkPrimitiveDiff(oldProps.maxStickingDistance, newProps.maxStickingDistance, 'maxStickingDistance', changedProps);
        // type: 'BabylonjsCoreAbstractMesh[]' property (not coded) BabylonjsCoreSurfaceMagnetismBehavior.meshes.
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberSurfaceMagnetismBehaviorPropsHandler;
}());
/**
 * A behavior that allows a transform node to stick to a surface position/orientation
 *
 * This code has been generated
 */
var FiberSurfaceMagnetismBehavior = /** @class */ (function () {
    function FiberSurfaceMagnetismBehavior() {
        this.propsHandlers = [new FiberSurfaceMagnetismBehaviorPropsHandler()];
    }
    FiberSurfaceMagnetismBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberSurfaceMagnetismBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberSurfaceMagnetismBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'SurfaceMagnetismBehavior',
        namespace: '@babylonjs/core',
        parameters: [],
    };
    FiberSurfaceMagnetismBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberSurfaceMagnetismBehavior',
    };
    return FiberSurfaceMagnetismBehavior;
}());
var FiberDefaultBehaviorPropsHandler = /** @class */ (function () {
    function FiberDefaultBehaviorPropsHandler() {
    }
    FiberDefaultBehaviorPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreMesh' property (not coded) BabylonjsGuiDefaultBehavior.attachedNode.
        checkPrimitiveDiff(oldProps.followBehaviorEnabled, newProps.followBehaviorEnabled, 'followBehaviorEnabled', changedProps);
        checkPrimitiveDiff(oldProps.sixDofDragBehaviorEnabled, newProps.sixDofDragBehaviorEnabled, 'sixDofDragBehaviorEnabled', changedProps);
        checkPrimitiveDiff(oldProps.surfaceMagnetismBehaviorEnabled, newProps.surfaceMagnetismBehaviorEnabled, 'surfaceMagnetismBehaviorEnabled', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberDefaultBehaviorPropsHandler;
}());
/**
 * Default behavior for 3D UI elements.
 * Handles a FollowBehavior, SixDofBehavior and SurfaceMagnetismBehavior
 *
 * This code has been generated
 */
var FiberDefaultBehavior = /** @class */ (function () {
    function FiberDefaultBehavior() {
        this.propsHandlers = [new FiberDefaultBehaviorPropsHandler()];
    }
    FiberDefaultBehavior.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    FiberDefaultBehavior.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    FiberDefaultBehavior.CreateInfo = {
        creationType: 'Constructor',
        libraryLocation: 'DefaultBehavior',
        namespace: '@babylonjs/gui',
        parameters: [],
    };
    FiberDefaultBehavior.Metadata = {
        isBehavior: true,
        className: 'FiberDefaultBehavior',
    };
    return FiberDefaultBehavior;
}());
var FiberScenePropsHandler = /** @class */ (function () {
    function FiberScenePropsHandler() {
    }
    FiberScenePropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        // type: 'BabylonjsCoreAbstractActionManager' property (not coded) BabylonjsCoreScene.actionManager.
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreScene.activeCamera.
        // type: 'BabylonjsCoreCamera[]' property (not coded) BabylonjsCoreScene.activeCameras.
        checkLambdaDiff(oldProps.afterCameraRender, newProps.afterCameraRender, 'afterCameraRender', changedProps);
        checkLambdaDiff(oldProps.afterRender, newProps.afterRender, 'afterRender', changedProps);
        checkColor3Diff(oldProps.ambientColor, newProps.ambientColor, 'ambientColor', changedProps);
        // type: 'BabylonjsCoreAnimationPropertiesOverride' property (not coded) BabylonjsCoreScene.animationPropertiesOverride.
        checkPrimitiveDiff(oldProps.animationsEnabled, newProps.animationsEnabled, 'animationsEnabled', changedProps);
        checkPrimitiveDiff(oldProps.animationTimeScale, newProps.animationTimeScale, 'animationTimeScale', changedProps);
        checkPrimitiveDiff(oldProps.autoClear, newProps.autoClear, 'autoClear', changedProps);
        checkPrimitiveDiff(oldProps.autoClearDepthAndStencil, newProps.autoClearDepthAndStencil, 'autoClearDepthAndStencil', changedProps);
        checkLambdaDiff(oldProps.beforeCameraRender, newProps.beforeCameraRender, 'beforeCameraRender', changedProps);
        checkLambdaDiff(oldProps.beforeRender, newProps.beforeRender, 'beforeRender', changedProps);
        checkPrimitiveDiff(oldProps.blockfreeActiveMeshesAndRenderingGroups, newProps.blockfreeActiveMeshesAndRenderingGroups, 'blockfreeActiveMeshesAndRenderingGroups', changedProps);
        checkPrimitiveDiff(oldProps.blockMaterialDirtyMechanism, newProps.blockMaterialDirtyMechanism, 'blockMaterialDirtyMechanism', changedProps);
        // type: 'BabylonjsCoreCamera' property (not coded) BabylonjsCoreScene.cameraToUseForPointers.
        checkColor4Diff(oldProps.clearColor, newProps.clearColor, 'clearColor', changedProps);
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreScene.clipPlane.
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreScene.clipPlane2.
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreScene.clipPlane3.
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreScene.clipPlane4.
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreScene.clipPlane5.
        // type: 'BabylonjsCorePlane' property (not coded) BabylonjsCoreScene.clipPlane6.
        checkPrimitiveDiff(oldProps.collisionsEnabled, newProps.collisionsEnabled, 'collisionsEnabled', changedProps);
        checkPrimitiveDiff(oldProps.constantlyUpdateMeshUnderPointer, newProps.constantlyUpdateMeshUnderPointer, 'constantlyUpdateMeshUnderPointer', changedProps);
        checkLambdaDiff(oldProps.customLODSelector, newProps.customLODSelector, 'customLODSelector', changedProps);
        // type: 'BabylonjsCoreRenderTargetTexture[]' property (not coded) BabylonjsCoreScene.customRenderTargets.
        checkPrimitiveDiff(oldProps.defaultCursor, newProps.defaultCursor, 'defaultCursor', changedProps);
        // type: 'BabylonjsCoreMaterial' property (not coded) BabylonjsCoreScene.defaultMaterial.
        // type: 'RegExp[]' property (not coded) BabylonjsCoreScene.disableOfflineSupportExceptionRules.
        checkPrimitiveDiff(oldProps.dispatchAllSubMeshesOfActiveMeshes, newProps.dispatchAllSubMeshesOfActiveMeshes, 'dispatchAllSubMeshesOfActiveMeshes', changedProps);
        checkPrimitiveDiff(oldProps.doNotHandleCursors, newProps.doNotHandleCursors, 'doNotHandleCursors', changedProps);
        checkPrimitiveDiff(oldProps.DoubleClickDelay, newProps.DoubleClickDelay, 'DoubleClickDelay', changedProps);
        checkPrimitiveDiff(oldProps.DragMovementThreshold, newProps.DragMovementThreshold, 'DragMovementThreshold', changedProps);
        checkPrimitiveDiff(oldProps.dumpNextRenderTargets, newProps.dumpNextRenderTargets, 'dumpNextRenderTargets', changedProps);
        checkTextureDiff(oldProps.environmentBRDFTexture, newProps.environmentBRDFTexture, 'environmentBRDFTexture', changedProps);
        checkPrimitiveDiff(oldProps.environmentIntensity, newProps.environmentIntensity, 'environmentIntensity', changedProps);
        checkTextureDiff(oldProps.environmentTexture, newProps.environmentTexture, 'environmentTexture', changedProps);
        checkPrimitiveDiff(oldProps.ExclusiveDoubleClickMode, newProps.ExclusiveDoubleClickMode, 'ExclusiveDoubleClickMode', changedProps);
        checkColor3Diff(oldProps.fogColor, newProps.fogColor, 'fogColor', changedProps);
        checkPrimitiveDiff(oldProps.fogDensity, newProps.fogDensity, 'fogDensity', changedProps);
        checkPrimitiveDiff(oldProps.fogEnabled, newProps.fogEnabled, 'fogEnabled', changedProps);
        checkPrimitiveDiff(oldProps.fogEnd, newProps.fogEnd, 'fogEnd', changedProps);
        checkPrimitiveDiff(oldProps.fogMode, newProps.fogMode, 'fogMode', changedProps);
        checkPrimitiveDiff(oldProps.fogStart, newProps.fogStart, 'fogStart', changedProps);
        checkPrimitiveDiff(oldProps.forcePointsCloud, newProps.forcePointsCloud, 'forcePointsCloud', changedProps);
        checkPrimitiveDiff(oldProps.forceWireframe, newProps.forceWireframe, 'forceWireframe', changedProps);
        checkLambdaDiff(oldProps.getActiveMeshCandidates, newProps.getActiveMeshCandidates, 'getActiveMeshCandidates', changedProps);
        checkLambdaDiff(oldProps.getActiveSubMeshCandidates, newProps.getActiveSubMeshCandidates, 'getActiveSubMeshCandidates', changedProps);
        checkLambdaDiff(oldProps.getCollidingSubMeshCandidates, newProps.getCollidingSubMeshCandidates, 'getCollidingSubMeshCandidates', changedProps);
        checkLambdaDiff(oldProps.getDeterministicFrameTime, newProps.getDeterministicFrameTime, 'getDeterministicFrameTime', changedProps);
        checkLambdaDiff(oldProps.getIntersectingSubMeshCandidates, newProps.getIntersectingSubMeshCandidates, 'getIntersectingSubMeshCandidates', changedProps);
        checkVector3Diff(oldProps.gravity, newProps.gravity, 'gravity', changedProps);
        checkPrimitiveDiff(oldProps['gravity-x'], newProps['gravity-x'], 'gravity.x', changedProps);
        checkPrimitiveDiff(oldProps['gravity-y'], newProps['gravity-y'], 'gravity.y', changedProps);
        checkPrimitiveDiff(oldProps['gravity-z'], newProps['gravity-z'], 'gravity.z', changedProps);
        checkPrimitiveDiff(oldProps.hoverCursor, newProps.hoverCursor, 'hoverCursor', changedProps);
        // type: 'String[]' property (not coded) BabylonjsCoreScene.importedMeshesFiles.
        checkPrimitiveDiff(oldProps.lensFlaresEnabled, newProps.lensFlaresEnabled, 'lensFlaresEnabled', changedProps);
        checkPrimitiveDiff(oldProps.lightsEnabled, newProps.lightsEnabled, 'lightsEnabled', changedProps);
        checkPrimitiveDiff(oldProps.loadingPluginName, newProps.loadingPluginName, 'loadingPluginName', changedProps);
        checkPrimitiveDiff(oldProps.LongPressDelay, newProps.LongPressDelay, 'LongPressDelay', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreScene.metadata.
        checkPrimitiveDiff(oldProps.needsPreviousWorldMatrices, newProps.needsPreviousWorldMatrices, 'needsPreviousWorldMatrices', changedProps);
        // type: 'BabylonjsCoreIOfflineProvider' property (not coded) BabylonjsCoreScene.offlineProvider.
        checkObservableDiff(oldProps.onActiveCameraChanged, newProps.onActiveCameraChanged, 'onActiveCameraChanged', changedProps);
        checkObservableDiff(oldProps.onAfterActiveMeshesEvaluationObservable, newProps.onAfterActiveMeshesEvaluationObservable, 'onAfterActiveMeshesEvaluationObservable', changedProps);
        checkObservableDiff(oldProps.onAfterAnimationsObservable, newProps.onAfterAnimationsObservable, 'onAfterAnimationsObservable', changedProps);
        checkObservableDiff(oldProps.onAfterCameraRenderObservable, newProps.onAfterCameraRenderObservable, 'onAfterCameraRenderObservable', changedProps);
        checkObservableDiff(oldProps.onAfterDrawPhaseObservable, newProps.onAfterDrawPhaseObservable, 'onAfterDrawPhaseObservable', changedProps);
        checkObservableDiff(oldProps.onAfterParticlesRenderingObservable, newProps.onAfterParticlesRenderingObservable, 'onAfterParticlesRenderingObservable', changedProps);
        checkObservableDiff(oldProps.onAfterPhysicsObservable, newProps.onAfterPhysicsObservable, 'onAfterPhysicsObservable', changedProps);
        checkObservableDiff(oldProps.onAfterRenderCameraObservable, newProps.onAfterRenderCameraObservable, 'onAfterRenderCameraObservable', changedProps);
        checkObservableDiff(oldProps.onAfterRenderingGroupObservable, newProps.onAfterRenderingGroupObservable, 'onAfterRenderingGroupObservable', changedProps);
        checkObservableDiff(oldProps.onAfterRenderObservable, newProps.onAfterRenderObservable, 'onAfterRenderObservable', changedProps);
        checkObservableDiff(oldProps.onAfterRenderTargetsRenderObservable, newProps.onAfterRenderTargetsRenderObservable, 'onAfterRenderTargetsRenderObservable', changedProps);
        checkObservableDiff(oldProps.onAfterStepObservable, newProps.onAfterStepObservable, 'onAfterStepObservable', changedProps);
        checkObservableDiff(oldProps.onAnimationFileImportedObservable, newProps.onAnimationFileImportedObservable, 'onAnimationFileImportedObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeActiveMeshesEvaluationObservable, newProps.onBeforeActiveMeshesEvaluationObservable, 'onBeforeActiveMeshesEvaluationObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeAnimationsObservable, newProps.onBeforeAnimationsObservable, 'onBeforeAnimationsObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeCameraRenderObservable, newProps.onBeforeCameraRenderObservable, 'onBeforeCameraRenderObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeDrawPhaseObservable, newProps.onBeforeDrawPhaseObservable, 'onBeforeDrawPhaseObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeParticlesRenderingObservable, newProps.onBeforeParticlesRenderingObservable, 'onBeforeParticlesRenderingObservable', changedProps);
        checkObservableDiff(oldProps.onBeforePhysicsObservable, newProps.onBeforePhysicsObservable, 'onBeforePhysicsObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderingGroupObservable, newProps.onBeforeRenderingGroupObservable, 'onBeforeRenderingGroupObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderObservable, newProps.onBeforeRenderObservable, 'onBeforeRenderObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeRenderTargetsRenderObservable, newProps.onBeforeRenderTargetsRenderObservable, 'onBeforeRenderTargetsRenderObservable', changedProps);
        checkObservableDiff(oldProps.onBeforeStepObservable, newProps.onBeforeStepObservable, 'onBeforeStepObservable', changedProps);
        checkObservableDiff(oldProps.onCameraRemovedObservable, newProps.onCameraRemovedObservable, 'onCameraRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onComputePressureChanged, newProps.onComputePressureChanged, 'onComputePressureChanged', changedProps);
        checkObservableDiff(oldProps.onDataLoadedObservable, newProps.onDataLoadedObservable, 'onDataLoadedObservable', changedProps);
        checkLambdaDiff(oldProps.onDispose, newProps.onDispose, 'onDispose', changedProps);
        checkObservableDiff(oldProps.onDisposeObservable, newProps.onDisposeObservable, 'onDisposeObservable', changedProps);
        checkObservableDiff(oldProps.onGeometryRemovedObservable, newProps.onGeometryRemovedObservable, 'onGeometryRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onKeyboardObservable, newProps.onKeyboardObservable, 'onKeyboardObservable', changedProps);
        checkObservableDiff(oldProps.onLightRemovedObservable, newProps.onLightRemovedObservable, 'onLightRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onMaterialRemovedObservable, newProps.onMaterialRemovedObservable, 'onMaterialRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onMeshImportedObservable, newProps.onMeshImportedObservable, 'onMeshImportedObservable', changedProps);
        checkObservableDiff(oldProps.onMeshRemovedObservable, newProps.onMeshRemovedObservable, 'onMeshRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onMultiMaterialRemovedObservable, newProps.onMultiMaterialRemovedObservable, 'onMultiMaterialRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onNewCameraAddedObservable, newProps.onNewCameraAddedObservable, 'onNewCameraAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewGeometryAddedObservable, newProps.onNewGeometryAddedObservable, 'onNewGeometryAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewLightAddedObservable, newProps.onNewLightAddedObservable, 'onNewLightAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewMaterialAddedObservable, newProps.onNewMaterialAddedObservable, 'onNewMaterialAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewMeshAddedObservable, newProps.onNewMeshAddedObservable, 'onNewMeshAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewMultiMaterialAddedObservable, newProps.onNewMultiMaterialAddedObservable, 'onNewMultiMaterialAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewSkeletonAddedObservable, newProps.onNewSkeletonAddedObservable, 'onNewSkeletonAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewTextureAddedObservable, newProps.onNewTextureAddedObservable, 'onNewTextureAddedObservable', changedProps);
        checkObservableDiff(oldProps.onNewTransformNodeAddedObservable, newProps.onNewTransformNodeAddedObservable, 'onNewTransformNodeAddedObservable', changedProps);
        checkLambdaDiff(oldProps.onPointerDown, newProps.onPointerDown, 'onPointerDown', changedProps);
        checkLambdaDiff(oldProps.onPointerMove, newProps.onPointerMove, 'onPointerMove', changedProps);
        checkObservableDiff(oldProps.onPointerObservable, newProps.onPointerObservable, 'onPointerObservable', changedProps);
        checkLambdaDiff(oldProps.onPointerPick, newProps.onPointerPick, 'onPointerPick', changedProps);
        checkLambdaDiff(oldProps.onPointerUp, newProps.onPointerUp, 'onPointerUp', changedProps);
        checkObservableDiff(oldProps.onPreKeyboardObservable, newProps.onPreKeyboardObservable, 'onPreKeyboardObservable', changedProps);
        checkObservableDiff(oldProps.onPrePointerObservable, newProps.onPrePointerObservable, 'onPrePointerObservable', changedProps);
        checkObservableDiff(oldProps.onReadyObservable, newProps.onReadyObservable, 'onReadyObservable', changedProps);
        checkObservableDiff(oldProps.onSkeletonRemovedObservable, newProps.onSkeletonRemovedObservable, 'onSkeletonRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onTextureRemovedObservable, newProps.onTextureRemovedObservable, 'onTextureRemovedObservable', changedProps);
        checkObservableDiff(oldProps.onTransformNodeRemovedObservable, newProps.onTransformNodeRemovedObservable, 'onTransformNodeRemovedObservable', changedProps);
        checkPrimitiveDiff(oldProps.particlesEnabled, newProps.particlesEnabled, 'particlesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.physicsEnabled, newProps.physicsEnabled, 'physicsEnabled', changedProps);
        checkLambdaDiff(oldProps.pointerDownPredicate, newProps.pointerDownPredicate, 'pointerDownPredicate', changedProps);
        checkLambdaDiff(oldProps.pointerMovePredicate, newProps.pointerMovePredicate, 'pointerMovePredicate', changedProps);
        checkLambdaDiff(oldProps.pointerMoveTrianglePredicate, newProps.pointerMoveTrianglePredicate, 'pointerMoveTrianglePredicate', changedProps);
        checkLambdaDiff(oldProps.pointerUpPredicate, newProps.pointerUpPredicate, 'pointerUpPredicate', changedProps);
        checkPrimitiveDiff(oldProps.pointerX, newProps.pointerX, 'pointerX', changedProps);
        checkPrimitiveDiff(oldProps.pointerY, newProps.pointerY, 'pointerY', changedProps);
        checkPrimitiveDiff(oldProps.postProcessesEnabled, newProps.postProcessesEnabled, 'postProcessesEnabled', changedProps);
        // type: 'BabylonjsCorePostProcessManager' property (not coded) BabylonjsCoreScene.postProcessManager.
        checkPrimitiveDiff(oldProps.preventDefaultOnPointerDown, newProps.preventDefaultOnPointerDown, 'preventDefaultOnPointerDown', changedProps);
        checkPrimitiveDiff(oldProps.preventDefaultOnPointerUp, newProps.preventDefaultOnPointerUp, 'preventDefaultOnPointerUp', changedProps);
        checkPrimitiveDiff(oldProps.probesEnabled, newProps.probesEnabled, 'probesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.proceduralTexturesEnabled, newProps.proceduralTexturesEnabled, 'proceduralTexturesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.renderTargetsEnabled, newProps.renderTargetsEnabled, 'renderTargetsEnabled', changedProps);
        checkPrimitiveDiff(oldProps.requireLightSorting, newProps.requireLightSorting, 'requireLightSorting', changedProps);
        // type: 'any' property (not coded) BabylonjsCoreScene.reservedDataStore.
        checkPrimitiveDiff(oldProps.shadowsEnabled, newProps.shadowsEnabled, 'shadowsEnabled', changedProps);
        checkPrimitiveDiff(oldProps.skeletonsEnabled, newProps.skeletonsEnabled, 'skeletonsEnabled', changedProps);
        checkPrimitiveDiff(oldProps.skipFrustumClipping, newProps.skipFrustumClipping, 'skipFrustumClipping', changedProps);
        checkPrimitiveDiff(oldProps.skipPointerMovePicking, newProps.skipPointerMovePicking, 'skipPointerMovePicking', changedProps);
        checkPrimitiveDiff(oldProps.spritesEnabled, newProps.spritesEnabled, 'spritesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.texturesEnabled, newProps.texturesEnabled, 'texturesEnabled', changedProps);
        checkPrimitiveDiff(oldProps.useConstantAnimationDeltaTime, newProps.useConstantAnimationDeltaTime, 'useConstantAnimationDeltaTime', changedProps);
        checkPrimitiveDiff(oldProps.useDelayedTextureLoading, newProps.useDelayedTextureLoading, 'useDelayedTextureLoading', changedProps);
        checkPrimitiveDiff(oldProps.useRightHandedSystem, newProps.useRightHandedSystem, 'useRightHandedSystem', changedProps);
        checkMethodDiff(oldProps.addActionManager, newProps.addActionManager, 'addActionManager', changedProps);
        checkMethodDiff(oldProps.addAnimation, newProps.addAnimation, 'addAnimation', changedProps);
        checkMethodDiff(oldProps.addAnimationGroup, newProps.addAnimationGroup, 'addAnimationGroup', changedProps);
        checkMethodDiff(oldProps.addCamera, newProps.addCamera, 'addCamera', changedProps);
        checkMethodDiff(oldProps.addExternalData, newProps.addExternalData, 'addExternalData', changedProps);
        checkMethodDiff(oldProps.addGeometry, newProps.addGeometry, 'addGeometry', changedProps);
        checkMethodDiff(oldProps.addLight, newProps.addLight, 'addLight', changedProps);
        checkMethodDiff(oldProps.addMaterial, newProps.addMaterial, 'addMaterial', changedProps);
        checkMethodDiff(oldProps.addMesh, newProps.addMesh, 'addMesh', changedProps);
        checkMethodDiff(oldProps.addMorphTargetManager, newProps.addMorphTargetManager, 'addMorphTargetManager', changedProps);
        checkMethodDiff(oldProps.addMultiMaterial, newProps.addMultiMaterial, 'addMultiMaterial', changedProps);
        checkMethodDiff(oldProps.addParticleSystem, newProps.addParticleSystem, 'addParticleSystem', changedProps);
        checkMethodDiff(oldProps.addSkeleton, newProps.addSkeleton, 'addSkeleton', changedProps);
        checkMethodDiff(oldProps.addTexture, newProps.addTexture, 'addTexture', changedProps);
        checkMethodDiff(oldProps.addTransformNode, newProps.addTransformNode, 'addTransformNode', changedProps);
        checkMethodDiff(oldProps.deleteCompoundImpostor, newProps.deleteCompoundImpostor, 'deleteCompoundImpostor', changedProps);
        checkMethodDiff(oldProps.enablePhysics, newProps.enablePhysics, 'enablePhysics', changedProps);
        checkMethodDiff(oldProps.setActiveCameraById, newProps.setActiveCameraById, 'setActiveCameraById', changedProps);
        checkMethodDiff(oldProps.setActiveCameraByName, newProps.setActiveCameraByName, 'setActiveCameraByName', changedProps);
        checkMethodDiff(oldProps.setPointerOverMesh, newProps.setPointerOverMesh, 'setPointerOverMesh', changedProps);
        checkMethodDiff(oldProps.setRenderingAutoClearDepthStencil, newProps.setRenderingAutoClearDepthStencil, 'setRenderingAutoClearDepthStencil', changedProps);
        checkMethodDiff(oldProps.setRenderingOrder, newProps.setRenderingOrder, 'setRenderingOrder', changedProps);
        checkMethodDiff(oldProps.setSceneUniformBuffer, newProps.setSceneUniformBuffer, 'setSceneUniformBuffer', changedProps);
        checkMethodDiff(oldProps.setStepId, newProps.setStepId, 'setStepId', changedProps);
        checkMethodDiff(oldProps.setTransformMatrix, newProps.setTransformMatrix, 'setTransformMatrix', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return FiberScenePropsHandler;
}());
var ADTForMesh = 'ADTForMesh', ADTForMeshTexture = 'ADTForMeshTexture', ADTFullscreenUI = 'ADTFullscreenUI', AbstractButton3D = 'AbstractButton3D', AbstractMesh = 'AbstractMesh', AdvancedDynamicTexture = 'AdvancedDynamicTexture', AnaglyphArcRotateCamera = 'AnaglyphArcRotateCamera', AnaglyphFreeCamera = 'AnaglyphFreeCamera', AnaglyphGamepadCamera = 'AnaglyphGamepadCamera', AnaglyphPostProcess = 'AnaglyphPostProcess', AnaglyphUniversalCamera = 'AnaglyphUniversalCamera', ArcFollowCamera = 'ArcFollowCamera', ArcRotateCamera = 'ArcRotateCamera', AttachToBoxBehavior = 'AttachToBoxBehavior', AutoRotationBehavior = 'AutoRotationBehavior', AxisDragGizmo = 'AxisDragGizmo', AxisScaleGizmo = 'AxisScaleGizmo', BackgroundMaterial = 'BackgroundMaterial', BaseSixDofDragBehavior = 'BaseSixDofDragBehavior', BaseSlider = 'BaseSlider', BaseTexture = 'BaseTexture', BlackAndWhitePostProcess = 'BlackAndWhitePostProcess', BloomMergePostProcess = 'BloomMergePostProcess', BlurPostProcess = 'BlurPostProcess', BouncingBehavior = 'BouncingBehavior', BoundingBoxGizmo = 'BoundingBoxGizmo', Box = 'Box', Button = 'Button', Button3D = 'Button3D', Camera = 'Camera', CameraGizmo = 'CameraGizmo', Capsule = 'Capsule', CascadedShadowGenerator = 'CascadedShadowGenerator', Checkbox = 'Checkbox', ChromaticAberrationPostProcess = 'ChromaticAberrationPostProcess', CircleOfConfusionPostProcess = 'CircleOfConfusionPostProcess', ColorCorrectionPostProcess = 'ColorCorrectionPostProcess', ColorGradingTexture = 'ColorGradingTexture', ColorPicker = 'ColorPicker', Container = 'Container', Container3D = 'Container3D', ContentDisplay3D = 'ContentDisplay3D', Control = 'Control', Control3D = 'Control3D', ConvolutionPostProcess = 'ConvolutionPostProcess', CubeTexture = 'CubeTexture', CustomProceduralTexture = 'CustomProceduralTexture', Cylinder = 'Cylinder', CylinderPanel = 'CylinderPanel', DashedLines = 'DashedLines', Decal = 'Decal', DefaultBehavior = 'DefaultBehavior', DefaultRenderingPipeline = 'DefaultRenderingPipeline', DepthOfFieldBlurPostProcess = 'DepthOfFieldBlurPostProcess', DepthOfFieldMergePostProcess = 'DepthOfFieldMergePostProcess', DetailMapConfiguration = 'DetailMapConfiguration', DeviceOrientationCamera = 'DeviceOrientationCamera', DirectionalLight = 'DirectionalLight', Disc = 'Disc', DisplayGrid = 'DisplayGrid', DisplayPassPostProcess = 'DisplayPassPostProcess', DynamicTerrain = 'DynamicTerrain', DynamicTexture = 'DynamicTexture', EffectLayer = 'EffectLayer', Ellipse = 'Ellipse', EngineView = 'EngineView', EnvironmentHelper = 'EnvironmentHelper', EquiRectangularCubeTexture = 'EquiRectangularCubeTexture', ExtractHighlightsPostProcess = 'ExtractHighlightsPostProcess', ExtrudePolygon = 'ExtrudePolygon', ExtrudeShape = 'ExtrudeShape', ExtrudeShapeCustom = 'ExtrudeShapeCustom', FadeInOutBehavior = 'FadeInOutBehavior', FilterPostProcess = 'FilterPostProcess', FluentBackplateMaterial = 'FluentBackplateMaterial', FluentButtonMaterial = 'FluentButtonMaterial', FluentMaterial = 'FluentMaterial', FlyCamera = 'FlyCamera', FocusableButton = 'FocusableButton', FollowBehavior = 'FollowBehavior', FollowCamera = 'FollowCamera', FramingBehavior = 'FramingBehavior', FreeCamera = 'FreeCamera', FxaaPostProcess = 'FxaaPostProcess', GUI3DManager = 'GUI3DManager', GamepadCamera = 'GamepadCamera', Geodesic = 'Geodesic', Gizmo = 'Gizmo', GizmoManager = 'GizmoManager', GlowLayer = 'GlowLayer', Goldberg = 'Goldberg', GoldbergMesh = 'GoldbergMesh', GrainPostProcess = 'GrainPostProcess', Grid = 'Grid', Ground = 'Ground', GroundFromHeightMap = 'GroundFromHeightMap', GroundMesh = 'GroundMesh', HDRCubeTexture = 'HDRCubeTexture', HandConstraintBehavior = 'HandConstraintBehavior', HandMenu = 'HandMenu', HandleMaterial = 'HandleMaterial', HemisphericLight = 'HemisphericLight', HighlightLayer = 'HighlightLayer', HighlightsPostProcess = 'HighlightsPostProcess', HolographicBackplate = 'HolographicBackplate', HolographicButton = 'HolographicButton', HolographicSlate = 'HolographicSlate', HtmlElementTexture = 'HtmlElementTexture', IcoSphere = 'IcoSphere', Image = 'Image', ImageBasedSlider = 'ImageBasedSlider', ImageProcessingConfiguration = 'ImageProcessingConfiguration', ImageProcessingPostProcess = 'ImageProcessingPostProcess', ImageScrollBar = 'ImageScrollBar', InputPassword = 'InputPassword', InputText = 'InputText', InstancedLinesMesh = 'InstancedLinesMesh', InstancedMesh = 'InstancedMesh', Lathe = 'Lathe', Layer = 'Layer', LensRenderingPipeline = 'LensRenderingPipeline', Light = 'Light', LightGizmo = 'LightGizmo', Line = 'Line', LineSystem = 'LineSystem', Lines = 'Lines', LinesMesh = 'LinesMesh', MRDLBackplateMaterial = 'MRDLBackplateMaterial', MRDLSliderBarMaterial = 'MRDLSliderBarMaterial', MRDLSliderThumbMaterial = 'MRDLSliderThumbMaterial', Material = 'Material', MaterialPluginBase = 'MaterialPluginBase', Mesh = 'Mesh', MeshButton3D = 'MeshButton3D', MirrorTexture = 'MirrorTexture', MotionBlurPostProcess = 'MotionBlurPostProcess', MultiLine = 'MultiLine', MultiMaterial = 'MultiMaterial', MultiPointerScaleBehavior = 'MultiPointerScaleBehavior', MultiRenderTarget = 'MultiRenderTarget', MultiviewRenderTarget = 'MultiviewRenderTarget', NearMenu = 'NearMenu', Node = 'Node', NodeMaterial = 'NodeMaterial', NoiseProceduralTexture = 'NoiseProceduralTexture', OcclusionMaterial = 'OcclusionMaterial', PBRAnisotropicConfiguration = 'PBRAnisotropicConfiguration', PBRBRDFConfiguration = 'PBRBRDFConfiguration', PBRBaseMaterial = 'PBRBaseMaterial', PBRBaseSimpleMaterial = 'PBRBaseSimpleMaterial', PBRClearCoatConfiguration = 'PBRClearCoatConfiguration', PBRMaterial = 'PBRMaterial', PBRMetallicRoughnessMaterial = 'PBRMetallicRoughnessMaterial', PBRSheenConfiguration = 'PBRSheenConfiguration', PBRSpecularGlossinessMaterial = 'PBRSpecularGlossinessMaterial', PBRSubSurfaceConfiguration = 'PBRSubSurfaceConfiguration', PassCubePostProcess = 'PassCubePostProcess', PassPostProcess = 'PassPostProcess', PhysicsImpostor = 'PhysicsImpostor', Plane = 'Plane', PlaneDragGizmo = 'PlaneDragGizmo', PlanePanel = 'PlanePanel', PlaneRotationGizmo = 'PlaneRotationGizmo', PointLight = 'PointLight', PointerDragBehavior = 'PointerDragBehavior', PointsCloudSystem = 'PointsCloudSystem', Polygon = 'Polygon', Polyhedron = 'Polyhedron', PositionGizmo = 'PositionGizmo', PostProcess = 'PostProcess', PostProcessRenderPipeline = 'PostProcessRenderPipeline', PrePassConfiguration = 'PrePassConfiguration', PrePassRenderTarget = 'PrePassRenderTarget', ProceduralTexture = 'ProceduralTexture', PushMaterial = 'PushMaterial', RadioButton = 'RadioButton', RawCubeTexture = 'RawCubeTexture', RawTexture = 'RawTexture', RawTexture2DArray = 'RawTexture2DArray', RawTexture3D = 'RawTexture3D', Rectangle = 'Rectangle', RefractionPostProcess = 'RefractionPostProcess', RefractionTexture = 'RefractionTexture', RenderTargetTexture = 'RenderTargetTexture', Ribbon = 'Ribbon', RotationGizmo = 'RotationGizmo', SSAO2RenderingPipeline = 'SSAO2RenderingPipeline', SSAORenderingPipeline = 'SSAORenderingPipeline', ScaleGizmo = 'ScaleGizmo', ScatterPanel = 'ScatterPanel', ScreenSpaceCurvaturePostProcess = 'ScreenSpaceCurvaturePostProcess', ScreenSpaceReflectionPostProcess = 'ScreenSpaceReflectionPostProcess', ScrollBar = 'ScrollBar', ScrollViewer = 'ScrollViewer', SelectionPanel = 'SelectionPanel', ShaderMaterial = 'ShaderMaterial', ShadowGenerator = 'ShadowGenerator', ShadowLight = 'ShadowLight', SharpenPostProcess = 'SharpenPostProcess', SixDofDragBehavior = 'SixDofDragBehavior', SlateGizmo = 'SlateGizmo', Slider = 'Slider', Slider3D = 'Slider3D', Sphere = 'Sphere', SpherePanel = 'SpherePanel', SpotLight = 'SpotLight', StackPanel = 'StackPanel', StackPanel3D = 'StackPanel3D', StandardMaterial = 'StandardMaterial', StandardRenderingPipeline = 'StandardRenderingPipeline', StereoscopicArcRotateCamera = 'StereoscopicArcRotateCamera', StereoscopicFreeCamera = 'StereoscopicFreeCamera', StereoscopicGamepadCamera = 'StereoscopicGamepadCamera', StereoscopicInterlacePostProcess = 'StereoscopicInterlacePostProcess', StereoscopicInterlacePostProcessI = 'StereoscopicInterlacePostProcessI', StereoscopicScreenUniversalCamera = 'StereoscopicScreenUniversalCamera', StereoscopicUniversalCamera = 'StereoscopicUniversalCamera', SubSurfaceScatteringPostProcess = 'SubSurfaceScatteringPostProcess', SurfaceMagnetismBehavior = 'SurfaceMagnetismBehavior', TargetCamera = 'TargetCamera', TextBlock = 'TextBlock', Texture = 'Texture', ThinRenderTargetTexture = 'ThinRenderTargetTexture', ThinTexture = 'ThinTexture', TiledBox = 'TiledBox', TiledGround = 'TiledGround', TiledPlane = 'TiledPlane', ToggleButton = 'ToggleButton', TonemapPostProcess = 'TonemapPostProcess', Torus = 'Torus', TorusKnot = 'TorusKnot', TouchButton3D = 'TouchButton3D', TouchCamera = 'TouchCamera', TouchHolographicButton = 'TouchHolographicButton', TouchHolographicMenu = 'TouchHolographicMenu', TouchMeshButton3D = 'TouchMeshButton3D', TrailMesh = 'TrailMesh', TransformNode = 'TransformNode', Tube = 'Tube', UniversalCamera = 'UniversalCamera', UtilityLayerRenderer = 'UtilityLayerRenderer', VRDeviceOrientationArcRotateCamera = 'VRDeviceOrientationArcRotateCamera', VRDeviceOrientationFreeCamera = 'VRDeviceOrientationFreeCamera', VRDeviceOrientationGamepadCamera = 'VRDeviceOrientationGamepadCamera', VRDistortionCorrectionPostProcess = 'VRDistortionCorrectionPostProcess', VRExperienceHelper = 'VRExperienceHelper', VRMultiviewToSingleviewPostProcess = 'VRMultiviewToSingleviewPostProcess', VideoTexture = 'VideoTexture', Viewport = 'Viewport', VirtualJoysticksCamera = 'VirtualJoysticksCamera', VirtualKeyboard = 'VirtualKeyboard', VolumeBasedPanel = 'VolumeBasedPanel', VolumetricLightScatteringPostProcess = 'VolumetricLightScatteringPostProcess', WebVRFreeCamera = 'WebVRFreeCamera', WebXRCamera = 'WebXRCamera', _ScrollViewerWindow = '_ScrollViewerWindow';
var classesMap = {
    abstractScene: AbstractScene,
    AbstractScene: AbstractScene,
    scene: Scene$2,
    Scene: Scene$2,
    dynamicTerrain: DynamicTerrain$1,
    DynamicTerrain: DynamicTerrain$1,
    camera: Camera$1,
    Camera: Camera$1,
    gizmo: Gizmo$1,
    Gizmo: Gizmo$1,
    gizmoManager: GizmoManager$1,
    GizmoManager: GizmoManager$1,
    environmentHelper: EnvironmentHelper$1,
    EnvironmentHelper: EnvironmentHelper$1,
    effectLayer: EffectLayer$1,
    EffectLayer: EffectLayer$1,
    layer: Layer$1,
    Layer: Layer$1,
    light: Light$1,
    Light: Light$1,
    material: Material$1,
    Material: Material$1,
    materialPluginBase: MaterialPluginBase$1,
    MaterialPluginBase: MaterialPluginBase$1,
    viewport: Viewport$1,
    Viewport: Viewport$1,
    abstractMesh: AbstractMesh$1,
    AbstractMesh: AbstractMesh$1,
    mesh: Mesh$1,
    Mesh: Mesh$1,
    transformNode: TransformNode$1,
    TransformNode: TransformNode$1,
    pointsCloudSystem: PointsCloudSystem$1,
    PointsCloudSystem: PointsCloudSystem$1,
    physicsImpostor: PhysicsImpostor$1,
    PhysicsImpostor: PhysicsImpostor$1,
    postProcess: PostProcess$1,
    PostProcess: PostProcess$1,
    tonemapPostProcess: TonemapPostProcess$1,
    TonemapPostProcess: TonemapPostProcess$1,
    utilityLayerRenderer: UtilityLayerRenderer$1,
    UtilityLayerRenderer: UtilityLayerRenderer$1,
    advancedDynamicTexture: AdvancedDynamicTexture$1,
    AdvancedDynamicTexture: AdvancedDynamicTexture$1,
    gui3DManager: GUI3DManager$1,
    GUI3DManager: GUI3DManager$1,
    autoRotationBehavior: AutoRotationBehavior$1,
    AutoRotationBehavior: AutoRotationBehavior$1,
    bouncingBehavior: BouncingBehavior$1,
    BouncingBehavior: BouncingBehavior$1,
    framingBehavior: FramingBehavior$1,
    FramingBehavior: FramingBehavior$1,
    attachToBoxBehavior: AttachToBoxBehavior$1,
    AttachToBoxBehavior: AttachToBoxBehavior$1,
    baseSixDofDragBehavior: BaseSixDofDragBehavior$1,
    BaseSixDofDragBehavior: BaseSixDofDragBehavior$1,
    fadeInOutBehavior: FadeInOutBehavior$1,
    FadeInOutBehavior: FadeInOutBehavior$1,
    followBehavior: FollowBehavior$1,
    FollowBehavior: FollowBehavior$1,
    handConstraintBehavior: HandConstraintBehavior$1,
    HandConstraintBehavior: HandConstraintBehavior$1,
    multiPointerScaleBehavior: MultiPointerScaleBehavior$1,
    MultiPointerScaleBehavior: MultiPointerScaleBehavior$1,
    pointerDragBehavior: PointerDragBehavior$1,
    PointerDragBehavior: PointerDragBehavior$1,
    sixDofDragBehavior: SixDofDragBehavior$1,
    SixDofDragBehavior: SixDofDragBehavior$1,
    surfaceMagnetismBehavior: SurfaceMagnetismBehavior$1,
    SurfaceMagnetismBehavior: SurfaceMagnetismBehavior$1,
    vrExperienceHelper: VRExperienceHelper$1,
    VRExperienceHelper: VRExperienceHelper$1,
    engineView: EngineView$1,
    EngineView: EngineView$1,
    cascadedShadowGenerator: CascadedShadowGenerator$1,
    CascadedShadowGenerator: CascadedShadowGenerator$1,
    shadowGenerator: ShadowGenerator$1,
    ShadowGenerator: ShadowGenerator$1,
    thinTexture: ThinTexture$1,
    ThinTexture: ThinTexture$1,
    postProcessRenderPipeline: PostProcessRenderPipeline$1,
    PostProcessRenderPipeline: PostProcessRenderPipeline$1,
    control: Control$1,
    Control: Control$1,
    textBlock: TextBlock$1,
    TextBlock: TextBlock$1,
    defaultBehavior: DefaultBehavior$1,
    DefaultBehavior: DefaultBehavior$1,
    control3D: Control3D$1,
    Control3D: Control3D$1,
    node: Node$1,
    Node: Node$1,
    instancedMesh: InstancedMesh$1,
    InstancedMesh: InstancedMesh$1,
    instancedLinesMesh: InstancedLinesMesh$1,
    InstancedLinesMesh: InstancedLinesMesh$1,
    linesMesh: LinesMesh$1,
    LinesMesh: LinesMesh$1,
    groundMesh: GroundMesh$1,
    GroundMesh: GroundMesh$1,
    goldbergMesh: GoldbergMesh$1,
    GoldbergMesh: GoldbergMesh$1,
    trailMesh: TrailMesh$1,
    TrailMesh: TrailMesh$1,
    renderTargetTexture: RenderTargetTexture$1,
    RenderTargetTexture: RenderTargetTexture$1,
    targetCamera: TargetCamera$1,
    TargetCamera: TargetCamera$1,
    freeCamera: FreeCamera$1,
    FreeCamera: FreeCamera$1,
    webXrCamera: WebXRCamera$1,
    WebXRCamera: WebXRCamera$1,
    touchCamera: TouchCamera$1,
    TouchCamera: TouchCamera$1,
    universalCamera: UniversalCamera$1,
    UniversalCamera: UniversalCamera$1,
    gamepadCamera: GamepadCamera$1,
    GamepadCamera: GamepadCamera$1,
    anaglyphGamepadCamera: AnaglyphGamepadCamera$1,
    AnaglyphGamepadCamera: AnaglyphGamepadCamera$1,
    stereoscopicGamepadCamera: StereoscopicGamepadCamera$1,
    StereoscopicGamepadCamera: StereoscopicGamepadCamera$1,
    anaglyphUniversalCamera: AnaglyphUniversalCamera$1,
    AnaglyphUniversalCamera: AnaglyphUniversalCamera$1,
    stereoscopicUniversalCamera: StereoscopicUniversalCamera$1,
    StereoscopicUniversalCamera: StereoscopicUniversalCamera$1,
    stereoscopicScreenUniversalCamera: StereoscopicScreenUniversalCamera$1,
    StereoscopicScreenUniversalCamera: StereoscopicScreenUniversalCamera$1,
    deviceOrientationCamera: DeviceOrientationCamera$1,
    DeviceOrientationCamera: DeviceOrientationCamera$1,
    vrDeviceOrientationFreeCamera: VRDeviceOrientationFreeCamera$1,
    VRDeviceOrientationFreeCamera: VRDeviceOrientationFreeCamera$1,
    vrDeviceOrientationGamepadCamera: VRDeviceOrientationGamepadCamera$1,
    VRDeviceOrientationGamepadCamera: VRDeviceOrientationGamepadCamera$1,
    anaglyphFreeCamera: AnaglyphFreeCamera$1,
    AnaglyphFreeCamera: AnaglyphFreeCamera$1,
    stereoscopicFreeCamera: StereoscopicFreeCamera$1,
    StereoscopicFreeCamera: StereoscopicFreeCamera$1,
    virtualJoysticksCamera: VirtualJoysticksCamera$1,
    VirtualJoysticksCamera: VirtualJoysticksCamera$1,
    webVrFreeCamera: WebVRFreeCamera$1,
    WebVRFreeCamera: WebVRFreeCamera$1,
    arcRotateCamera: ArcRotateCamera$1,
    ArcRotateCamera: ArcRotateCamera$1,
    anaglyphArcRotateCamera: AnaglyphArcRotateCamera$1,
    AnaglyphArcRotateCamera: AnaglyphArcRotateCamera$1,
    stereoscopicArcRotateCamera: StereoscopicArcRotateCamera$1,
    StereoscopicArcRotateCamera: StereoscopicArcRotateCamera$1,
    vrDeviceOrientationArcRotateCamera: VRDeviceOrientationArcRotateCamera$1,
    VRDeviceOrientationArcRotateCamera: VRDeviceOrientationArcRotateCamera$1,
    flyCamera: FlyCamera$1,
    FlyCamera: FlyCamera$1,
    followCamera: FollowCamera$1,
    FollowCamera: FollowCamera$1,
    arcFollowCamera: ArcFollowCamera$1,
    ArcFollowCamera: ArcFollowCamera$1,
    meshBuilder: MeshBuilder,
    MeshBuilder: MeshBuilder,
    pushMaterial: PushMaterial$1,
    PushMaterial: PushMaterial$1,
    nodeMaterial: NodeMaterial$1,
    NodeMaterial: NodeMaterial$1,
    imageProcessingConfiguration: ImageProcessingConfiguration$1,
    ImageProcessingConfiguration: ImageProcessingConfiguration$1,
    shaderMaterial: ShaderMaterial$1,
    ShaderMaterial: ShaderMaterial$1,
    baseTexture: BaseTexture$1,
    BaseTexture: BaseTexture$1,
    occlusionMaterial: OcclusionMaterial$1,
    OcclusionMaterial: OcclusionMaterial$1,
    handleMaterial: HandleMaterial$1,
    HandleMaterial: HandleMaterial$1,
    pbrBaseMaterial: PBRBaseMaterial$1,
    PBRBaseMaterial: PBRBaseMaterial$1,
    pbrBaseSimpleMaterial: PBRBaseSimpleMaterial$1,
    PBRBaseSimpleMaterial: PBRBaseSimpleMaterial$1,
    pbrMetallicRoughnessMaterial: PBRMetallicRoughnessMaterial$1,
    PBRMetallicRoughnessMaterial: PBRMetallicRoughnessMaterial$1,
    pbrSpecularGlossinessMaterial: PBRSpecularGlossinessMaterial$1,
    PBRSpecularGlossinessMaterial: PBRSpecularGlossinessMaterial$1,
    pbrMaterial: PBRMaterial$1,
    PBRMaterial: PBRMaterial$1,
    standardMaterial: StandardMaterial$1,
    StandardMaterial: StandardMaterial$1,
    backgroundMaterial: BackgroundMaterial$1,
    BackgroundMaterial: BackgroundMaterial$1,
    shadowLight: ShadowLight$1,
    ShadowLight: ShadowLight$1,
    fluentMaterial: FluentMaterial$1,
    FluentMaterial: FluentMaterial$1,
    fluentButtonMaterial: FluentButtonMaterial$1,
    FluentButtonMaterial: FluentButtonMaterial$1,
    mrdlSliderBarMaterial: MRDLSliderBarMaterial$1,
    MRDLSliderBarMaterial: MRDLSliderBarMaterial$1,
    texture: Texture$1,
    Texture: Texture$1,
    mrdlSliderThumbMaterial: MRDLSliderThumbMaterial$1,
    MRDLSliderThumbMaterial: MRDLSliderThumbMaterial$1,
    mrdlBackplateMaterial: MRDLBackplateMaterial$1,
    MRDLBackplateMaterial: MRDLBackplateMaterial$1,
    fluentBackplateMaterial: FluentBackplateMaterial$1,
    FluentBackplateMaterial: FluentBackplateMaterial$1,
    multiMaterial: MultiMaterial$1,
    MultiMaterial: MultiMaterial$1,
    directionalLight: DirectionalLight$1,
    DirectionalLight: DirectionalLight$1,
    pointLight: PointLight$1,
    PointLight: PointLight$1,
    spotLight: SpotLight$1,
    SpotLight: SpotLight$1,
    hemisphericLight: HemisphericLight$1,
    HemisphericLight: HemisphericLight$1,
    container: Container$1,
    Container: Container$1,
    rectangle: Rectangle$1,
    Rectangle: Rectangle$1,
    'babylon-button': Button$1,
    Button: Button$1,
    focusableButton: FocusableButton$1,
    FocusableButton: FocusableButton$1,
    selectionPanel: SelectionPanel$1,
    SelectionPanel: SelectionPanel$1,
    scrollViewer: ScrollViewer$1,
    ScrollViewer: ScrollViewer$1,
    'babylon-image': Image$1,
    Image: Image$1,
    toggleButton: ToggleButton$1,
    ToggleButton: ToggleButton$1,
    stackPanel: StackPanel$1,
    StackPanel: StackPanel$1,
    virtualKeyboard: VirtualKeyboard$1,
    VirtualKeyboard: VirtualKeyboard$1,
    'babylon-ellipse': Ellipse$1,
    Ellipse: Ellipse$1,
    grid: Grid$1,
    Grid: Grid$1,
    scrollViewerWindow: _ScrollViewerWindow$1,
    _ScrollViewerWindow: _ScrollViewerWindow$1,
    checkbox: Checkbox$1,
    Checkbox: Checkbox$1,
    colorPicker: ColorPicker$1,
    ColorPicker: ColorPicker$1,
    inputText: InputText$1,
    InputText: InputText$1,
    inputPassword: InputPassword$1,
    InputPassword: InputPassword$1,
    'babylon-line': Line$1,
    Line: Line$1,
    multiLine: MultiLine$1,
    MultiLine: MultiLine$1,
    radioButton: RadioButton$1,
    RadioButton: RadioButton$1,
    baseSlider: BaseSlider$1,
    BaseSlider: BaseSlider$1,
    scrollBar: ScrollBar$1,
    ScrollBar: ScrollBar$1,
    imageScrollBar: ImageScrollBar$1,
    ImageScrollBar: ImageScrollBar$1,
    slider: Slider$1,
    Slider: Slider$1,
    imageBasedSlider: ImageBasedSlider$1,
    ImageBasedSlider: ImageBasedSlider$1,
    displayGrid: DisplayGrid$1,
    DisplayGrid: DisplayGrid$1,
    container3D: Container3D$1,
    Container3D: Container3D$1,
    volumeBasedPanel: VolumeBasedPanel$1,
    VolumeBasedPanel: VolumeBasedPanel$1,
    cylinderPanel: CylinderPanel$1,
    CylinderPanel: CylinderPanel$1,
    touchHolographicMenu: TouchHolographicMenu$1,
    TouchHolographicMenu: TouchHolographicMenu$1,
    touchHolographicButton: TouchHolographicButton$1,
    TouchHolographicButton: TouchHolographicButton$1,
    handMenu: HandMenu$1,
    HandMenu: HandMenu$1,
    nearMenu: NearMenu$1,
    NearMenu: NearMenu$1,
    planePanel: PlanePanel$1,
    PlanePanel: PlanePanel$1,
    scatterPanel: ScatterPanel$1,
    ScatterPanel: ScatterPanel$1,
    spherePanel: SpherePanel$1,
    SpherePanel: SpherePanel$1,
    stackPanel3D: StackPanel3D$1,
    StackPanel3D: StackPanel3D$1,
    contentDisplay3D: ContentDisplay3D$1,
    ContentDisplay3D: ContentDisplay3D$1,
    abstractButton3D: AbstractButton3D$1,
    AbstractButton3D: AbstractButton3D$1,
    button3D: Button3D$1,
    Button3D: Button3D$1,
    holographicButton: HolographicButton$1,
    HolographicButton: HolographicButton$1,
    touchButton3D: TouchButton3D$1,
    TouchButton3D: TouchButton3D$1,
    touchMeshButton3D: TouchMeshButton3D$1,
    TouchMeshButton3D: TouchMeshButton3D$1,
    meshButton3D: MeshButton3D$1,
    MeshButton3D: MeshButton3D$1,
    holographicSlate: HolographicSlate$1,
    HolographicSlate: HolographicSlate$1,
    slider3D: Slider3D$1,
    Slider3D: Slider3D$1,
    holographicBackplate: HolographicBackplate$1,
    HolographicBackplate: HolographicBackplate$1,
    glowLayer: GlowLayer$1,
    GlowLayer: GlowLayer$1,
    highlightLayer: HighlightLayer$1,
    HighlightLayer: HighlightLayer$1,
    cubeTexture: CubeTexture$1,
    CubeTexture: CubeTexture$1,
    rawCubeTexture: RawCubeTexture$1,
    RawCubeTexture: RawCubeTexture$1,
    proceduralTexture: ProceduralTexture$1,
    ProceduralTexture: ProceduralTexture$1,
    customProceduralTexture: CustomProceduralTexture$1,
    CustomProceduralTexture: CustomProceduralTexture$1,
    noiseProceduralTexture: NoiseProceduralTexture$1,
    NoiseProceduralTexture: NoiseProceduralTexture$1,
    rawTexture: RawTexture$1,
    RawTexture: RawTexture$1,
    rawTexture2DArray: RawTexture2DArray$1,
    RawTexture2DArray: RawTexture2DArray$1,
    mirrorTexture: MirrorTexture$1,
    MirrorTexture: MirrorTexture$1,
    multiRenderTarget: MultiRenderTarget$1,
    MultiRenderTarget: MultiRenderTarget$1,
    prePassRenderTarget: PrePassRenderTarget$1,
    PrePassRenderTarget: PrePassRenderTarget$1,
    imageProcessingPostProcess: ImageProcessingPostProcess$1,
    ImageProcessingPostProcess: ImageProcessingPostProcess$1,
    refractionTexture: RefractionTexture$1,
    RefractionTexture: RefractionTexture$1,
    multiviewRenderTarget: MultiviewRenderTarget$1,
    MultiviewRenderTarget: MultiviewRenderTarget$1,
    videoTexture: VideoTexture$1,
    VideoTexture: VideoTexture$1,
    dynamicTexture: DynamicTexture$1,
    DynamicTexture: DynamicTexture$1,
    rawTexture3D: RawTexture3D$1,
    RawTexture3D: RawTexture3D$1,
    colorGradingTexture: ColorGradingTexture$1,
    ColorGradingTexture: ColorGradingTexture$1,
    equiRectangularCubeTexture: EquiRectangularCubeTexture$1,
    EquiRectangularCubeTexture: EquiRectangularCubeTexture$1,
    hdrCubeTexture: HDRCubeTexture$1,
    HDRCubeTexture: HDRCubeTexture$1,
    htmlElementTexture: HtmlElementTexture$1,
    HtmlElementTexture: HtmlElementTexture$1,
    thinRenderTargetTexture: ThinRenderTargetTexture$1,
    ThinRenderTargetTexture: ThinRenderTargetTexture$1,
    defaultRenderingPipeline: DefaultRenderingPipeline$1,
    DefaultRenderingPipeline: DefaultRenderingPipeline$1,
    chromaticAberrationPostProcess: ChromaticAberrationPostProcess$1,
    ChromaticAberrationPostProcess: ChromaticAberrationPostProcess$1,
    fxaaPostProcess: FxaaPostProcess$1,
    FxaaPostProcess: FxaaPostProcess$1,
    grainPostProcess: GrainPostProcess$1,
    GrainPostProcess: GrainPostProcess$1,
    sharpenPostProcess: SharpenPostProcess$1,
    SharpenPostProcess: SharpenPostProcess$1,
    lensRenderingPipeline: LensRenderingPipeline$1,
    LensRenderingPipeline: LensRenderingPipeline$1,
    ssao2RenderingPipeline: SSAO2RenderingPipeline$1,
    SSAO2RenderingPipeline: SSAO2RenderingPipeline$1,
    ssaoRenderingPipeline: SSAORenderingPipeline$1,
    SSAORenderingPipeline: SSAORenderingPipeline$1,
    standardRenderingPipeline: StandardRenderingPipeline$1,
    StandardRenderingPipeline: StandardRenderingPipeline$1,
    screenSpaceReflectionPostProcess: ScreenSpaceReflectionPostProcess$1,
    ScreenSpaceReflectionPostProcess: ScreenSpaceReflectionPostProcess$1,
    blurPostProcess: BlurPostProcess$1,
    BlurPostProcess: BlurPostProcess$1,
    anaglyphPostProcess: AnaglyphPostProcess$1,
    AnaglyphPostProcess: AnaglyphPostProcess$1,
    blackAndWhitePostProcess: BlackAndWhitePostProcess$1,
    BlackAndWhitePostProcess: BlackAndWhitePostProcess$1,
    extractHighlightsPostProcess: ExtractHighlightsPostProcess$1,
    ExtractHighlightsPostProcess: ExtractHighlightsPostProcess$1,
    bloomMergePostProcess: BloomMergePostProcess$1,
    BloomMergePostProcess: BloomMergePostProcess$1,
    depthOfFieldBlurPostProcess: DepthOfFieldBlurPostProcess$1,
    DepthOfFieldBlurPostProcess: DepthOfFieldBlurPostProcess$1,
    circleOfConfusionPostProcess: CircleOfConfusionPostProcess$1,
    CircleOfConfusionPostProcess: CircleOfConfusionPostProcess$1,
    colorCorrectionPostProcess: ColorCorrectionPostProcess$1,
    ColorCorrectionPostProcess: ColorCorrectionPostProcess$1,
    convolutionPostProcess: ConvolutionPostProcess$1,
    ConvolutionPostProcess: ConvolutionPostProcess$1,
    depthOfFieldMergePostProcess: DepthOfFieldMergePostProcess$1,
    DepthOfFieldMergePostProcess: DepthOfFieldMergePostProcess$1,
    displayPassPostProcess: DisplayPassPostProcess$1,
    DisplayPassPostProcess: DisplayPassPostProcess$1,
    filterPostProcess: FilterPostProcess$1,
    FilterPostProcess: FilterPostProcess$1,
    highlightsPostProcess: HighlightsPostProcess$1,
    HighlightsPostProcess: HighlightsPostProcess$1,
    motionBlurPostProcess: MotionBlurPostProcess$1,
    MotionBlurPostProcess: MotionBlurPostProcess$1,
    passPostProcess: PassPostProcess$1,
    PassPostProcess: PassPostProcess$1,
    passCubePostProcess: PassCubePostProcess$1,
    PassCubePostProcess: PassCubePostProcess$1,
    refractionPostProcess: RefractionPostProcess$1,
    RefractionPostProcess: RefractionPostProcess$1,
    stereoscopicInterlacePostProcessI: StereoscopicInterlacePostProcessI$1,
    StereoscopicInterlacePostProcessI: StereoscopicInterlacePostProcessI$1,
    stereoscopicInterlacePostProcess: StereoscopicInterlacePostProcess$1,
    StereoscopicInterlacePostProcess: StereoscopicInterlacePostProcess$1,
    volumetricLightScatteringPostProcess: VolumetricLightScatteringPostProcess$1,
    VolumetricLightScatteringPostProcess: VolumetricLightScatteringPostProcess$1,
    vrDistortionCorrectionPostProcess: VRDistortionCorrectionPostProcess$1,
    VRDistortionCorrectionPostProcess: VRDistortionCorrectionPostProcess$1,
    vrMultiviewToSingleviewPostProcess: VRMultiviewToSingleviewPostProcess$1,
    VRMultiviewToSingleviewPostProcess: VRMultiviewToSingleviewPostProcess$1,
    screenSpaceCurvaturePostProcess: ScreenSpaceCurvaturePostProcess$1,
    ScreenSpaceCurvaturePostProcess: ScreenSpaceCurvaturePostProcess$1,
    subSurfaceScatteringPostProcess: SubSurfaceScatteringPostProcess$1,
    SubSurfaceScatteringPostProcess: SubSurfaceScatteringPostProcess$1,
    planeDragGizmo: PlaneDragGizmo$1,
    PlaneDragGizmo: PlaneDragGizmo$1,
    positionGizmo: PositionGizmo$1,
    PositionGizmo: PositionGizmo$1,
    planeRotationGizmo: PlaneRotationGizmo$1,
    PlaneRotationGizmo: PlaneRotationGizmo$1,
    rotationGizmo: RotationGizmo$1,
    RotationGizmo: RotationGizmo$1,
    axisScaleGizmo: AxisScaleGizmo$1,
    AxisScaleGizmo: AxisScaleGizmo$1,
    scaleGizmo: ScaleGizmo$1,
    ScaleGizmo: ScaleGizmo$1,
    boundingBoxGizmo: BoundingBoxGizmo$1,
    BoundingBoxGizmo: BoundingBoxGizmo$1,
    axisDragGizmo: AxisDragGizmo$1,
    AxisDragGizmo: AxisDragGizmo$1,
    lightGizmo: LightGizmo$1,
    LightGizmo: LightGizmo$1,
    cameraGizmo: CameraGizmo$1,
    CameraGizmo: CameraGizmo$1,
    slateGizmo: SlateGizmo$1,
    SlateGizmo: SlateGizmo$1,
    pbrClearCoatConfiguration: PBRClearCoatConfiguration$1,
    PBRClearCoatConfiguration: PBRClearCoatConfiguration$1,
    pbrAnisotropicConfiguration: PBRAnisotropicConfiguration$1,
    PBRAnisotropicConfiguration: PBRAnisotropicConfiguration$1,
    pbrbrdfConfiguration: PBRBRDFConfiguration$1,
    PBRBRDFConfiguration: PBRBRDFConfiguration$1,
    pbrSheenConfiguration: PBRSheenConfiguration$1,
    PBRSheenConfiguration: PBRSheenConfiguration$1,
    pbrSubSurfaceConfiguration: PBRSubSurfaceConfiguration$1,
    PBRSubSurfaceConfiguration: PBRSubSurfaceConfiguration$1,
    prePassConfiguration: PrePassConfiguration$1,
    PrePassConfiguration: PrePassConfiguration$1,
    detailMapConfiguration: DetailMapConfiguration$1,
    DetailMapConfiguration: DetailMapConfiguration$1,
};
var intrinsicClassMap = {
    abstractScene: 'AbstractScene',
    scene: 'Scene',
    dynamicTerrain: 'DynamicTerrain',
    camera: 'Camera',
    gizmo: 'Gizmo',
    gizmoManager: 'GizmoManager',
    environmentHelper: 'EnvironmentHelper',
    effectLayer: 'EffectLayer',
    layer: 'Layer',
    light: 'Light',
    material: 'Material',
    materialPluginBase: 'MaterialPluginBase',
    viewport: 'Viewport',
    abstractMesh: 'AbstractMesh',
    mesh: 'Mesh',
    transformNode: 'TransformNode',
    pointsCloudSystem: 'PointsCloudSystem',
    physicsImpostor: 'PhysicsImpostor',
    postProcess: 'PostProcess',
    tonemapPostProcess: 'TonemapPostProcess',
    utilityLayerRenderer: 'UtilityLayerRenderer',
    advancedDynamicTexture: 'AdvancedDynamicTexture',
    gui3DManager: 'GUI3DManager',
    autoRotationBehavior: 'AutoRotationBehavior',
    bouncingBehavior: 'BouncingBehavior',
    framingBehavior: 'FramingBehavior',
    attachToBoxBehavior: 'AttachToBoxBehavior',
    baseSixDofDragBehavior: 'BaseSixDofDragBehavior',
    fadeInOutBehavior: 'FadeInOutBehavior',
    followBehavior: 'FollowBehavior',
    handConstraintBehavior: 'HandConstraintBehavior',
    multiPointerScaleBehavior: 'MultiPointerScaleBehavior',
    pointerDragBehavior: 'PointerDragBehavior',
    sixDofDragBehavior: 'SixDofDragBehavior',
    surfaceMagnetismBehavior: 'SurfaceMagnetismBehavior',
    vrExperienceHelper: 'VRExperienceHelper',
    engineView: 'EngineView',
    cascadedShadowGenerator: 'CascadedShadowGenerator',
    shadowGenerator: 'ShadowGenerator',
    thinTexture: 'ThinTexture',
    postProcessRenderPipeline: 'PostProcessRenderPipeline',
    control: 'Control',
    textBlock: 'TextBlock',
    defaultBehavior: 'DefaultBehavior',
    control3D: 'Control3D',
    node: 'Node',
    instancedMesh: 'InstancedMesh',
    instancedLinesMesh: 'InstancedLinesMesh',
    linesMesh: 'LinesMesh',
    groundMesh: 'GroundMesh',
    goldbergMesh: 'GoldbergMesh',
    trailMesh: 'TrailMesh',
    renderTargetTexture: 'RenderTargetTexture',
    targetCamera: 'TargetCamera',
    freeCamera: 'FreeCamera',
    webXrCamera: 'WebXRCamera',
    touchCamera: 'TouchCamera',
    universalCamera: 'UniversalCamera',
    gamepadCamera: 'GamepadCamera',
    anaglyphGamepadCamera: 'AnaglyphGamepadCamera',
    stereoscopicGamepadCamera: 'StereoscopicGamepadCamera',
    anaglyphUniversalCamera: 'AnaglyphUniversalCamera',
    stereoscopicUniversalCamera: 'StereoscopicUniversalCamera',
    stereoscopicScreenUniversalCamera: 'StereoscopicScreenUniversalCamera',
    deviceOrientationCamera: 'DeviceOrientationCamera',
    vrDeviceOrientationFreeCamera: 'VRDeviceOrientationFreeCamera',
    vrDeviceOrientationGamepadCamera: 'VRDeviceOrientationGamepadCamera',
    anaglyphFreeCamera: 'AnaglyphFreeCamera',
    stereoscopicFreeCamera: 'StereoscopicFreeCamera',
    virtualJoysticksCamera: 'VirtualJoysticksCamera',
    webVrFreeCamera: 'WebVRFreeCamera',
    arcRotateCamera: 'ArcRotateCamera',
    anaglyphArcRotateCamera: 'AnaglyphArcRotateCamera',
    stereoscopicArcRotateCamera: 'StereoscopicArcRotateCamera',
    vrDeviceOrientationArcRotateCamera: 'VRDeviceOrientationArcRotateCamera',
    flyCamera: 'FlyCamera',
    followCamera: 'FollowCamera',
    arcFollowCamera: 'ArcFollowCamera',
    meshBuilder: 'MeshBuilder',
    pushMaterial: 'PushMaterial',
    nodeMaterial: 'NodeMaterial',
    imageProcessingConfiguration: 'ImageProcessingConfiguration',
    shaderMaterial: 'ShaderMaterial',
    baseTexture: 'BaseTexture',
    occlusionMaterial: 'OcclusionMaterial',
    handleMaterial: 'HandleMaterial',
    pbrBaseMaterial: 'PBRBaseMaterial',
    pbrBaseSimpleMaterial: 'PBRBaseSimpleMaterial',
    pbrMetallicRoughnessMaterial: 'PBRMetallicRoughnessMaterial',
    pbrSpecularGlossinessMaterial: 'PBRSpecularGlossinessMaterial',
    pbrMaterial: 'PBRMaterial',
    standardMaterial: 'StandardMaterial',
    backgroundMaterial: 'BackgroundMaterial',
    shadowLight: 'ShadowLight',
    fluentMaterial: 'FluentMaterial',
    fluentButtonMaterial: 'FluentButtonMaterial',
    mrdlSliderBarMaterial: 'MRDLSliderBarMaterial',
    texture: 'Texture',
    mrdlSliderThumbMaterial: 'MRDLSliderThumbMaterial',
    mrdlBackplateMaterial: 'MRDLBackplateMaterial',
    fluentBackplateMaterial: 'FluentBackplateMaterial',
    multiMaterial: 'MultiMaterial',
    directionalLight: 'DirectionalLight',
    pointLight: 'PointLight',
    spotLight: 'SpotLight',
    hemisphericLight: 'HemisphericLight',
    container: 'Container',
    rectangle: 'Rectangle',
    'babylon-button': 'Button',
    focusableButton: 'FocusableButton',
    selectionPanel: 'SelectionPanel',
    scrollViewer: 'ScrollViewer',
    'babylon-image': 'Image',
    toggleButton: 'ToggleButton',
    stackPanel: 'StackPanel',
    virtualKeyboard: 'VirtualKeyboard',
    'babylon-ellipse': 'Ellipse',
    grid: 'Grid',
    scrollViewerWindow: '_ScrollViewerWindow',
    checkbox: 'Checkbox',
    colorPicker: 'ColorPicker',
    inputText: 'InputText',
    inputPassword: 'InputPassword',
    'babylon-line': 'Line',
    multiLine: 'MultiLine',
    radioButton: 'RadioButton',
    baseSlider: 'BaseSlider',
    scrollBar: 'ScrollBar',
    imageScrollBar: 'ImageScrollBar',
    slider: 'Slider',
    imageBasedSlider: 'ImageBasedSlider',
    displayGrid: 'DisplayGrid',
    container3D: 'Container3D',
    volumeBasedPanel: 'VolumeBasedPanel',
    cylinderPanel: 'CylinderPanel',
    touchHolographicMenu: 'TouchHolographicMenu',
    touchHolographicButton: 'TouchHolographicButton',
    handMenu: 'HandMenu',
    nearMenu: 'NearMenu',
    planePanel: 'PlanePanel',
    scatterPanel: 'ScatterPanel',
    spherePanel: 'SpherePanel',
    stackPanel3D: 'StackPanel3D',
    contentDisplay3D: 'ContentDisplay3D',
    abstractButton3D: 'AbstractButton3D',
    button3D: 'Button3D',
    holographicButton: 'HolographicButton',
    touchButton3D: 'TouchButton3D',
    touchMeshButton3D: 'TouchMeshButton3D',
    meshButton3D: 'MeshButton3D',
    holographicSlate: 'HolographicSlate',
    slider3D: 'Slider3D',
    holographicBackplate: 'HolographicBackplate',
    glowLayer: 'GlowLayer',
    highlightLayer: 'HighlightLayer',
    cubeTexture: 'CubeTexture',
    rawCubeTexture: 'RawCubeTexture',
    proceduralTexture: 'ProceduralTexture',
    customProceduralTexture: 'CustomProceduralTexture',
    noiseProceduralTexture: 'NoiseProceduralTexture',
    rawTexture: 'RawTexture',
    rawTexture2DArray: 'RawTexture2DArray',
    mirrorTexture: 'MirrorTexture',
    multiRenderTarget: 'MultiRenderTarget',
    prePassRenderTarget: 'PrePassRenderTarget',
    imageProcessingPostProcess: 'ImageProcessingPostProcess',
    refractionTexture: 'RefractionTexture',
    multiviewRenderTarget: 'MultiviewRenderTarget',
    videoTexture: 'VideoTexture',
    dynamicTexture: 'DynamicTexture',
    rawTexture3D: 'RawTexture3D',
    colorGradingTexture: 'ColorGradingTexture',
    equiRectangularCubeTexture: 'EquiRectangularCubeTexture',
    hdrCubeTexture: 'HDRCubeTexture',
    htmlElementTexture: 'HtmlElementTexture',
    thinRenderTargetTexture: 'ThinRenderTargetTexture',
    defaultRenderingPipeline: 'DefaultRenderingPipeline',
    chromaticAberrationPostProcess: 'ChromaticAberrationPostProcess',
    fxaaPostProcess: 'FxaaPostProcess',
    grainPostProcess: 'GrainPostProcess',
    sharpenPostProcess: 'SharpenPostProcess',
    lensRenderingPipeline: 'LensRenderingPipeline',
    ssao2RenderingPipeline: 'SSAO2RenderingPipeline',
    ssaoRenderingPipeline: 'SSAORenderingPipeline',
    standardRenderingPipeline: 'StandardRenderingPipeline',
    screenSpaceReflectionPostProcess: 'ScreenSpaceReflectionPostProcess',
    blurPostProcess: 'BlurPostProcess',
    anaglyphPostProcess: 'AnaglyphPostProcess',
    blackAndWhitePostProcess: 'BlackAndWhitePostProcess',
    extractHighlightsPostProcess: 'ExtractHighlightsPostProcess',
    bloomMergePostProcess: 'BloomMergePostProcess',
    depthOfFieldBlurPostProcess: 'DepthOfFieldBlurPostProcess',
    circleOfConfusionPostProcess: 'CircleOfConfusionPostProcess',
    colorCorrectionPostProcess: 'ColorCorrectionPostProcess',
    convolutionPostProcess: 'ConvolutionPostProcess',
    depthOfFieldMergePostProcess: 'DepthOfFieldMergePostProcess',
    displayPassPostProcess: 'DisplayPassPostProcess',
    filterPostProcess: 'FilterPostProcess',
    highlightsPostProcess: 'HighlightsPostProcess',
    motionBlurPostProcess: 'MotionBlurPostProcess',
    passPostProcess: 'PassPostProcess',
    passCubePostProcess: 'PassCubePostProcess',
    refractionPostProcess: 'RefractionPostProcess',
    stereoscopicInterlacePostProcessI: 'StereoscopicInterlacePostProcessI',
    stereoscopicInterlacePostProcess: 'StereoscopicInterlacePostProcess',
    volumetricLightScatteringPostProcess: 'VolumetricLightScatteringPostProcess',
    vrDistortionCorrectionPostProcess: 'VRDistortionCorrectionPostProcess',
    vrMultiviewToSingleviewPostProcess: 'VRMultiviewToSingleviewPostProcess',
    screenSpaceCurvaturePostProcess: 'ScreenSpaceCurvaturePostProcess',
    subSurfaceScatteringPostProcess: 'SubSurfaceScatteringPostProcess',
    planeDragGizmo: 'PlaneDragGizmo',
    positionGizmo: 'PositionGizmo',
    planeRotationGizmo: 'PlaneRotationGizmo',
    rotationGizmo: 'RotationGizmo',
    axisScaleGizmo: 'AxisScaleGizmo',
    scaleGizmo: 'ScaleGizmo',
    boundingBoxGizmo: 'BoundingBoxGizmo',
    axisDragGizmo: 'AxisDragGizmo',
    lightGizmo: 'LightGizmo',
    cameraGizmo: 'CameraGizmo',
    slateGizmo: 'SlateGizmo',
    pbrClearCoatConfiguration: 'PBRClearCoatConfiguration',
    pbrAnisotropicConfiguration: 'PBRAnisotropicConfiguration',
    pbrbrdfConfiguration: 'PBRBRDFConfiguration',
    pbrSheenConfiguration: 'PBRSheenConfiguration',
    pbrSubSurfaceConfiguration: 'PBRSubSurfaceConfiguration',
    prePassConfiguration: 'PrePassConfiguration',
    detailMapConfiguration: 'DetailMapConfiguration',
    adtForMesh: 'ADTForMesh',
    adtForMeshTexture: 'ADTForMeshTexture',
    adtFullscreenUi: 'ADTFullscreenUI',
    box: 'Box',
    capsule: 'Capsule',
    cylinder: 'Cylinder',
    dashedLines: 'DashedLines',
    decal: 'Decal',
    disc: 'Disc',
    extrudePolygon: 'ExtrudePolygon',
    extrudeShape: 'ExtrudeShape',
    extrudeShapeCustom: 'ExtrudeShapeCustom',
    geodesic: 'Geodesic',
    goldberg: 'Goldberg',
    ground: 'Ground',
    groundFromHeightMap: 'GroundFromHeightMap',
    icoSphere: 'IcoSphere',
    lathe: 'Lathe',
    lines: 'Lines',
    lineSystem: 'LineSystem',
    plane: 'Plane',
    'babylon-polygon': 'Polygon',
    polyhedron: 'Polyhedron',
    ribbon: 'Ribbon',
    sphere: 'Sphere',
    tiledBox: 'TiledBox',
    tiledGround: 'TiledGround',
    tiledPlane: 'TiledPlane',
    torus: 'Torus',
    torusKnot: 'TorusKnot',
    tube: 'Tube',
};
function babylonClassFactory(importAlias) {
    return classesMap[importAlias];
}

var GENERATED = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FiberNodePropsHandler: FiberNodePropsHandler,
    FiberNode: FiberNode,
    FiberTransformNodePropsHandler: FiberTransformNodePropsHandler,
    FiberTransformNode: FiberTransformNode,
    FiberAbstractMeshPropsHandler: FiberAbstractMeshPropsHandler,
    FiberAbstractMesh: FiberAbstractMesh,
    FiberInstancedMeshPropsHandler: FiberInstancedMeshPropsHandler,
    FiberInstancedMesh: FiberInstancedMesh,
    FiberInstancedLinesMeshPropsHandler: FiberInstancedLinesMeshPropsHandler,
    FiberInstancedLinesMesh: FiberInstancedLinesMesh,
    FiberMeshPropsHandler: FiberMeshPropsHandler,
    FiberMesh: FiberMesh,
    FiberGroundMeshPropsHandler: FiberGroundMeshPropsHandler,
    FiberGroundMesh: FiberGroundMesh,
    FiberLinesMeshPropsHandler: FiberLinesMeshPropsHandler,
    FiberLinesMesh: FiberLinesMesh,
    FiberGoldbergMeshPropsHandler: FiberGoldbergMeshPropsHandler,
    FiberGoldbergMesh: FiberGoldbergMesh,
    FiberTrailMeshPropsHandler: FiberTrailMeshPropsHandler,
    FiberTrailMesh: FiberTrailMesh,
    FiberCameraPropsHandler: FiberCameraPropsHandler,
    FiberCamera: FiberCamera,
    FiberTargetCameraPropsHandler: FiberTargetCameraPropsHandler,
    FiberTargetCamera: FiberTargetCamera,
    FiberFreeCameraPropsHandler: FiberFreeCameraPropsHandler,
    FiberFreeCamera: FiberFreeCamera,
    FiberWebXRCameraPropsHandler: FiberWebXRCameraPropsHandler,
    FiberWebXRCamera: FiberWebXRCamera,
    FiberTouchCameraPropsHandler: FiberTouchCameraPropsHandler,
    FiberTouchCamera: FiberTouchCamera,
    FiberUniversalCameraPropsHandler: FiberUniversalCameraPropsHandler,
    FiberUniversalCamera: FiberUniversalCamera,
    FiberGamepadCameraPropsHandler: FiberGamepadCameraPropsHandler,
    FiberGamepadCamera: FiberGamepadCamera,
    FiberAnaglyphGamepadCameraPropsHandler: FiberAnaglyphGamepadCameraPropsHandler,
    FiberAnaglyphGamepadCamera: FiberAnaglyphGamepadCamera,
    FiberStereoscopicGamepadCameraPropsHandler: FiberStereoscopicGamepadCameraPropsHandler,
    FiberStereoscopicGamepadCamera: FiberStereoscopicGamepadCamera,
    FiberAnaglyphUniversalCameraPropsHandler: FiberAnaglyphUniversalCameraPropsHandler,
    FiberAnaglyphUniversalCamera: FiberAnaglyphUniversalCamera,
    FiberStereoscopicUniversalCameraPropsHandler: FiberStereoscopicUniversalCameraPropsHandler,
    FiberStereoscopicUniversalCamera: FiberStereoscopicUniversalCamera,
    FiberStereoscopicScreenUniversalCameraPropsHandler: FiberStereoscopicScreenUniversalCameraPropsHandler,
    FiberStereoscopicScreenUniversalCamera: FiberStereoscopicScreenUniversalCamera,
    FiberDeviceOrientationCameraPropsHandler: FiberDeviceOrientationCameraPropsHandler,
    FiberDeviceOrientationCamera: FiberDeviceOrientationCamera,
    FiberVRDeviceOrientationFreeCameraPropsHandler: FiberVRDeviceOrientationFreeCameraPropsHandler,
    FiberVRDeviceOrientationFreeCamera: FiberVRDeviceOrientationFreeCamera,
    FiberVRDeviceOrientationGamepadCameraPropsHandler: FiberVRDeviceOrientationGamepadCameraPropsHandler,
    FiberVRDeviceOrientationGamepadCamera: FiberVRDeviceOrientationGamepadCamera,
    FiberAnaglyphFreeCameraPropsHandler: FiberAnaglyphFreeCameraPropsHandler,
    FiberAnaglyphFreeCamera: FiberAnaglyphFreeCamera,
    FiberStereoscopicFreeCameraPropsHandler: FiberStereoscopicFreeCameraPropsHandler,
    FiberStereoscopicFreeCamera: FiberStereoscopicFreeCamera,
    FiberVirtualJoysticksCameraPropsHandler: FiberVirtualJoysticksCameraPropsHandler,
    FiberVirtualJoysticksCamera: FiberVirtualJoysticksCamera,
    FiberWebVRFreeCameraPropsHandler: FiberWebVRFreeCameraPropsHandler,
    FiberWebVRFreeCamera: FiberWebVRFreeCamera,
    FiberArcRotateCameraPropsHandler: FiberArcRotateCameraPropsHandler,
    FiberArcRotateCamera: FiberArcRotateCamera,
    FiberAnaglyphArcRotateCameraPropsHandler: FiberAnaglyphArcRotateCameraPropsHandler,
    FiberAnaglyphArcRotateCamera: FiberAnaglyphArcRotateCamera,
    FiberStereoscopicArcRotateCameraPropsHandler: FiberStereoscopicArcRotateCameraPropsHandler,
    FiberStereoscopicArcRotateCamera: FiberStereoscopicArcRotateCamera,
    FiberVRDeviceOrientationArcRotateCameraPropsHandler: FiberVRDeviceOrientationArcRotateCameraPropsHandler,
    FiberVRDeviceOrientationArcRotateCamera: FiberVRDeviceOrientationArcRotateCamera,
    FiberFlyCameraPropsHandler: FiberFlyCameraPropsHandler,
    FiberFlyCamera: FiberFlyCamera,
    FiberFollowCameraPropsHandler: FiberFollowCameraPropsHandler,
    FiberFollowCamera: FiberFollowCamera,
    FiberArcFollowCameraPropsHandler: FiberArcFollowCameraPropsHandler,
    FiberArcFollowCamera: FiberArcFollowCamera,
    FiberBox: FiberBox,
    FiberTiledBox: FiberTiledBox,
    FiberSphere: FiberSphere,
    FiberDisc: FiberDisc,
    FiberIcoSphere: FiberIcoSphere,
    FiberRibbon: FiberRibbon,
    FiberCylinder: FiberCylinder,
    FiberTorus: FiberTorus,
    FiberTorusKnot: FiberTorusKnot,
    FiberLineSystem: FiberLineSystem,
    FiberLines: FiberLines,
    FiberDashedLines: FiberDashedLines,
    FiberExtrudeShape: FiberExtrudeShape,
    FiberExtrudeShapeCustom: FiberExtrudeShapeCustom,
    FiberLathe: FiberLathe,
    FiberTiledPlane: FiberTiledPlane,
    FiberPlane: FiberPlane,
    FiberGround: FiberGround,
    FiberTiledGround: FiberTiledGround,
    FiberGroundFromHeightMap: FiberGroundFromHeightMap,
    FiberPolygon: FiberPolygon,
    FiberExtrudePolygon: FiberExtrudePolygon,
    FiberTube: FiberTube,
    FiberPolyhedron: FiberPolyhedron,
    FiberGeodesic: FiberGeodesic,
    FiberGoldberg: FiberGoldberg,
    FiberDecal: FiberDecal,
    FiberCapsule: FiberCapsule,
    FiberMaterialPropsHandler: FiberMaterialPropsHandler,
    FiberMaterial: FiberMaterial,
    FiberPushMaterialPropsHandler: FiberPushMaterialPropsHandler,
    FiberPushMaterial: FiberPushMaterial,
    FiberNodeMaterialPropsHandler: FiberNodeMaterialPropsHandler,
    FiberNodeMaterial: FiberNodeMaterial,
    FiberShaderMaterialPropsHandler: FiberShaderMaterialPropsHandler,
    FiberShaderMaterial: FiberShaderMaterial,
    FiberOcclusionMaterialPropsHandler: FiberOcclusionMaterialPropsHandler,
    FiberOcclusionMaterial: FiberOcclusionMaterial,
    FiberHandleMaterialPropsHandler: FiberHandleMaterialPropsHandler,
    FiberHandleMaterial: FiberHandleMaterial,
    FiberPBRBaseMaterialPropsHandler: FiberPBRBaseMaterialPropsHandler,
    FiberPBRBaseMaterial: FiberPBRBaseMaterial,
    FiberPBRBaseSimpleMaterialPropsHandler: FiberPBRBaseSimpleMaterialPropsHandler,
    FiberPBRBaseSimpleMaterial: FiberPBRBaseSimpleMaterial,
    FiberPBRMetallicRoughnessMaterialPropsHandler: FiberPBRMetallicRoughnessMaterialPropsHandler,
    FiberPBRMetallicRoughnessMaterial: FiberPBRMetallicRoughnessMaterial,
    FiberPBRSpecularGlossinessMaterialPropsHandler: FiberPBRSpecularGlossinessMaterialPropsHandler,
    FiberPBRSpecularGlossinessMaterial: FiberPBRSpecularGlossinessMaterial,
    FiberPBRMaterialPropsHandler: FiberPBRMaterialPropsHandler,
    FiberPBRMaterial: FiberPBRMaterial,
    FiberStandardMaterialPropsHandler: FiberStandardMaterialPropsHandler,
    FiberStandardMaterial: FiberStandardMaterial,
    FiberBackgroundMaterialPropsHandler: FiberBackgroundMaterialPropsHandler,
    FiberBackgroundMaterial: FiberBackgroundMaterial,
    FiberFluentMaterialPropsHandler: FiberFluentMaterialPropsHandler,
    FiberFluentMaterial: FiberFluentMaterial,
    FiberFluentButtonMaterialPropsHandler: FiberFluentButtonMaterialPropsHandler,
    FiberFluentButtonMaterial: FiberFluentButtonMaterial,
    FiberMRDLSliderBarMaterialPropsHandler: FiberMRDLSliderBarMaterialPropsHandler,
    FiberMRDLSliderBarMaterial: FiberMRDLSliderBarMaterial,
    FiberMRDLSliderThumbMaterialPropsHandler: FiberMRDLSliderThumbMaterialPropsHandler,
    FiberMRDLSliderThumbMaterial: FiberMRDLSliderThumbMaterial,
    FiberMRDLBackplateMaterialPropsHandler: FiberMRDLBackplateMaterialPropsHandler,
    FiberMRDLBackplateMaterial: FiberMRDLBackplateMaterial,
    FiberFluentBackplateMaterialPropsHandler: FiberFluentBackplateMaterialPropsHandler,
    FiberFluentBackplateMaterial: FiberFluentBackplateMaterial,
    FiberMultiMaterialPropsHandler: FiberMultiMaterialPropsHandler,
    FiberMultiMaterial: FiberMultiMaterial,
    FiberLightPropsHandler: FiberLightPropsHandler,
    FiberLight: FiberLight,
    FiberShadowLightPropsHandler: FiberShadowLightPropsHandler,
    FiberShadowLight: FiberShadowLight,
    FiberDirectionalLightPropsHandler: FiberDirectionalLightPropsHandler,
    FiberDirectionalLight: FiberDirectionalLight,
    FiberPointLightPropsHandler: FiberPointLightPropsHandler,
    FiberPointLight: FiberPointLight,
    FiberSpotLightPropsHandler: FiberSpotLightPropsHandler,
    FiberSpotLight: FiberSpotLight,
    FiberHemisphericLightPropsHandler: FiberHemisphericLightPropsHandler,
    FiberHemisphericLight: FiberHemisphericLight,
    FiberControlPropsHandler: FiberControlPropsHandler,
    FiberControl: FiberControl,
    FiberContainerPropsHandler: FiberContainerPropsHandler,
    FiberContainer: FiberContainer,
    FiberRectanglePropsHandler: FiberRectanglePropsHandler,
    FiberRectangle: FiberRectangle,
    FiberButtonPropsHandler: FiberButtonPropsHandler,
    FiberButton: FiberButton,
    FiberFocusableButtonPropsHandler: FiberFocusableButtonPropsHandler,
    FiberFocusableButton: FiberFocusableButton,
    FiberSelectionPanelPropsHandler: FiberSelectionPanelPropsHandler,
    FiberSelectionPanel: FiberSelectionPanel,
    FiberScrollViewerPropsHandler: FiberScrollViewerPropsHandler,
    FiberScrollViewer: FiberScrollViewer,
    FiberToggleButtonPropsHandler: FiberToggleButtonPropsHandler,
    FiberToggleButton: FiberToggleButton,
    FiberStackPanelPropsHandler: FiberStackPanelPropsHandler,
    FiberStackPanel: FiberStackPanel,
    FiberVirtualKeyboardPropsHandler: FiberVirtualKeyboardPropsHandler,
    FiberVirtualKeyboard: FiberVirtualKeyboard,
    FiberEllipsePropsHandler: FiberEllipsePropsHandler,
    FiberEllipse: FiberEllipse,
    FiberGridPropsHandler: FiberGridPropsHandler,
    FiberGrid: FiberGrid,
    Fiber_ScrollViewerWindowPropsHandler: Fiber_ScrollViewerWindowPropsHandler,
    Fiber_ScrollViewerWindow: Fiber_ScrollViewerWindow,
    FiberTextBlockPropsHandler: FiberTextBlockPropsHandler,
    FiberTextBlock: FiberTextBlock,
    FiberImagePropsHandler: FiberImagePropsHandler,
    FiberImage: FiberImage,
    FiberCheckboxPropsHandler: FiberCheckboxPropsHandler,
    FiberCheckbox: FiberCheckbox,
    FiberColorPickerPropsHandler: FiberColorPickerPropsHandler,
    FiberColorPicker: FiberColorPicker,
    FiberInputTextPropsHandler: FiberInputTextPropsHandler,
    FiberInputText: FiberInputText,
    FiberInputPasswordPropsHandler: FiberInputPasswordPropsHandler,
    FiberInputPassword: FiberInputPassword,
    FiberLinePropsHandler: FiberLinePropsHandler,
    FiberLine: FiberLine,
    FiberMultiLinePropsHandler: FiberMultiLinePropsHandler,
    FiberMultiLine: FiberMultiLine,
    FiberRadioButtonPropsHandler: FiberRadioButtonPropsHandler,
    FiberRadioButton: FiberRadioButton,
    FiberBaseSliderPropsHandler: FiberBaseSliderPropsHandler,
    FiberBaseSlider: FiberBaseSlider,
    FiberScrollBarPropsHandler: FiberScrollBarPropsHandler,
    FiberScrollBar: FiberScrollBar,
    FiberImageScrollBarPropsHandler: FiberImageScrollBarPropsHandler,
    FiberImageScrollBar: FiberImageScrollBar,
    FiberSliderPropsHandler: FiberSliderPropsHandler,
    FiberSlider: FiberSlider,
    FiberImageBasedSliderPropsHandler: FiberImageBasedSliderPropsHandler,
    FiberImageBasedSlider: FiberImageBasedSlider,
    FiberDisplayGridPropsHandler: FiberDisplayGridPropsHandler,
    FiberDisplayGrid: FiberDisplayGrid,
    FiberControl3DPropsHandler: FiberControl3DPropsHandler,
    FiberControl3D: FiberControl3D,
    FiberContainer3DPropsHandler: FiberContainer3DPropsHandler,
    FiberContainer3D: FiberContainer3D,
    FiberVolumeBasedPanelPropsHandler: FiberVolumeBasedPanelPropsHandler,
    FiberVolumeBasedPanel: FiberVolumeBasedPanel,
    FiberCylinderPanelPropsHandler: FiberCylinderPanelPropsHandler,
    FiberCylinderPanel: FiberCylinderPanel,
    FiberTouchHolographicMenuPropsHandler: FiberTouchHolographicMenuPropsHandler,
    FiberTouchHolographicMenu: FiberTouchHolographicMenu,
    FiberHandMenuPropsHandler: FiberHandMenuPropsHandler,
    FiberHandMenu: FiberHandMenu,
    FiberNearMenuPropsHandler: FiberNearMenuPropsHandler,
    FiberNearMenu: FiberNearMenu,
    FiberPlanePanelPropsHandler: FiberPlanePanelPropsHandler,
    FiberPlanePanel: FiberPlanePanel,
    FiberScatterPanelPropsHandler: FiberScatterPanelPropsHandler,
    FiberScatterPanel: FiberScatterPanel,
    FiberSpherePanelPropsHandler: FiberSpherePanelPropsHandler,
    FiberSpherePanel: FiberSpherePanel,
    FiberStackPanel3DPropsHandler: FiberStackPanel3DPropsHandler,
    FiberStackPanel3D: FiberStackPanel3D,
    FiberContentDisplay3DPropsHandler: FiberContentDisplay3DPropsHandler,
    FiberContentDisplay3D: FiberContentDisplay3D,
    FiberAbstractButton3DPropsHandler: FiberAbstractButton3DPropsHandler,
    FiberAbstractButton3D: FiberAbstractButton3D,
    FiberButton3DPropsHandler: FiberButton3DPropsHandler,
    FiberButton3D: FiberButton3D,
    FiberHolographicButtonPropsHandler: FiberHolographicButtonPropsHandler,
    FiberHolographicButton: FiberHolographicButton,
    FiberTouchButton3DPropsHandler: FiberTouchButton3DPropsHandler,
    FiberTouchButton3D: FiberTouchButton3D,
    FiberTouchHolographicButtonPropsHandler: FiberTouchHolographicButtonPropsHandler,
    FiberTouchHolographicButton: FiberTouchHolographicButton,
    FiberTouchMeshButton3DPropsHandler: FiberTouchMeshButton3DPropsHandler,
    FiberTouchMeshButton3D: FiberTouchMeshButton3D,
    FiberMeshButton3DPropsHandler: FiberMeshButton3DPropsHandler,
    FiberMeshButton3D: FiberMeshButton3D,
    FiberHolographicSlatePropsHandler: FiberHolographicSlatePropsHandler,
    FiberHolographicSlate: FiberHolographicSlate,
    FiberSlider3DPropsHandler: FiberSlider3DPropsHandler,
    FiberSlider3D: FiberSlider3D,
    FiberHolographicBackplatePropsHandler: FiberHolographicBackplatePropsHandler,
    FiberHolographicBackplate: FiberHolographicBackplate,
    FiberEffectLayerPropsHandler: FiberEffectLayerPropsHandler,
    FiberEffectLayer: FiberEffectLayer,
    FiberGlowLayerPropsHandler: FiberGlowLayerPropsHandler,
    FiberGlowLayer: FiberGlowLayer,
    FiberHighlightLayerPropsHandler: FiberHighlightLayerPropsHandler,
    FiberHighlightLayer: FiberHighlightLayer,
    FiberThinTexturePropsHandler: FiberThinTexturePropsHandler,
    FiberThinTexture: FiberThinTexture,
    FiberBaseTexturePropsHandler: FiberBaseTexturePropsHandler,
    FiberBaseTexture: FiberBaseTexture,
    FiberCubeTexturePropsHandler: FiberCubeTexturePropsHandler,
    FiberCubeTexture: FiberCubeTexture,
    FiberRawCubeTexturePropsHandler: FiberRawCubeTexturePropsHandler,
    FiberRawCubeTexture: FiberRawCubeTexture,
    FiberTexturePropsHandler: FiberTexturePropsHandler,
    FiberTexture: FiberTexture,
    FiberProceduralTexturePropsHandler: FiberProceduralTexturePropsHandler,
    FiberProceduralTexture: FiberProceduralTexture,
    FiberCustomProceduralTexturePropsHandler: FiberCustomProceduralTexturePropsHandler,
    FiberCustomProceduralTexture: FiberCustomProceduralTexture,
    FiberNoiseProceduralTexturePropsHandler: FiberNoiseProceduralTexturePropsHandler,
    FiberNoiseProceduralTexture: FiberNoiseProceduralTexture,
    FiberRawTexturePropsHandler: FiberRawTexturePropsHandler,
    FiberRawTexture: FiberRawTexture,
    FiberRawTexture2DArrayPropsHandler: FiberRawTexture2DArrayPropsHandler,
    FiberRawTexture2DArray: FiberRawTexture2DArray,
    FiberRenderTargetTexturePropsHandler: FiberRenderTargetTexturePropsHandler,
    FiberRenderTargetTexture: FiberRenderTargetTexture,
    FiberMirrorTexturePropsHandler: FiberMirrorTexturePropsHandler,
    FiberMirrorTexture: FiberMirrorTexture,
    FiberMultiRenderTargetPropsHandler: FiberMultiRenderTargetPropsHandler,
    FiberMultiRenderTarget: FiberMultiRenderTarget,
    FiberPrePassRenderTargetPropsHandler: FiberPrePassRenderTargetPropsHandler,
    FiberPrePassRenderTarget: FiberPrePassRenderTarget,
    FiberRefractionTexturePropsHandler: FiberRefractionTexturePropsHandler,
    FiberRefractionTexture: FiberRefractionTexture,
    FiberMultiviewRenderTargetPropsHandler: FiberMultiviewRenderTargetPropsHandler,
    FiberMultiviewRenderTarget: FiberMultiviewRenderTarget,
    FiberVideoTexturePropsHandler: FiberVideoTexturePropsHandler,
    FiberVideoTexture: FiberVideoTexture,
    FiberDynamicTexturePropsHandler: FiberDynamicTexturePropsHandler,
    FiberDynamicTexture: FiberDynamicTexture,
    FiberAdvancedDynamicTexturePropsHandler: FiberAdvancedDynamicTexturePropsHandler,
    FiberAdvancedDynamicTexture: FiberAdvancedDynamicTexture,
    FiberADTForMesh: FiberADTForMesh,
    FiberADTForMeshTexture: FiberADTForMeshTexture,
    FiberADTFullscreenUI: FiberADTFullscreenUI,
    FiberRawTexture3DPropsHandler: FiberRawTexture3DPropsHandler,
    FiberRawTexture3D: FiberRawTexture3D,
    FiberColorGradingTexturePropsHandler: FiberColorGradingTexturePropsHandler,
    FiberColorGradingTexture: FiberColorGradingTexture,
    FiberEquiRectangularCubeTexturePropsHandler: FiberEquiRectangularCubeTexturePropsHandler,
    FiberEquiRectangularCubeTexture: FiberEquiRectangularCubeTexture,
    FiberHDRCubeTexturePropsHandler: FiberHDRCubeTexturePropsHandler,
    FiberHDRCubeTexture: FiberHDRCubeTexture,
    FiberHtmlElementTexturePropsHandler: FiberHtmlElementTexturePropsHandler,
    FiberHtmlElementTexture: FiberHtmlElementTexture,
    FiberThinRenderTargetTexturePropsHandler: FiberThinRenderTargetTexturePropsHandler,
    FiberThinRenderTargetTexture: FiberThinRenderTargetTexture,
    FiberPostProcessRenderPipelinePropsHandler: FiberPostProcessRenderPipelinePropsHandler,
    FiberPostProcessRenderPipeline: FiberPostProcessRenderPipeline,
    FiberDefaultRenderingPipelinePropsHandler: FiberDefaultRenderingPipelinePropsHandler,
    FiberDefaultRenderingPipeline: FiberDefaultRenderingPipeline,
    FiberLensRenderingPipelinePropsHandler: FiberLensRenderingPipelinePropsHandler,
    FiberLensRenderingPipeline: FiberLensRenderingPipeline,
    FiberSSAO2RenderingPipelinePropsHandler: FiberSSAO2RenderingPipelinePropsHandler,
    FiberSSAO2RenderingPipeline: FiberSSAO2RenderingPipeline,
    FiberSSAORenderingPipelinePropsHandler: FiberSSAORenderingPipelinePropsHandler,
    FiberSSAORenderingPipeline: FiberSSAORenderingPipeline,
    FiberStandardRenderingPipelinePropsHandler: FiberStandardRenderingPipelinePropsHandler,
    FiberStandardRenderingPipeline: FiberStandardRenderingPipeline,
    FiberPostProcessPropsHandler: FiberPostProcessPropsHandler,
    FiberPostProcess: FiberPostProcess,
    FiberImageProcessingPostProcessPropsHandler: FiberImageProcessingPostProcessPropsHandler,
    FiberImageProcessingPostProcess: FiberImageProcessingPostProcess,
    FiberAnaglyphPostProcessPropsHandler: FiberAnaglyphPostProcessPropsHandler,
    FiberAnaglyphPostProcess: FiberAnaglyphPostProcess,
    FiberBlackAndWhitePostProcessPropsHandler: FiberBlackAndWhitePostProcessPropsHandler,
    FiberBlackAndWhitePostProcess: FiberBlackAndWhitePostProcess,
    FiberExtractHighlightsPostProcessPropsHandler: FiberExtractHighlightsPostProcessPropsHandler,
    FiberExtractHighlightsPostProcess: FiberExtractHighlightsPostProcess,
    FiberBloomMergePostProcessPropsHandler: FiberBloomMergePostProcessPropsHandler,
    FiberBloomMergePostProcess: FiberBloomMergePostProcess,
    FiberBlurPostProcessPropsHandler: FiberBlurPostProcessPropsHandler,
    FiberBlurPostProcess: FiberBlurPostProcess,
    FiberDepthOfFieldBlurPostProcessPropsHandler: FiberDepthOfFieldBlurPostProcessPropsHandler,
    FiberDepthOfFieldBlurPostProcess: FiberDepthOfFieldBlurPostProcess,
    FiberChromaticAberrationPostProcessPropsHandler: FiberChromaticAberrationPostProcessPropsHandler,
    FiberChromaticAberrationPostProcess: FiberChromaticAberrationPostProcess,
    FiberCircleOfConfusionPostProcessPropsHandler: FiberCircleOfConfusionPostProcessPropsHandler,
    FiberCircleOfConfusionPostProcess: FiberCircleOfConfusionPostProcess,
    FiberColorCorrectionPostProcessPropsHandler: FiberColorCorrectionPostProcessPropsHandler,
    FiberColorCorrectionPostProcess: FiberColorCorrectionPostProcess,
    FiberConvolutionPostProcessPropsHandler: FiberConvolutionPostProcessPropsHandler,
    FiberConvolutionPostProcess: FiberConvolutionPostProcess,
    FiberDepthOfFieldMergePostProcessPropsHandler: FiberDepthOfFieldMergePostProcessPropsHandler,
    FiberDepthOfFieldMergePostProcess: FiberDepthOfFieldMergePostProcess,
    FiberDisplayPassPostProcessPropsHandler: FiberDisplayPassPostProcessPropsHandler,
    FiberDisplayPassPostProcess: FiberDisplayPassPostProcess,
    FiberFilterPostProcessPropsHandler: FiberFilterPostProcessPropsHandler,
    FiberFilterPostProcess: FiberFilterPostProcess,
    FiberFxaaPostProcessPropsHandler: FiberFxaaPostProcessPropsHandler,
    FiberFxaaPostProcess: FiberFxaaPostProcess,
    FiberGrainPostProcessPropsHandler: FiberGrainPostProcessPropsHandler,
    FiberGrainPostProcess: FiberGrainPostProcess,
    FiberHighlightsPostProcessPropsHandler: FiberHighlightsPostProcessPropsHandler,
    FiberHighlightsPostProcess: FiberHighlightsPostProcess,
    FiberMotionBlurPostProcessPropsHandler: FiberMotionBlurPostProcessPropsHandler,
    FiberMotionBlurPostProcess: FiberMotionBlurPostProcess,
    FiberPassPostProcessPropsHandler: FiberPassPostProcessPropsHandler,
    FiberPassPostProcess: FiberPassPostProcess,
    FiberPassCubePostProcessPropsHandler: FiberPassCubePostProcessPropsHandler,
    FiberPassCubePostProcess: FiberPassCubePostProcess,
    FiberRefractionPostProcessPropsHandler: FiberRefractionPostProcessPropsHandler,
    FiberRefractionPostProcess: FiberRefractionPostProcess,
    FiberSharpenPostProcessPropsHandler: FiberSharpenPostProcessPropsHandler,
    FiberSharpenPostProcess: FiberSharpenPostProcess,
    FiberScreenSpaceReflectionPostProcessPropsHandler: FiberScreenSpaceReflectionPostProcessPropsHandler,
    FiberScreenSpaceReflectionPostProcess: FiberScreenSpaceReflectionPostProcess,
    FiberStereoscopicInterlacePostProcessIPropsHandler: FiberStereoscopicInterlacePostProcessIPropsHandler,
    FiberStereoscopicInterlacePostProcessI: FiberStereoscopicInterlacePostProcessI,
    FiberStereoscopicInterlacePostProcessPropsHandler: FiberStereoscopicInterlacePostProcessPropsHandler,
    FiberStereoscopicInterlacePostProcess: FiberStereoscopicInterlacePostProcess,
    FiberTonemapPostProcessPropsHandler: FiberTonemapPostProcessPropsHandler,
    FiberTonemapPostProcess: FiberTonemapPostProcess,
    FiberVolumetricLightScatteringPostProcessPropsHandler: FiberVolumetricLightScatteringPostProcessPropsHandler,
    FiberVolumetricLightScatteringPostProcess: FiberVolumetricLightScatteringPostProcess,
    FiberVRDistortionCorrectionPostProcessPropsHandler: FiberVRDistortionCorrectionPostProcessPropsHandler,
    FiberVRDistortionCorrectionPostProcess: FiberVRDistortionCorrectionPostProcess,
    FiberVRMultiviewToSingleviewPostProcessPropsHandler: FiberVRMultiviewToSingleviewPostProcessPropsHandler,
    FiberVRMultiviewToSingleviewPostProcess: FiberVRMultiviewToSingleviewPostProcess,
    FiberScreenSpaceCurvaturePostProcessPropsHandler: FiberScreenSpaceCurvaturePostProcessPropsHandler,
    FiberScreenSpaceCurvaturePostProcess: FiberScreenSpaceCurvaturePostProcess,
    FiberSubSurfaceScatteringPostProcessPropsHandler: FiberSubSurfaceScatteringPostProcessPropsHandler,
    FiberSubSurfaceScatteringPostProcess: FiberSubSurfaceScatteringPostProcess,
    FiberGizmoPropsHandler: FiberGizmoPropsHandler,
    FiberGizmo: FiberGizmo,
    FiberPlaneDragGizmoPropsHandler: FiberPlaneDragGizmoPropsHandler,
    FiberPlaneDragGizmo: FiberPlaneDragGizmo,
    FiberPlaneRotationGizmoPropsHandler: FiberPlaneRotationGizmoPropsHandler,
    FiberPlaneRotationGizmo: FiberPlaneRotationGizmo,
    FiberRotationGizmoPropsHandler: FiberRotationGizmoPropsHandler,
    FiberRotationGizmo: FiberRotationGizmo,
    FiberAxisScaleGizmoPropsHandler: FiberAxisScaleGizmoPropsHandler,
    FiberAxisScaleGizmo: FiberAxisScaleGizmo,
    FiberScaleGizmoPropsHandler: FiberScaleGizmoPropsHandler,
    FiberScaleGizmo: FiberScaleGizmo,
    FiberBoundingBoxGizmoPropsHandler: FiberBoundingBoxGizmoPropsHandler,
    FiberBoundingBoxGizmo: FiberBoundingBoxGizmo,
    FiberPositionGizmoPropsHandler: FiberPositionGizmoPropsHandler,
    FiberPositionGizmo: FiberPositionGizmo,
    FiberAxisDragGizmoPropsHandler: FiberAxisDragGizmoPropsHandler,
    FiberAxisDragGizmo: FiberAxisDragGizmo,
    FiberLightGizmoPropsHandler: FiberLightGizmoPropsHandler,
    FiberLightGizmo: FiberLightGizmo,
    FiberCameraGizmoPropsHandler: FiberCameraGizmoPropsHandler,
    FiberCameraGizmo: FiberCameraGizmo,
    FiberSlateGizmoPropsHandler: FiberSlateGizmoPropsHandler,
    FiberSlateGizmo: FiberSlateGizmo,
    FiberGUI3DManagerPropsHandler: FiberGUI3DManagerPropsHandler,
    FiberGUI3DManager: FiberGUI3DManager,
    FiberEnvironmentHelperPropsHandler: FiberEnvironmentHelperPropsHandler,
    FiberEnvironmentHelper: FiberEnvironmentHelper,
    FiberPhysicsImpostorPropsHandler: FiberPhysicsImpostorPropsHandler,
    FiberPhysicsImpostor: FiberPhysicsImpostor,
    FiberVRExperienceHelperPropsHandler: FiberVRExperienceHelperPropsHandler,
    FiberVRExperienceHelper: FiberVRExperienceHelper,
    FiberDynamicTerrainPropsHandler: FiberDynamicTerrainPropsHandler,
    FiberDynamicTerrain: FiberDynamicTerrain,
    FiberPointsCloudSystemPropsHandler: FiberPointsCloudSystemPropsHandler,
    FiberPointsCloudSystem: FiberPointsCloudSystem,
    FiberViewportPropsHandler: FiberViewportPropsHandler,
    FiberViewport: FiberViewport,
    FiberUtilityLayerRendererPropsHandler: FiberUtilityLayerRendererPropsHandler,
    FiberUtilityLayerRenderer: FiberUtilityLayerRenderer,
    FiberMaterialPluginBasePropsHandler: FiberMaterialPluginBasePropsHandler,
    FiberMaterialPluginBase: FiberMaterialPluginBase,
    FiberShadowGeneratorPropsHandler: FiberShadowGeneratorPropsHandler,
    FiberShadowGenerator: FiberShadowGenerator,
    FiberCascadedShadowGeneratorPropsHandler: FiberCascadedShadowGeneratorPropsHandler,
    FiberCascadedShadowGenerator: FiberCascadedShadowGenerator,
    FiberEngineViewPropsHandler: FiberEngineViewPropsHandler,
    FiberEngineView: FiberEngineView,
    FiberGizmoManagerPropsHandler: FiberGizmoManagerPropsHandler,
    FiberGizmoManager: FiberGizmoManager,
    FiberLayerPropsHandler: FiberLayerPropsHandler,
    FiberLayer: FiberLayer,
    FiberImageProcessingConfigurationPropsHandler: FiberImageProcessingConfigurationPropsHandler,
    FiberImageProcessingConfiguration: FiberImageProcessingConfiguration,
    FiberPBRClearCoatConfigurationPropsHandler: FiberPBRClearCoatConfigurationPropsHandler,
    FiberPBRClearCoatConfiguration: FiberPBRClearCoatConfiguration,
    FiberPBRAnisotropicConfigurationPropsHandler: FiberPBRAnisotropicConfigurationPropsHandler,
    FiberPBRAnisotropicConfiguration: FiberPBRAnisotropicConfiguration,
    FiberPBRBRDFConfigurationPropsHandler: FiberPBRBRDFConfigurationPropsHandler,
    FiberPBRBRDFConfiguration: FiberPBRBRDFConfiguration,
    FiberPBRSheenConfigurationPropsHandler: FiberPBRSheenConfigurationPropsHandler,
    FiberPBRSheenConfiguration: FiberPBRSheenConfiguration,
    FiberPBRSubSurfaceConfigurationPropsHandler: FiberPBRSubSurfaceConfigurationPropsHandler,
    FiberPBRSubSurfaceConfiguration: FiberPBRSubSurfaceConfiguration,
    FiberPrePassConfigurationPropsHandler: FiberPrePassConfigurationPropsHandler,
    FiberPrePassConfiguration: FiberPrePassConfiguration,
    FiberDetailMapConfigurationPropsHandler: FiberDetailMapConfigurationPropsHandler,
    FiberDetailMapConfiguration: FiberDetailMapConfiguration,
    FiberAutoRotationBehaviorPropsHandler: FiberAutoRotationBehaviorPropsHandler,
    FiberAutoRotationBehavior: FiberAutoRotationBehavior,
    FiberBouncingBehaviorPropsHandler: FiberBouncingBehaviorPropsHandler,
    FiberBouncingBehavior: FiberBouncingBehavior,
    FiberFramingBehaviorPropsHandler: FiberFramingBehaviorPropsHandler,
    FiberFramingBehavior: FiberFramingBehavior,
    FiberAttachToBoxBehaviorPropsHandler: FiberAttachToBoxBehaviorPropsHandler,
    FiberAttachToBoxBehavior: FiberAttachToBoxBehavior,
    FiberBaseSixDofDragBehaviorPropsHandler: FiberBaseSixDofDragBehaviorPropsHandler,
    FiberBaseSixDofDragBehavior: FiberBaseSixDofDragBehavior,
    FiberFadeInOutBehaviorPropsHandler: FiberFadeInOutBehaviorPropsHandler,
    FiberFadeInOutBehavior: FiberFadeInOutBehavior,
    FiberFollowBehaviorPropsHandler: FiberFollowBehaviorPropsHandler,
    FiberFollowBehavior: FiberFollowBehavior,
    FiberHandConstraintBehaviorPropsHandler: FiberHandConstraintBehaviorPropsHandler,
    FiberHandConstraintBehavior: FiberHandConstraintBehavior,
    FiberMultiPointerScaleBehaviorPropsHandler: FiberMultiPointerScaleBehaviorPropsHandler,
    FiberMultiPointerScaleBehavior: FiberMultiPointerScaleBehavior,
    FiberPointerDragBehaviorPropsHandler: FiberPointerDragBehaviorPropsHandler,
    FiberPointerDragBehavior: FiberPointerDragBehavior,
    FiberSixDofDragBehaviorPropsHandler: FiberSixDofDragBehaviorPropsHandler,
    FiberSixDofDragBehavior: FiberSixDofDragBehavior,
    FiberSurfaceMagnetismBehaviorPropsHandler: FiberSurfaceMagnetismBehaviorPropsHandler,
    FiberSurfaceMagnetismBehavior: FiberSurfaceMagnetismBehavior,
    FiberDefaultBehaviorPropsHandler: FiberDefaultBehaviorPropsHandler,
    FiberDefaultBehavior: FiberDefaultBehavior,
    FiberScenePropsHandler: FiberScenePropsHandler,
    ADTForMesh: ADTForMesh,
    ADTForMeshTexture: ADTForMeshTexture,
    ADTFullscreenUI: ADTFullscreenUI,
    AbstractButton3D: AbstractButton3D,
    AbstractMesh: AbstractMesh,
    AdvancedDynamicTexture: AdvancedDynamicTexture,
    AnaglyphArcRotateCamera: AnaglyphArcRotateCamera,
    AnaglyphFreeCamera: AnaglyphFreeCamera,
    AnaglyphGamepadCamera: AnaglyphGamepadCamera,
    AnaglyphPostProcess: AnaglyphPostProcess,
    AnaglyphUniversalCamera: AnaglyphUniversalCamera,
    ArcFollowCamera: ArcFollowCamera,
    ArcRotateCamera: ArcRotateCamera,
    AttachToBoxBehavior: AttachToBoxBehavior,
    AutoRotationBehavior: AutoRotationBehavior,
    AxisDragGizmo: AxisDragGizmo,
    AxisScaleGizmo: AxisScaleGizmo,
    BackgroundMaterial: BackgroundMaterial,
    BaseSixDofDragBehavior: BaseSixDofDragBehavior,
    BaseSlider: BaseSlider,
    BaseTexture: BaseTexture,
    BlackAndWhitePostProcess: BlackAndWhitePostProcess,
    BloomMergePostProcess: BloomMergePostProcess,
    BlurPostProcess: BlurPostProcess,
    BouncingBehavior: BouncingBehavior,
    BoundingBoxGizmo: BoundingBoxGizmo,
    Box: Box,
    Button: Button,
    Button3D: Button3D,
    Camera: Camera,
    CameraGizmo: CameraGizmo,
    Capsule: Capsule,
    CascadedShadowGenerator: CascadedShadowGenerator,
    Checkbox: Checkbox,
    ChromaticAberrationPostProcess: ChromaticAberrationPostProcess,
    CircleOfConfusionPostProcess: CircleOfConfusionPostProcess,
    ColorCorrectionPostProcess: ColorCorrectionPostProcess,
    ColorGradingTexture: ColorGradingTexture,
    ColorPicker: ColorPicker,
    Container: Container,
    Container3D: Container3D,
    ContentDisplay3D: ContentDisplay3D,
    Control: Control,
    Control3D: Control3D,
    ConvolutionPostProcess: ConvolutionPostProcess,
    CubeTexture: CubeTexture,
    CustomProceduralTexture: CustomProceduralTexture,
    Cylinder: Cylinder,
    CylinderPanel: CylinderPanel,
    DashedLines: DashedLines,
    Decal: Decal,
    DefaultBehavior: DefaultBehavior,
    DefaultRenderingPipeline: DefaultRenderingPipeline,
    DepthOfFieldBlurPostProcess: DepthOfFieldBlurPostProcess,
    DepthOfFieldMergePostProcess: DepthOfFieldMergePostProcess,
    DetailMapConfiguration: DetailMapConfiguration,
    DeviceOrientationCamera: DeviceOrientationCamera,
    DirectionalLight: DirectionalLight,
    Disc: Disc,
    DisplayGrid: DisplayGrid,
    DisplayPassPostProcess: DisplayPassPostProcess,
    DynamicTerrain: DynamicTerrain,
    DynamicTexture: DynamicTexture,
    EffectLayer: EffectLayer,
    Ellipse: Ellipse,
    EngineView: EngineView,
    EnvironmentHelper: EnvironmentHelper,
    EquiRectangularCubeTexture: EquiRectangularCubeTexture,
    ExtractHighlightsPostProcess: ExtractHighlightsPostProcess,
    ExtrudePolygon: ExtrudePolygon,
    ExtrudeShape: ExtrudeShape,
    ExtrudeShapeCustom: ExtrudeShapeCustom,
    FadeInOutBehavior: FadeInOutBehavior,
    FilterPostProcess: FilterPostProcess,
    FluentBackplateMaterial: FluentBackplateMaterial,
    FluentButtonMaterial: FluentButtonMaterial,
    FluentMaterial: FluentMaterial,
    FlyCamera: FlyCamera,
    FocusableButton: FocusableButton,
    FollowBehavior: FollowBehavior,
    FollowCamera: FollowCamera,
    FramingBehavior: FramingBehavior,
    FreeCamera: FreeCamera,
    FxaaPostProcess: FxaaPostProcess,
    GUI3DManager: GUI3DManager,
    GamepadCamera: GamepadCamera,
    Geodesic: Geodesic,
    Gizmo: Gizmo,
    GizmoManager: GizmoManager,
    GlowLayer: GlowLayer,
    Goldberg: Goldberg,
    GoldbergMesh: GoldbergMesh,
    GrainPostProcess: GrainPostProcess,
    Grid: Grid,
    Ground: Ground,
    GroundFromHeightMap: GroundFromHeightMap,
    GroundMesh: GroundMesh,
    HDRCubeTexture: HDRCubeTexture,
    HandConstraintBehavior: HandConstraintBehavior,
    HandMenu: HandMenu,
    HandleMaterial: HandleMaterial,
    HemisphericLight: HemisphericLight,
    HighlightLayer: HighlightLayer,
    HighlightsPostProcess: HighlightsPostProcess,
    HolographicBackplate: HolographicBackplate,
    HolographicButton: HolographicButton,
    HolographicSlate: HolographicSlate,
    HtmlElementTexture: HtmlElementTexture,
    IcoSphere: IcoSphere,
    Image: Image,
    ImageBasedSlider: ImageBasedSlider,
    ImageProcessingConfiguration: ImageProcessingConfiguration,
    ImageProcessingPostProcess: ImageProcessingPostProcess,
    ImageScrollBar: ImageScrollBar,
    InputPassword: InputPassword,
    InputText: InputText,
    InstancedLinesMesh: InstancedLinesMesh,
    InstancedMesh: InstancedMesh,
    Lathe: Lathe,
    Layer: Layer,
    LensRenderingPipeline: LensRenderingPipeline,
    Light: Light,
    LightGizmo: LightGizmo,
    Line: Line,
    LineSystem: LineSystem,
    Lines: Lines,
    LinesMesh: LinesMesh,
    MRDLBackplateMaterial: MRDLBackplateMaterial,
    MRDLSliderBarMaterial: MRDLSliderBarMaterial,
    MRDLSliderThumbMaterial: MRDLSliderThumbMaterial,
    Material: Material,
    MaterialPluginBase: MaterialPluginBase,
    Mesh: Mesh,
    MeshButton3D: MeshButton3D,
    MirrorTexture: MirrorTexture,
    MotionBlurPostProcess: MotionBlurPostProcess,
    MultiLine: MultiLine,
    MultiMaterial: MultiMaterial,
    MultiPointerScaleBehavior: MultiPointerScaleBehavior,
    MultiRenderTarget: MultiRenderTarget,
    MultiviewRenderTarget: MultiviewRenderTarget,
    NearMenu: NearMenu,
    Node: Node,
    NodeMaterial: NodeMaterial,
    NoiseProceduralTexture: NoiseProceduralTexture,
    OcclusionMaterial: OcclusionMaterial,
    PBRAnisotropicConfiguration: PBRAnisotropicConfiguration,
    PBRBRDFConfiguration: PBRBRDFConfiguration,
    PBRBaseMaterial: PBRBaseMaterial,
    PBRBaseSimpleMaterial: PBRBaseSimpleMaterial,
    PBRClearCoatConfiguration: PBRClearCoatConfiguration,
    PBRMaterial: PBRMaterial,
    PBRMetallicRoughnessMaterial: PBRMetallicRoughnessMaterial,
    PBRSheenConfiguration: PBRSheenConfiguration,
    PBRSpecularGlossinessMaterial: PBRSpecularGlossinessMaterial,
    PBRSubSurfaceConfiguration: PBRSubSurfaceConfiguration,
    PassCubePostProcess: PassCubePostProcess,
    PassPostProcess: PassPostProcess,
    PhysicsImpostor: PhysicsImpostor,
    Plane: Plane,
    PlaneDragGizmo: PlaneDragGizmo,
    PlanePanel: PlanePanel,
    PlaneRotationGizmo: PlaneRotationGizmo,
    PointLight: PointLight,
    PointerDragBehavior: PointerDragBehavior,
    PointsCloudSystem: PointsCloudSystem,
    Polygon: Polygon,
    Polyhedron: Polyhedron,
    PositionGizmo: PositionGizmo,
    PostProcess: PostProcess,
    PostProcessRenderPipeline: PostProcessRenderPipeline,
    PrePassConfiguration: PrePassConfiguration,
    PrePassRenderTarget: PrePassRenderTarget,
    ProceduralTexture: ProceduralTexture,
    PushMaterial: PushMaterial,
    RadioButton: RadioButton,
    RawCubeTexture: RawCubeTexture,
    RawTexture: RawTexture,
    RawTexture2DArray: RawTexture2DArray,
    RawTexture3D: RawTexture3D,
    Rectangle: Rectangle,
    RefractionPostProcess: RefractionPostProcess,
    RefractionTexture: RefractionTexture,
    RenderTargetTexture: RenderTargetTexture,
    Ribbon: Ribbon,
    RotationGizmo: RotationGizmo,
    SSAO2RenderingPipeline: SSAO2RenderingPipeline,
    SSAORenderingPipeline: SSAORenderingPipeline,
    ScaleGizmo: ScaleGizmo,
    ScatterPanel: ScatterPanel,
    ScreenSpaceCurvaturePostProcess: ScreenSpaceCurvaturePostProcess,
    ScreenSpaceReflectionPostProcess: ScreenSpaceReflectionPostProcess,
    ScrollBar: ScrollBar,
    ScrollViewer: ScrollViewer,
    SelectionPanel: SelectionPanel,
    ShaderMaterial: ShaderMaterial,
    ShadowGenerator: ShadowGenerator,
    ShadowLight: ShadowLight,
    SharpenPostProcess: SharpenPostProcess,
    SixDofDragBehavior: SixDofDragBehavior,
    SlateGizmo: SlateGizmo,
    Slider: Slider,
    Slider3D: Slider3D,
    Sphere: Sphere,
    SpherePanel: SpherePanel,
    SpotLight: SpotLight,
    StackPanel: StackPanel,
    StackPanel3D: StackPanel3D,
    StandardMaterial: StandardMaterial,
    StandardRenderingPipeline: StandardRenderingPipeline,
    StereoscopicArcRotateCamera: StereoscopicArcRotateCamera,
    StereoscopicFreeCamera: StereoscopicFreeCamera,
    StereoscopicGamepadCamera: StereoscopicGamepadCamera,
    StereoscopicInterlacePostProcess: StereoscopicInterlacePostProcess,
    StereoscopicInterlacePostProcessI: StereoscopicInterlacePostProcessI,
    StereoscopicScreenUniversalCamera: StereoscopicScreenUniversalCamera,
    StereoscopicUniversalCamera: StereoscopicUniversalCamera,
    SubSurfaceScatteringPostProcess: SubSurfaceScatteringPostProcess,
    SurfaceMagnetismBehavior: SurfaceMagnetismBehavior,
    TargetCamera: TargetCamera,
    TextBlock: TextBlock,
    Texture: Texture,
    ThinRenderTargetTexture: ThinRenderTargetTexture,
    ThinTexture: ThinTexture,
    TiledBox: TiledBox,
    TiledGround: TiledGround,
    TiledPlane: TiledPlane,
    ToggleButton: ToggleButton,
    TonemapPostProcess: TonemapPostProcess,
    Torus: Torus,
    TorusKnot: TorusKnot,
    TouchButton3D: TouchButton3D,
    TouchCamera: TouchCamera,
    TouchHolographicButton: TouchHolographicButton,
    TouchHolographicMenu: TouchHolographicMenu,
    TouchMeshButton3D: TouchMeshButton3D,
    TrailMesh: TrailMesh,
    TransformNode: TransformNode,
    Tube: Tube,
    UniversalCamera: UniversalCamera,
    UtilityLayerRenderer: UtilityLayerRenderer,
    VRDeviceOrientationArcRotateCamera: VRDeviceOrientationArcRotateCamera,
    VRDeviceOrientationFreeCamera: VRDeviceOrientationFreeCamera,
    VRDeviceOrientationGamepadCamera: VRDeviceOrientationGamepadCamera,
    VRDistortionCorrectionPostProcess: VRDistortionCorrectionPostProcess,
    VRExperienceHelper: VRExperienceHelper,
    VRMultiviewToSingleviewPostProcess: VRMultiviewToSingleviewPostProcess,
    VideoTexture: VideoTexture,
    Viewport: Viewport,
    VirtualJoysticksCamera: VirtualJoysticksCamera,
    VirtualKeyboard: VirtualKeyboard,
    VolumeBasedPanel: VolumeBasedPanel,
    VolumetricLightScatteringPostProcess: VolumetricLightScatteringPostProcess,
    WebVRFreeCamera: WebVRFreeCamera,
    WebXRCamera: WebXRCamera,
    _ScrollViewerWindow: _ScrollViewerWindow,
    intrinsicClassMap: intrinsicClassMap,
    babylonClassFactory: babylonClassFactory
});

var applyUpdateToInstance = function (createdInstance, update) {
    var target = update.target !== undefined
        ? createdInstance.hostInstance[update.target]
        : createdInstance.hostInstance;
    switch (update.changeType) {
        case PropChangeType.Primitive:
        case PropChangeType.FresnelParameters:
        case PropChangeType.LambdaExpression:
        case PropChangeType.Texture:
            // console.log(` > ${type}: updating ${update.changeType} on ${update.propertyName} to ${update.value}`)
            if (update.propertyName.indexOf('.') !== -1) {
                var dotProps = update.propertyName.split('.');
                var lastProp = dotProps.pop();
                var newTarget = dotProps.reduce(function (target, prop) { return target[prop]; }, target);
                newTarget[lastProp] = update.value;
            }
            else {
                target[update.propertyName] = update.value;
            }
            break;
        case PropChangeType.Vector3:
            if (target[update.propertyName]) {
                target[update.propertyName].copyFrom(update.value);
            }
            else if (update.value) {
                target[update.propertyName] = update.value.clone();
            }
            else {
                target[update.propertyName] = update.value; // ie: undefined/null?
            }
            break;
        case PropChangeType.Color3:
        case PropChangeType.Color4:
            if (update.value) {
                target[update.propertyName] = update.value.clone();
            }
            else {
                target[update.propertyName] = update.value;
            }
            break;
        case PropChangeType.Control:
            target[update.propertyName] = update.value;
            break;
        case PropChangeType.NumericArray:
            target[update.propertyName] = update.value;
            break;
        case PropChangeType.Observable:
            // adding and remove observer can cause an infinite loop without something like  setTimeout(() => ..., 1);
            // ie: clicking a button causes a re-render, which causes the callback to change (inline method)...
            if (update.propertyName in createdInstance.observers) {
                createdInstance.observers[update.propertyName].callback = update.value;
            }
            else {
                var observer = target[update.propertyName].add(update.value);
                createdInstance.observers[update.propertyName] = observer;
            }
            break;
        case PropChangeType.Method:
            if (typeof target[update.propertyName] === 'function') {
                if (Array.isArray(update.value)) {
                    target[update.propertyName].apply(target, update.value);
                }
                else if (Object(update.value) !== update.value) {
                    // primitive, undefined & null.  Comparison is 7x slower than instanceof check,
                    // TODO: should be: update.value === undefined || typeof(update.value) === 'number' || ...
                    target[update.propertyName](update.value);
                }
                else {
                    // TODO: there is a bug here in that setTarget={new Vector3(0, 1, 0)} will throw an exception...
                    console.error("need to make sure this isn't something like a Vector3 before destructuring");
                    target[update.propertyName].apply(target, Object.values(update.value));
                }
            }
            else {
                console.error("Cannot call [not a function] ".concat(update.propertyName, "(...) on:"), target);
            }
            break;
        case PropChangeType.Quaternion:
            // console.warn(`quaternion update detected ${update.propertyName} to:`, update.value)
            if (target[update.propertyName]) {
                target[update.propertyName].copyFrom(update.value);
            }
            else if (update.value) {
                target[update.propertyName] = update.value.clone();
            }
            else {
                target[update.propertyName] = update.value; // ie: undefined/null?
            }
            break;
        default:
            console.error("Unhandled property update of type '".concat(update.changeType, "'"));
            break;
    }
};
/**
 * Only applied in this way immediately after instantiation (not on deltas)
 *
 * @param instance
 * @param props
 */
var applyInitialPropsToCreatedInstance = function (createdInstance, props) {
    if (createdInstance.propsHandlers === undefined) {
        return;
    }
    var initPayload = [];
    createdInstance.propsHandlers.getPropsHandlers().forEach(function (propHandler) {
        // NOTE: this can actually be WRONG, because here we want to compare the props with the object.
        // This is only needed right after object instantiation.
        var handlerUpdates = propHandler.getPropertyUpdates({}, // Here we will reapply things like 'name', so we could get default props from 'babylonObject'.
        props);
        if (handlerUpdates !== null) {
            initPayload.push.apply(initPayload, handlerUpdates);
        }
    });
    if (initPayload.length > 0) {
        initPayload.forEach(function (update) {
            applyUpdateToInstance(createdInstance, update);
        });
    }
};

var LoaderStatus;
(function (LoaderStatus) {
    LoaderStatus["Loading"] = "Loading";
    LoaderStatus["Loaded"] = "Loaded";
    LoaderStatus["Error"] = "Error";
})(LoaderStatus || (LoaderStatus = {}));
var LoadedModel = /** @class */ (function () {
    function LoadedModel() {
        this.status = LoaderStatus.Loading;
    }
    Object.defineProperty(LoadedModel.prototype, "scaledToDimension", {
        get: function () {
            return this._scaledToDimension;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LoadedModel.prototype, "boundingInfo", {
        get: function () {
            if (!this.rootMesh) {
                return null;
            }
            // meshes are already parented to root mesh, so we do not need to look further.
            var min = null;
            var max = null;
            this.rootMesh.getChildMeshes().forEach(function (childMesh) {
                var _a = childMesh.getBoundingInfo().boundingBox, minimumWorld = _a.minimumWorld, maximumWorld = _a.maximumWorld;
                if (min === null) {
                    min = minimumWorld;
                }
                else {
                    min = Vector3.Minimize(min, minimumWorld);
                }
                if (max === null) {
                    max = maximumWorld;
                }
                else {
                    max = Vector3.Maximize(max, maximumWorld);
                }
            });
            if (min !== null && max != null) {
                return new BoundingInfo(min, max);
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    LoadedModel.prototype.scaleTo = function (maxDimension) {
        var boundingInfo = this.boundingInfo; // will be null when no meshes are loaded
        if (boundingInfo && this.rootMesh) {
            var longestDimension = Math.max(Math.abs(boundingInfo.minimum.x - boundingInfo.maximum.x), Math.abs(boundingInfo.minimum.y - boundingInfo.maximum.y), Math.abs(boundingInfo.minimum.z - boundingInfo.maximum.z));
            var dimension = maxDimension / longestDimension;
            this.rootMesh.scaling.scaleInPlace(dimension);
            this._scaledToDimension = maxDimension;
        }
    };
    /**
     * Clean up all resources.
     */
    LoadedModel.prototype.dispose = function () {
        if (this.rootMesh) {
            this.rootMesh.dispose(false, true);
            this.rootMesh = undefined;
            this.meshes = [];
        }
        if (this.particleSystems) {
            this.particleSystems.forEach(function (ps) {
                // ps.stop();
                ps.dispose();
            });
            this.particleSystems = [];
        }
        if (this.skeletons) {
            this.skeletons.forEach(function (skeleton) { return skeleton.dispose(); });
            this.skeletons = [];
        }
        if (this.animationGroups) {
            this.animationGroups.forEach(function (animationGroup) { return animationGroup.dispose(); });
            this.animationGroups = [];
        }
    };
    return LoadedModel;
}());

var SceneLoaderContext = React.createContext(undefined);
var SceneLoaderContextProvider = function (props) {
    var _a = useState(null), progress = _a[0], setProgress = _a[1];
    return (React.createElement(SceneLoaderContext.Provider, { value: { lastProgress: progress, updateProgress: setProgress } }, props.children));
};
/**
 * A cached version of SceneLoader with a Suspense cache.
 */
var useSceneLoaderWithCache = function () {
    // we need our own memoized cache. useMemo, useState, etc. fail miserably - throwing a promise forces the component to remount.
    var suspenseCache = {};
    var suspenseScene = null;
    // let tasksCompletedCache: Record<string, LoadedModel> = {};
    return function (rootUrl, sceneFilename, pluginExtension, options, initialProps) {
        var opts = options || {};
        // we are not in a callback here
        // eslint-disable-next-line react-hooks/rules-of-hooks
        var hookScene = useScene();
        if (opts.scene === undefined && hookScene === null) {
            throw new Error('useSceneLoader can only be used inside a Scene component (or pass scene as an option)');
        }
        var scene = opts.scene || hookScene;
        if (suspenseScene == null) {
            suspenseScene = scene;
        }
        else {
            if (suspenseScene !== scene) {
                // console.log('new scene detected - clearing useAssetManager cache');
                suspenseCache = {};
                // NOTE: could keep meshes with mesh.serialize and Mesh.Parse
                // Need to research how to do with textures, etc.
                // browser cache should make the load fast in most cases
                // tasksCompletedCache = {};
                suspenseScene = scene;
            }
        }
        var suspenseKey = "".concat(rootUrl, "/").concat(sceneFilename);
        // we are not in a callback here
        // eslint-disable-next-line react-hooks/rules-of-hooks
        var sceneLoaderContext = useContext(SceneLoaderContext);
        var createSceneLoader = function () {
            var taskPromise = new Promise(function (resolve, reject) {
                var loadedModel = new LoadedModel();
                loadedModel.status = LoaderStatus.Loading;
                var loader = SceneLoader.ImportMesh(opts.meshNames, rootUrl, sceneFilename, scene, function (meshes, particleSystems, skeletons, animationGroups) {
                    loadedModel.rootMesh = new AbstractMesh$1(sceneFilename + '-root-model', scene);
                    if (opts.alwaysSelectAsActiveMesh === true) {
                        loadedModel.rootMesh.alwaysSelectAsActiveMesh = true;
                    }
                    loadedModel.meshes = [];
                    meshes.forEach(function (mesh) {
                        loadedModel.meshes.push(mesh);
                        // leave meshes already parented to maintain model hierarchy:
                        if (!mesh.parent) {
                            mesh.parent = loadedModel.rootMesh;
                        }
                        if (opts.receiveShadows === true) {
                            mesh.receiveShadows = true;
                        }
                    });
                    loadedModel.particleSystems = particleSystems;
                    loadedModel.skeletons = skeletons;
                    loadedModel.animationGroups = animationGroups;
                    loadedModel.status = LoaderStatus.Loaded;
                    if (opts.scaleToDimension) {
                        loadedModel.scaleTo(opts.scaleToDimension);
                    }
                    if (initialProps) {
                        var initPayload_1 = [];
                        new FiberMesh().getPropsHandlers().forEach(function (propHandler) {
                            var handlerUpdates = propHandler.getPropertyUpdates({}, // Here we will reapply things like 'name', so we could get default props from 'babylonObject'.
                            initialProps);
                            if (handlerUpdates !== null) {
                                initPayload_1.push.apply(initPayload_1, handlerUpdates);
                            }
                        });
                        if (initPayload_1.length > 0) {
                            initPayload_1.forEach(function (update) {
                                applyUpdateToInstance({ hostInstance: loadedModel.rootMesh }, update);
                            });
                        }
                    }
                    if (options === null || options === void 0 ? void 0 : options.onModelLoaded) {
                        options.onModelLoaded(loadedModel);
                    }
                    var originalDispose = loadedModel.dispose;
                    loadedModel.dispose = function () {
                        // console.log('Clearing cache (cannot re-use meshes).');
                        suspenseCache[suspenseKey] = undefined;
                        originalDispose.call(loadedModel);
                    };
                    resolve(loadedModel);
                }, function (event) {
                    if (opts.reportProgress === true && sceneLoaderContext !== undefined) {
                        sceneLoaderContext.updateProgress(event);
                    }
                    if (opts.onLoadProgress) {
                        opts.onLoadProgress(event);
                    }
                }, function (_, message, exception) {
                    if (opts.onModelError) {
                        opts.onModelError(loadedModel);
                    }
                    reject(exception !== null && exception !== void 0 ? exception : message);
                }, pluginExtension);
                if (loader) {
                    loadedModel.loaderName = loader.name;
                }
                else {
                    loadedModel.loaderName = 'no loader found';
                }
            });
            var result;
            var error = null;
            var suspender = null;
            suspender = (function () { return __awaiter(void 0, void 0, void 0, function () {
                var e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, 3, 4]);
                            return [4 /*yield*/, taskPromise];
                        case 1:
                            result = _a.sent();
                            return [3 /*break*/, 4];
                        case 2:
                            e_1 = _a.sent();
                            error = e_1;
                            return [3 /*break*/, 4];
                        case 3:
                            suspender = null;
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            }); })();
            var getAssets = function () {
                if (suspender) {
                    throw suspender;
                }
                if (error !== null) {
                    throw error;
                }
                return result;
            };
            return getAssets;
        };
        if (suspenseCache[suspenseKey] === undefined) {
            suspenseCache[suspenseKey] = createSceneLoader();
        }
        return suspenseCache[suspenseKey]();
    };
};
// this isn't a hook being called
// eslint-disable-next-line react-hooks/rules-of-hooks
var useSceneLoader = useSceneLoaderWithCache();

var Model = function (props) {
    var alwaysSelectAsActiveMesh = props.alwaysSelectAsActiveMesh, meshNames = props.meshNames, onLoadProgress = props.onLoadProgress, onModelError = props.onModelError, onModelLoaded = props.onModelLoaded, receiveShadows = props.receiveShadows, reportProgress = props.reportProgress, scaleToDimension = props.scaleToDimension, // SceneLoaderOptions
    rootUrl = props.rootUrl, sceneFilename = props.sceneFilename, pluginExtension = props.pluginExtension, // other parameters
    rest = __rest(props, ["alwaysSelectAsActiveMesh", "meshNames", "onLoadProgress", "onModelError", "onModelLoaded", "receiveShadows", "reportProgress", "scaleToDimension", "rootUrl", "sceneFilename", "pluginExtension"]) // passed on to "rootMesh"
    ;
    var options = {
        alwaysSelectAsActiveMesh: alwaysSelectAsActiveMesh,
        meshNames: meshNames,
        onLoadProgress: onLoadProgress,
        onModelError: onModelError,
        onModelLoaded: onModelLoaded,
        receiveShadows: receiveShadows,
        reportProgress: reportProgress,
        scaleToDimension: scaleToDimension,
    };
    var sceneLoaderResults = useSceneLoader(rootUrl, sceneFilename, pluginExtension, options, rest);
    useEffect(function () {
        return function () {
            // console.log('disposing the sceneloader results.')
            sceneLoaderResults.dispose();
        };
    }, []);
    return (React.createElement("abstractMesh", __assign({ fromInstance: sceneLoaderResults.rootMesh, childMeshesNotTracked: true }, rest)));
};

var Skybox = function (props) {
    var _a;
    return (React.createElement("box", { name: props.name ? "skybox-".concat(props.name) : 'skybox', size: (_a = props.size) !== null && _a !== void 0 ? _a : 100, infiniteDistance: true, renderingGroupId: 0 },
        React.createElement("standardMaterial", { name: props.name ? "skybox-material-".concat(props.name) : 'skybox-material', backFaceCulling: false, disableLighting: true },
            React.createElement("cubeTexture", { key: "cube-texture-".concat(props.rootUrl), rootUrl: props.rootUrl, coordinatesMode: Texture$1.SKYBOX_MODE, assignTo: 'reflectionTexture' }))));
};

var EngineCanvasContext = createContext({
    engine: null,
    canvas: null,
});
function withEngineCanvasContext(Component) {
    return function BoundComponent(props) {
        return (React.createElement(EngineCanvasContext.Consumer, null, function (ctx) { return React.createElement(Component, __assign({}, props, { engineCanvasContext: ctx })); }));
    };
}
/**
 * Get the engine from the context.
 */
var useEngine = function () {
    var engineCanvasContext = useContext(EngineCanvasContext);
    var sceneContext = useContext(SceneContext);
    if (engineCanvasContext.engine !== null) {
        return engineCanvasContext.engine;
    }
    if (sceneContext.scene !== null) {
        return sceneContext.scene.getEngine();
    }
    return null;
};
/**
 * Get the canvas DOM element from the context.
 */
var useCanvas = function () {
    var engineCanvasContext = useContext(EngineCanvasContext);
    var sceneContext = useContext(SceneContext);
    if (engineCanvasContext.engine !== null) {
        return engineCanvasContext.canvas;
    }
    if (sceneContext.scene !== null) {
        return sceneContext.scene.getEngine().getRenderingCanvas();
    }
    return null;
};

// TODO: this should return a shouldRenderRef instead of setState for a re-render?
var useCanvasObserver = function (canvasRef, shouldRenderRef, enabledOption, threshold) {
    if (enabledOption === void 0) { enabledOption = false; }
    if (threshold === void 0) { threshold = 0; }
    useEffect(function () {
        if (enabledOption !== true) {
            return;
        }
        if (canvasRef.current === null) {
            return;
        }
        var callbackFn = function (entries) {
            var entry = entries[0];
            shouldRenderRef.current = entry.isIntersecting;
            console.log('should render updating:', shouldRenderRef.current);
        };
        var observer = new IntersectionObserver(callbackFn, { threshold: threshold });
        observer.observe(canvasRef.current);
        var canvas = canvasRef.current;
        return function () {
            observer.unobserve(canvas);
        };
    }, [canvasRef, threshold, enabledOption]);
};
var ReactBabylonjsEngine = function (props, context) {
    var engine = useRef(null);
    var _a = useState(false); _a[0]; var setEngineReady = _a[1];
    // const resizeObserver = useRef<Nullable<ResizeObserver>>(null);
    var onBeforeRenderLoopObservable = useRef(new Observable());
    var onEndRenderLoopObservable = useRef(new Observable());
    var canvasRef = useRef(null);
    var _b = useState(false), canvasReady = _b[0], setCanvasReady = _b[1];
    var [hasOffscreenCanvas, setHasOffscreenCanvas] = useState(false);
    var shouldRenderRef = useRef(true);
    // const renderOptions: RenderOptions = props.renderOptions ?? {};
    var isPaused = props.isPaused, touchActionNone = props.touchActionNone, canvasId = props.canvasId, engineOptions = props.engineOptions, antialias = props.antialias, adaptToDeviceRatio = props.adaptToDeviceRatio, renderOptions = props.renderOptions; props.observeCanvasResize; props.children; var style = props.style, canvasProps = __rest(props, ["isPaused", "touchActionNone", "canvasId", "engineOptions", "antialias", "adaptToDeviceRatio", "renderOptions", "observeCanvasResize", "children", "style"]);
    var observerEnabled = renderOptions !== undefined && renderOptions.whenVisibleOnly === true && !isPaused;
    useCanvasObserver(canvasRef, shouldRenderRef, observerEnabled, 0);
    useEffect(function () {
        shouldRenderRef.current = !isPaused;
    }, [isPaused]);
    useEffect(function () {
        if (!canvasReady) {
            return;
        }
        if (canvasRef.current === null) {
            return;
        }
        engine.current = new Engine(canvasRef.current, antialias === true, // default false
        engineOptions, adaptToDeviceRatio === true // default false
        );
        engine.current.runRenderLoop(function () {
            if (shouldRenderRef.current === false) {
                return;
            }
            if (onBeforeRenderLoopObservable.current.hasObservers()) {
                onBeforeRenderLoopObservable.current.notifyObservers(engine.current);
            }
            // TODO: here is where you could access your own render method
            engine.current.scenes.forEach(function (scene) {
                scene.render();
            });
            if (onEndRenderLoopObservable.current.hasObservers()) {
                onEndRenderLoopObservable.current.notifyObservers(engine.current);
            }
        });
        // if (props.observeCanvasResize !== false && window?.ResizeObserver) {
        //   resizeObserver.current = new ResizeObserver(() => {
        //     engine.current!.resize()
        //   })
        //   resizeObserver.current.observe(canvasRef.current);
        // }
        engine.current.onContextLostObservable.add(function (eventData) {
            console.warn('context loss observable from Engine: ', eventData);
        });
        var onResizeWindow = function () {
            if (engine.current) {
                engine.current.resize();
            }
        };
        window.addEventListener('resize', onResizeWindow);
        setEngineReady(true); // trigger re-render to render Scene
        return function () {
            window.removeEventListener('resize', onResizeWindow);
            // if (resizeObserver.current !== null) {
            //   resizeObserver.current.disconnect()
            //   resizeObserver.current = null
            // }
            if (engine.current !== null) {
                engine.current.dispose();
                engine.current = null;
            }
        };
    }, [canvasReady]);
    var opts = {};
    if (touchActionNone !== false) {
        opts['touch-action'] = 'none';
    }
    // this is for backwards compatibility - before props were passed to canvas.
    if (canvasId && canvasProps.id === undefined) {
        opts.id = canvasId;
    }
    // TODO: this.props.portalCanvas does not need to render a canvas.
    // return (React.createElement(EngineCanvasContext.Provider, { value: { engine: engine.current, canvas: canvasRef.current } },
    //     React.createElement("canvas", __assign({}, opts, canvasProps, { ref: function (view) { canvasRef.current = view; setCanvasReady(true); }, style: __assign({ width: '100%', height: '100%' }, style) }), engine.current !== null && props.children)));
    return (
        <EngineCanvasContext.Provider value={{ engine: engine.current, canvas: canvasRef.current }}>
            {Platform.OS === 'web' ? (
                <canvas
                    {...opts}
                    {...canvasProps}
                    ref={(view) => {
                        canvasRef.current = view;
                        setCanvasReady(true);
                    }}
                    style={{
                        width: '100%',
                        height: '100%',
                        ...style,
                    }}
                >
                    {engine.current !== null && props.children}
                </canvas>
            ) : (
                <>
                    <GCanvasView
                        style={{
                            width: Dimensions.get('window').width * 2, //  need * 2 to display UI text fStop:3.00 in https://github.com/flyskywhy/GCanvasRNExamples/src/nonDeclarative.js
                            height: Dimensions.get('window').height * 2,
                            position: 'absolute',
                            left: Dimensions.get('window').width,
                            top: 0,
                            zIndex: -100,
                        }}
                        // offscreenCanvas={true} // TODO: use it instead of global.createCanvasElements.push(canvas) in next major version
                        onCanvasCreate={(canvas) => {
                            global.createCanvasElements.push(canvas);
                            setHasOffscreenCanvas(true);
                        }}
                        isGestureResponsible={false}
                    />
                    {hasOffscreenCanvas && (
                        <GCanvasView
                            onCanvasCreate={(view) => {
                                canvasRef.current = view;
                                setCanvasReady(true);
                            }}
                            onCanvasResize={({width, height, canvas}) => {
                                canvas.width = width;
                                canvas.height = height;

                                // seems will resize() automatically somewhere, so comment below
                                // if (engine.current) {
                                //     engine.current.resize();
                                // }
                            }}
                            isGestureResponsible={!touchActionNone}
                            isAutoClearRectBeforePutImageData={true}
                            isResetGlViewportAfterSetWidthOrHeight={false}
                            devicePixelRatio={1}
                            style={{
                                width: '100%',
                                height: '100%',
                                ...style,
                            }}
                        >
                            {engine.current !== null && props.children}
                        </GCanvasView>
                    )}
                </>
            )}
      </EngineCanvasContext.Provider>
    )
};

/**
 * Handles creating a camera and attaching/disposing.
 * TODO: add new 4.2 parameters: useCtrlForPanning & panningMouseButton
 * @param createCameraFn function that creates and returns a camera
 * @param autoAttach Attach the input controls (default true)
 * @param noPreventDefault Events caught by controls should call prevent default
 * @param useCtrlForPanning (ArcRotateCamera only)
 * @param panningMoustButton (ArcRotateCamera only)
 */
var useCamera = function (createCameraFn, autoAttach, noPreventDefault /*, useCtrlForPanning: boolean = false, panningMouseButton: number*/) {
    if (autoAttach === void 0) { autoAttach = true; }
    if (noPreventDefault === void 0) { noPreventDefault = true; }
    var scene = useContext(SceneContext).scene;
    var cameraRef = useRef(null);
    useEffect(function () {
        if (scene === null) {
            console.warn('cannot create camera (scene not ready)');
            return;
        }
        var camera = createCameraFn(scene);
        if (autoAttach === true) {
            var canvas = scene.getEngine().getRenderingCanvas();
            // This attaches the camera to the canvas - adding extra parameters breaks backwards compatibility
            // https://github.com/BabylonJS/Babylon.js/pull/9192 (keep canvas to work with < 4.2 beta-13)
            // TODO: look at parameters of other camera types for attaching - likely need an 'options' parameter instead.
            // if (camera instanceof ArcRotateCamera) {
            //     camera.attachControl(noPreventDefault, useCtrlForPanning, panningMouseButton)
            camera.attachControl(canvas, noPreventDefault);
        }
        cameraRef.current = camera;
        return function () {
            if (autoAttach === true) {
                // canvas is only needed for < 4.1.  Type typings broke in 5.x where there was no parameter.
                var canvas = scene.getEngine().getRenderingCanvas();
                camera.detachControl(canvas);
            }
            camera.dispose();
        };
    }, [scene]);
    return cameraRef.current;
};

var TaskType;
(function (TaskType) {
    TaskType["Binary"] = "Binary";
    TaskType["Mesh"] = "Mesh";
    TaskType["Texture"] = "Texture";
})(TaskType || (TaskType = {}));
var AssetManagerContext = React.createContext(undefined);
var AssetManagerContextProvider = function (props) {
    var _a = useState(undefined), progress = _a[0], setProgress = _a[1];
    return (React.createElement(AssetManagerContext.Provider, { value: { lastProgress: progress, updateProgress: setProgress } }, props.children));
};
var getTaskKey = function (task) {
    switch (task.taskType) {
        case TaskType.Binary:
            return "binary:".concat(task.url);
        case TaskType.Mesh:
            return "mesh:".concat(task.rootUrl, "/").concat(task.sceneFilename);
        case TaskType.Texture:
            return "texture:".concat(task.url);
        default:
            throw new Error("Unknown task type: ".concat(JSON.stringify(task)));
    }
};
/**
 * This has limited functionality and only works for limited asset types.
 *
 * This is an experimental API and *WILL* change.
 * TODO: function signature is not any.
 */
var useAssetManagerWithCache = function () {
    // we need our own memoized cache. useMemo, useState, etc. fail miserably - throwing a promise forces the component to remount.
    var suspenseCache = {};
    var suspenseScene = null;
    var tasksCompletedCache = {};
    return function (tasks, options) {
        // hooks cannot be used inside a callback (this is not a callback)
        // eslint-disable-next-line react-hooks/rules-of-hooks
        var hookScene = useScene();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        var assetManagerContext = useContext(AssetManagerContext);
        var opts = options || {
            useDefaultLoadingScreen: false,
        };
        if (opts.scene === undefined && hookScene === null) {
            throw new Error('useAssetManager can only be used inside a Scene component (or pass scene as an option)');
        }
        var scene = opts.scene || hookScene;
        if (suspenseScene == null) {
            suspenseScene = scene;
        }
        else {
            if (suspenseScene !== scene) {
                // console.log('new scene detected - clearing useAssetManager cache');
                // new scene detected.  clearing all caches.
                suspenseCache = {};
                // NOTE: could keep meshes with mesh.serialize and Mesh.Parse
                // Need to research how to do with textures, etc.
                // browser cache should make the load fast in most cases
                tasksCompletedCache = {};
                suspenseScene = scene;
            }
        }
        // invalidate cache with objects from another scene
        // Object.getOwnPropertyNames(tasksCompletedCache).forEach(propertyName => {
        //     const task: AbstractAssetTask = tasksCompletedCache[propertyName];
        //     if (task instanceof TextureAssetTask) {
        //         if (task.texture.getScene() !== scene) {
        //             console.log(`clearing ${task.name} from cache (different scene)`);
        //             delete tasksCompletedCache[propertyName];
        //         } else {
        //             console.log(`scane scene ${task.name}`, scene, task.texture.getScene());
        //         }
        //     }
        // });
        var createGetAssets = function (tasks) {
            if (!Array.isArray(tasks)) {
                throw new Error('Asset Manager tasks must be an array');
            }
            var newRequests = new Map();
            var assetManager = new AssetsManager(scene);
            var cachedTasks = [];
            tasks.forEach(function (task) {
                var key = getTaskKey(task);
                if (key !== undefined && suspenseCache[key]) {
                    cachedTasks.push(suspenseCache[key]);
                }
                else {
                    switch (task.taskType) {
                        case TaskType.Binary: {
                            var binaryTask = assetManager.addBinaryFileTask(task.name, task.url);
                            newRequests.set(binaryTask, task);
                            if (task.onSuccess) {
                                binaryTask.onSuccess = task.onSuccess;
                            }
                            if (task.onError) {
                                binaryTask.onError = task.onError;
                            }
                            break;
                        }
                        case TaskType.Mesh: {
                            var meshTask = assetManager.addMeshTask(task.name, task.meshesNames, task.rootUrl, task.sceneFilename);
                            newRequests.set(meshTask, task);
                            if (task.onSuccess) {
                                meshTask.onSuccess = task.onSuccess;
                            }
                            if (task.onError) {
                                meshTask.onError = task.onError;
                            }
                            break;
                        }
                        case TaskType.Texture: {
                            var textureTask = assetManager.addTextureTask(task.name, task.url, task.noMipmap, task.invertY, task.samplingMode);
                            newRequests.set(textureTask, task);
                            if (task.onSuccess) {
                                textureTask.onSuccess = task.onSuccess;
                            }
                            if (task.onError) {
                                textureTask.onError = task.onError;
                            }
                            break;
                        }
                        default:
                            throw new Error("Only binary/mesh supported currently.  'taskType' found on ".concat(JSON.stringify(task)));
                    }
                }
            });
            var createResultFromTasks = function (tasks) {
                var taskNameMap = tasks.reduce(function (prev, cur) {
                    prev[cur.name] = cur;
                    return prev;
                }, {});
                return { tasks: tasks, taskNameMap: taskNameMap };
            };
            var taskPromise = tasks.length === cachedTasks.length
                ? new Promise(function (resolve) {
                    return resolve(createResultFromTasks(cachedTasks));
                })
                : new Promise(function (resolve, reject) {
                    var _a;
                    var failed = false;
                    assetManager.useDefaultLoadingScreen = (_a = opts.useDefaultLoadingScreen) !== null && _a !== void 0 ? _a : false;
                    assetManager.onFinish = function (tasks) {
                        // whether it failed or not - we cache all results
                        tasks.forEach(function (task) {
                            if (newRequests.has(task)) {
                                // NOTE: we can skip caching failed requests (ie: due to temporary outage / 500)
                                var originalTask = newRequests.get(task);
                                var key_1 = getTaskKey(originalTask);
                                tasksCompletedCache[key_1] = task;
                            }
                        });
                        if (failed === false) {
                            // include cached ones as well.
                            var result_1 = createResultFromTasks(tasks.concat(cachedTasks));
                            resolve(result_1);
                        }
                    };
                    if (opts.reportProgress !== false && assetManagerContext !== undefined) {
                        assetManager.onProgressObservable.add(function (eventData, eventState) {
                            assetManagerContext.updateProgress({ eventData: eventData, eventState: eventState });
                        });
                    }
                    assetManager.onTaskError = function (task) {
                        var _a;
                        failed = true;
                        reject("Failed task ".concat(task.errorObject
                            ? (_a = task.errorObject.message) !== null && _a !== void 0 ? _a : "no error message on '".concat(task.name, "'")
                            : task.name));
                    };
                    assetManager.load();
                });
            var result;
            var error = null;
            var suspender = null;
            suspender = (function () { return __awaiter(void 0, void 0, void 0, function () {
                var e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, 3, 4]);
                            return [4 /*yield*/, taskPromise];
                        case 1:
                            result = _a.sent();
                            return [3 /*break*/, 4];
                        case 2:
                            e_1 = _a.sent();
                            error = e_1;
                            return [3 /*break*/, 4];
                        case 3:
                            suspender = null;
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            }); })();
            var getAssets = function () {
                if (suspender) {
                    throw suspender;
                }
                if (error !== null) {
                    throw error;
                }
                return result;
            };
            return getAssets;
        };
        var key = JSON.stringify(tasks);
        if (suspenseCache[key] === undefined) {
            suspenseCache[key] = createGetAssets(tasks);
        }
        return suspenseCache[key]();
    };
};
// this isn't a hook being called
// eslint-disable-next-line react-hooks/rules-of-hooks
var useAssetManager = useAssetManagerWithCache();

var useCustomPropsHandler = function (propsHandler /*, deps?: React.DependencyList | undefined*/) {
    var firstRun = useRef(true);
    if (firstRun.current === true) {
        CustomPropsHandler.RegisterPropsHandler(propsHandler);
        firstRun.current = false;
    }
    useEffect(function () {
        return function () {
            // console.warn('de-registering on unmount', propsHandler.name);
            CustomPropsHandler.UnregisterPropsHandler(propsHandler);
        };
    }, []);
};
/**
 * useHover hook
 *
 * NOTE: Supports Mesh and 2D GUI controls only (not 3D GUI).
 *
 * @param over expression when hover over starts
 * @param out expression when hover stops
 * @param ownRef to re-use a Ref you already have, otherwise one is created for you and returned.
 */
var useHover = function (over, out, ownRef) {
    var _a = useState(false), value = _a[0], setValue = _a[1];
    var createdRef = useRef(null);
    var ref = ownRef !== null && ownRef !== void 0 ? ownRef : createdRef;
    useEffect(function () {
        if (ref.current) {
            var registeredMeshActions_1 = [];
            var observer2dGuiEnter_1 = null;
            var observer2dGuiOut_1 = null;
            if (ref.current instanceof AbstractMesh$1) {
                var mesh = ref.current;
                if (!mesh.actionManager) {
                    mesh.actionManager = new ActionManager(mesh.getScene());
                }
                var onPointerOverAction = mesh.actionManager.registerAction(new ExecuteCodeAction(ActionManager.OnPointerOverTrigger, function (ev) {
                    over && over(ev);
                    setValue(true);
                }));
                var onPointerOutAction = mesh.actionManager.registerAction(new ExecuteCodeAction(ActionManager.OnPointerOutTrigger, function (ev) {
                    out && out(ev);
                    setValue(false);
                }));
                registeredMeshActions_1.push(onPointerOverAction);
                registeredMeshActions_1.push(onPointerOutAction);
            }
            else if (ref.current instanceof Control$1) {
                var control = ref.current;
                observer2dGuiEnter_1 = control.onPointerEnterObservable.add(over);
                observer2dGuiOut_1 = control.onPointerOutObservable.add(out);
            }
            else {
                console.warn('Can only apply useHover to non-mesh/2D control currently.', ref.current);
            }
            if (registeredMeshActions_1.length > 0 || observer2dGuiEnter_1 !== null) {
                return function () {
                    if (ref.current) {
                        if (registeredMeshActions_1.length > 0) {
                            registeredMeshActions_1.forEach(function (action) {
                                var _a;
                                if (action !== null) {
                                    var mesh = ref.current;
                                    (_a = mesh.actionManager) === null || _a === void 0 ? void 0 : _a.unregisterAction(action);
                                }
                            });
                            registeredMeshActions_1.splice(0, registeredMeshActions_1.length);
                        }
                        if (observer2dGuiEnter_1 !== null) {
                            var control = ref.current;
                            control.onPointerEnterObservable.remove(observer2dGuiEnter_1);
                            control.onPointerOutObservable.remove(observer2dGuiOut_1);
                            observer2dGuiEnter_1 = null;
                            observer2dGuiOut_1 = null;
                        }
                    }
                };
            }
        }
    }, [ref.current]);
    // todo: if use ref.current as dep,  duplicate register action.
    return [ref, value];
};
/**
 * useClick hook
 *
 * @param onClick What would be passed in the OnPickTrigger from ActionManager
 * @param ownRef to re-use a Ref you already have, otherwise one is created for you and returned.
 */
function useClick(onClick, ownRef) {
    var createdRef = useRef(null);
    var ref = ownRef !== null && ownRef !== void 0 ? ownRef : createdRef;
    useEffect(function () {
        if (ref.current) {
            if (ref.current instanceof AbstractMesh$1) {
                var mesh_1 = ref.current;
                if (!mesh_1.actionManager) {
                    mesh_1.actionManager = new ActionManager(mesh_1.getScene());
                }
                var action_1 = mesh_1.actionManager.registerAction(new ExecuteCodeAction(ActionManager.OnPickTrigger, function (ev) {
                    onClick(ev);
                }));
                return function () {
                    var _a;
                    // unregister on teardown
                    (_a = mesh_1.actionManager) === null || _a === void 0 ? void 0 : _a.unregisterAction(action_1);
                };
            }
            else {
                console.warn('onClick hook only supports referencing Meshes');
            }
        }
    }, [ref]);
    // todo: if use ref.current as dep,  duplicate register action.
    return [ref];
}

/**
 * Experimental - this will change - just a demo!
 *
 * Allows dynamic registration of host elements that the reconciler will take into consideration (case sensitive).
 */
var HostRegistrationStore = /** @class */ (function () {
    function HostRegistrationStore() {
    }
    /**
     * Registers a new host element
     * @param host host element to dynamically register
     */
    HostRegistrationStore.Register = function (host) {
        this._store[host.hostElementName] = host;
    };
    /**
     * Retrieve a registered host by element name
     */
    HostRegistrationStore.GetRegisteredHost = function (hostElementName) {
        return this._store[hostElementName];
    };
    HostRegistrationStore._store = {};
    return HostRegistrationStore;
}());

/**
 * @deprecated Please use @see applyPropsToRef instead
 * (same functionality different parameters better name, but doesn't work with "public" ref provided by reconciler)
 * @param hostInstance a babylonjs public ref (available with useRef)
 * @param props
 */
var applyInitialPropsToInstance = function (target, props) {
    // this is a bad cast.  it is here for backwards compatibility with a react-spring dependency that only uses vector/color prop changes.
    var initPayload = [];
    if ('__rb_createdInstance' in target) {
        var createdInstance = target.__rb_createdInstance;
        if (createdInstance.propsHandlers) {
            createdInstance.propsHandlers.getPropsHandlers().forEach(function (propHandler) {
                var handlerUpdates = propHandler.getPropertyUpdates({}, // We will reapply any props passed in (will not "clear" props, if we pass in an undefined prop)
                props);
                if (handlerUpdates !== null) {
                    initPayload.push.apply(initPayload, handlerUpdates);
                }
            });
        }
    }
    if (initPayload.length > 0) {
        // this is all copied code from `applyUpdateToInstance(...)`
        initPayload.forEach(function (update) {
            switch (update.changeType) {
                case PropChangeType.Primitive:
                case PropChangeType.FresnelParameters:
                case PropChangeType.LambdaExpression:
                case PropChangeType.Texture:
                    // console.log(` > ${type}: updating ${update.changeType} on ${update.propertyName} to ${update.value}`)
                    if (update.propertyName.indexOf('.') !== -1) {
                        var dotProps = update.propertyName.split('.');
                        var lastProp = dotProps.pop();
                        var newTarget = dotProps.reduce(function (target, prop) { return target[prop]; }, target);
                        newTarget[lastProp] = update.value;
                    }
                    else {
                        target[update.propertyName] = update.value;
                    }
                    break;
                case PropChangeType.Vector3:
                    if (target[update.propertyName]) {
                        target[update.propertyName].copyFrom(update.value);
                    }
                    else if (update.value) {
                        target[update.propertyName] = update.value.clone();
                    }
                    else {
                        target[update.propertyName] = update.value; // ie: undefined/null?
                    }
                    break;
                case PropChangeType.Color3:
                case PropChangeType.Color4:
                    if (update.value) {
                        target[update.propertyName] = update.value.clone();
                    }
                    else {
                        target[update.propertyName] = update.value;
                    }
                    break;
                case PropChangeType.Control:
                    target[update.propertyName] = update.value;
                    break;
                case PropChangeType.NumericArray:
                    target[update.propertyName] = update.value;
                    break;
                case PropChangeType.Observable:
                    console.warn('observable not supported for plugins (create a request if needed)');
                    break;
                case PropChangeType.Method:
                    if (typeof target[update.propertyName] === 'function') {
                        if (Array.isArray(update.value)) {
                            target[update.propertyName].apply(target, update.value);
                        }
                        else if (Object(update.value) !== update.value) {
                            // primitive, undefined & null.  Comparison is 7x slower than instanceof check,
                            // TODO: should be: update.value === undefined || typeof(update.value) === 'number' || ...
                            target[update.propertyName](update.value);
                        }
                        else {
                            // TODO: there is a bug here in that setTarget={new Vector3(0, 1, 0)} will throw an exception...
                            console.error("need to make sure this isn't something like a Vector3 before destructuring");
                            target[update.propertyName].apply(target, Object.values(update.value));
                        }
                    }
                    else {
                        console.error("Cannot call [not a function] ".concat(update.propertyName, "(...) on:"), target);
                    }
                    break;
                case PropChangeType.Quaternion:
                    // console.warn(`quaternion update detected ${update.propertyName} to:`, update.value)
                    if (target[update.propertyName]) {
                        target[update.propertyName].copyFrom(update.value);
                    }
                    else if (update.value) {
                        target[update.propertyName] = update.value.clone();
                    }
                    else {
                        target[update.propertyName] = update.value; // ie: undefined/null?
                    }
                    break;
                default:
                    console.error("Unhandled property update of type '".concat(update.changeType, "'"));
                    break;
            }
        });
    }
};

var CreationType = /** @class */ (function () {
    function CreationType() {
    }
    CreationType.FactoryMethod = 'FactoryMethod';
    CreationType.Constructor = 'Constructor';
    return CreationType;
}());

var BaseLifecycleListener = /** @class */ (function () {
    function BaseLifecycleListener(scene, props) {
        this.scene = scene;
        this.props = props;
        /* empty */
    }
    BaseLifecycleListener.prototype.onParented = function (parent, child) {
        if (child.customProps.assignFrom !== undefined) {
            // when mounted to the root container the parent is considered the "Scene". Needed for ie: scene.imageProcessingConfiguration property.
            var parentHostInstance = parent.metadata.className === 'root' ? this.scene : parent.hostInstance;
            if (parentHostInstance[child.customProps.assignFrom] === undefined) {
                console.error("Cannot find existing property ".concat(child.customProps.assignFrom, " on parent component (check your 'assignFrom')"));
            }
            else {
                // TODO: should we try to verify types like we do in 'fromInstance'?
                child.hostInstance = parentHostInstance[child.customProps.assignFrom];
                if (child.deferredCreationProps && child.propsHandlers) {
                    applyInitialPropsToCreatedInstance(child, child.deferredCreationProps);
                }
                else {
                    console.warn('cannot assign deferred props.  they are lost.');
                }
                child.deferredCreationProps = undefined;
            }
        }
    };
    BaseLifecycleListener.prototype.onChildAdded = function (child, parent) {
        /* empty */
    };
    BaseLifecycleListener.prototype.onMount = function (instance) {
        /* empty */
    };
    BaseLifecycleListener.prototype.onUnmount = function () {
        /* empty */
    };
    return BaseLifecycleListener;
}());

var AbstractMeshLifecycleListener = /** @class */ (function (_super) {
    __extends(AbstractMeshLifecycleListener, _super);
    function AbstractMeshLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractMeshLifecycleListener.prototype.onMount = function (instance) {
        if (instance === undefined || instance.hostInstance === undefined) {
            console.error('Missing instance');
            return;
        }
        var mesh = instance.hostInstance;
        var tmp = instance.parent;
        while (tmp !== null) {
            if (tmp.metadata && tmp.metadata.isGlowLayer === true) {
                if (tmp.customProps.addIncludeOnlyChildren === true) {
                    tmp.hostInstance.addIncludedOnlyMesh(mesh);
                    if (instance.customProps.childMeshesNotTracked === true) {
                        for (var _i = 0, _a = mesh.getChildMeshes(false); _i < _a.length; _i++) {
                            var childMesh = _a[_i];
                            tmp.hostInstance.addIncludedOnlyMesh(childMesh);
                        }
                    }
                }
                break;
            }
            if (tmp.metadata &&
                tmp.metadata.isShadowGenerator === true &&
                tmp.customProps.shadowCastChildren === true) {
                if (tmp.hostInstance !==
                    undefined /* ShadowGenerators have deferred creation (waiting on light source) */) {
                    tmp.hostInstance.addShadowCaster(mesh, instance.customProps.childMeshesNotTracked === true);
                }
            }
            tmp = tmp.parent;
        }
    };
    /**
     * This was copied from 'NodeLifecycleListener'.  TODO: Would be better to have inheritance hierarchy like 'BaseLifecycleListener'.
     */
    AbstractMeshLifecycleListener.prototype.onParented = function (parent, child) {
        _super.prototype.onParented.call(this, parent, child);
        if (parent.metadata.isNode && child.metadata.isNode) {
            // TODO: consider add option for setParent(), which parents and maintains mesh pos/rot in world space
            // child.hostInstance.setParent(parent.hostInstance)
            child.hostInstance.parent = parent.hostInstance;
        }
    };
    return AbstractMeshLifecycleListener;
}(BaseLifecycleListener));

var AdvancedDynamicTextureLifecycleListener = /** @class */ (function (_super) {
    __extends(AdvancedDynamicTextureLifecycleListener, _super);
    function AdvancedDynamicTextureLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AdvancedDynamicTextureLifecycleListener.prototype.onMount = function (instance) {
        instance.state = { added: true }; // allow children to attach
        this.addControls(instance);
        if (instance.customProps.createForParentMesh) {
            // console.log('for parent mesh', instance.parent ? instance.parent.babylonJsObject : 'error: no parent object')
            var mesh = instance.parent.hostInstance; // should crawl parent hierarchy for a mesh
            // console.error('we will be attaching the mesh:', mesh.name, mesh);
            var material = new StandardMaterial$1('AdvancedDynamicTextureMaterial', mesh.getScene());
            material.backFaceCulling = false;
            material.diffuseColor = Color3.Black();
            material.specularColor = Color3.Black();
            if (instance.hostInstance === undefined) {
                console.error('missing instance');
            }
            else {
                if (this.props.hasAlpha) {
                    material.diffuseTexture = instance.hostInstance;
                    material.emissiveTexture = instance.hostInstance;
                    instance.hostInstance.hasAlpha = true;
                }
                else {
                    material.emissiveTexture = instance.hostInstance;
                    material.opacityTexture = instance.hostInstance;
                }
            }
            mesh.material = material;
            // set to true unless explicitly not wanted.
            // connects the texture to a hosting mesh to enable interactions
            var supportPointerMove = this.props.supportPointerMove !== false ? true : false;
            instance.hostInstance.attachToMesh(mesh, supportPointerMove);
        }
    };
    AdvancedDynamicTextureLifecycleListener.prototype.addControls = function (instance) {
        var _this = this;
        // When there is a panel, it must be added before the children. Otherwise there is no UtilityLayer to attach to.
        // This project before 'react-reconciler' was added from parent up the tree.  'react-reconciler' wants to do the opposite.
        instance.children.forEach(function (child) {
            if (child.metadata.isGUI2DControl === true) {
                if (instance.metadata.isGUI2DGrid === true) {
                    var _a = child.customProps, gridRow = _a.gridRow, gridColumn = _a.gridColumn;
                    instance.hostInstance.addControl(child.hostInstance, gridRow, gridColumn);
                }
                else {
                    instance.hostInstance.addControl(child.hostInstance);
                }
                child.state = child.state ? __assign(__assign({}, child.state), { added: true }) : { added: true };
            }
        });
        if (instance.customProps.connectControlNames !== undefined &&
            Array.isArray(instance.customProps.connectControlNames)) {
            var controlNames = instance.customProps
                .connectControlNames;
            var root = instance;
            while (root.parent !== null) {
                root = root.parent;
            }
            this.connect(instance, root, controlNames);
        }
        instance.children.forEach(function (child) {
            _this.addControls(child);
        });
    };
    AdvancedDynamicTextureLifecycleListener.prototype.connect = function (keyboard, searchInstance, controlNames) {
        var _this = this;
        if (searchInstance.metadata.isGUI2DControl &&
            searchInstance.hostInstance &&
            controlNames.indexOf(searchInstance.hostInstance.name) !== -1) {
            // console.log(keyboard.hostInstance, '.connect(->', searchInstance.hostInstance)
            keyboard.hostInstance.connect(searchInstance.hostInstance);
        }
        searchInstance.children.forEach(function (child) { return _this.connect(keyboard, child, controlNames); });
    };
    return AdvancedDynamicTextureLifecycleListener;
}(BaseLifecycleListener));
/**
 * This is attached by convention in react-reconciler HostConfig.
 */
var ADTFullscreenUILifecycleListener = /** @class */ (function (_super) {
    __extends(ADTFullscreenUILifecycleListener, _super);
    function ADTFullscreenUILifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ADTFullscreenUILifecycleListener;
}(AdvancedDynamicTextureLifecycleListener));

var BehaviorLifecycleListener = /** @class */ (function (_super) {
    __extends(BehaviorLifecycleListener, _super);
    function BehaviorLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.behaviorAware = null;
        _this.behavior = null;
        return _this;
    }
    BehaviorLifecycleListener.prototype.onParented = function (parent, child) {
        var _a;
        _super.prototype.onParented.call(this, parent, child);
        if (parent.metadata.isNode &&
            ((_a = parent.hostInstance) === null || _a === void 0 ? void 0 : _a.addBehavior) /* TODO: verify if this needs to be a mesh */ &&
            child.metadata.isBehavior /* always true? */) {
            parent.hostInstance.addBehavior(child.hostInstance);
            this.behaviorAware = parent.hostInstance;
            this.behavior = child.hostInstance;
        }
        else {
            console.warn('Could not locate IBehaviorAware on Behavior parent.');
        }
    };
    BehaviorLifecycleListener.prototype.onUnmount = function () {
        if (this.behaviorAware) {
            this.behaviorAware.removeBehavior(this.behavior);
        }
    };
    return BehaviorLifecycleListener;
}(BaseLifecycleListener));

var CameraLifecycleListener = /** @class */ (function (_super) {
    __extends(CameraLifecycleListener, _super);
    function CameraLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CameraLifecycleListener.prototype.onParented = function (parent, child) {
        _super.prototype.onParented.call(this, parent, child);
        if (parent.metadata.isNode && child.metadata.isNode) {
            // TODO: consider add option for setParent(), which parents and maintains mesh pos/rot in world space
            // child.hostInstance.setParent(parent.hostInstance)
            child.hostInstance.parent = parent.hostInstance;
        }
    };
    CameraLifecycleListener.prototype.onMount = function (instance) {
        if (instance.hostInstance === undefined) {
            console.error('Missing instance');
            return;
        }
        // prevent default unless explicitly specified.
        var camera = instance.hostInstance;
        var noPreventDefault = this.props.noPreventDefault === false ? false : true;
        // console.log('camera.attachControl:', camera, this.canvas, noPreventDefault)
        // should be a custom property for autoAttaching?  Will be an issue for multiple cameras.
        camera.attachControl(this.scene.getEngine().getRenderingCanvas(), noPreventDefault);
        // Targeting removed from here - handled by TargetPropsHandler
    };
    return CameraLifecycleListener;
}(BaseLifecycleListener));

var DeferredCreationLifecycleListener = /** @class */ (function (_super) {
    __extends(DeferredCreationLifecycleListener, _super);
    function DeferredCreationLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DeferredCreationLifecycleListener.prototype.onMount = function (instance) {
        var createdInstance = this.createInstance(instance, this.scene, this.props);
        if (createdInstance === undefined) {
            console.warn('was unable to create deferred instance');
        }
        else {
            // Meed to assign deferred props (from delayed creation) or they are lost:
            if (instance.deferredCreationProps && instance.propsHandlers) {
                applyInitialPropsToCreatedInstance(instance, instance.deferredCreationProps);
            }
            else {
                console.warn('cannot assign deferred props.  they are lost.');
            }
            instance.deferredCreationProps = undefined;
        }
    };
    return DeferredCreationLifecycleListener;
}(BaseLifecycleListener));

/**
 * Create a Shadow Generator (CascadedShadowGenerator extends ShadowGenerator, so add/remove shadow casters is from parent class)
 */
var BaseShadowGeneratorLifecycleListener = /** @class */ (function (_super) {
    __extends(BaseShadowGeneratorLifecycleListener, _super);
    function BaseShadowGeneratorLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onMeshAddedObservable = null;
        _this.onMeshRemovedObservable = null;
        _this.createInstance = function (instance, scene, props) {
            var tmp = instance.parent;
            var result = null;
            while (tmp !== null) {
                if (tmp.metadata.isShadowLight) {
                    // console.log(`Creating ${this.generatorType}  size: ${props.mapSize} with light`, tmp.hostInstance);
                    instance.hostInstance = result = _this.createShadowGenerator(props.mapSize, tmp.hostInstance, props.useFullFloatFirst);
                    break;
                }
                tmp = tmp.parent;
            }
            if (instance.hostInstance === undefined) {
                console.error("".concat(_this.generatorType, " has no light source."));
                return null;
            }
            if (instance.customProps.shadowCastChildren === true) {
                // recursively add children once the generator has completed deferred creation - after this meshes will add themselves from their LifecycleListener.
                var addShadowCasters_1 = function (children, generator) {
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        if (child.metadata.isMesh === true) {
                            generator.addShadowCaster(child.hostInstance, child.customProps.childMeshesNotTracked === true);
                        }
                        if (child.children.length !== 0) {
                            addShadowCasters_1(child.children, generator);
                        }
                    }
                };
                addShadowCasters_1(instance.children, instance.hostInstance);
            }
            else if (instance.customProps.shadowCasters) {
                if (!Array.isArray(instance.customProps.shadowCasters)) {
                    console.error('Shadow casters must be an array (of strings).', instance.customProps.shadowCasters);
                    return null;
                }
                var shadowCasters_1 = instance.customProps
                    .shadowCasters;
                // TODO: also need a listener for models or if we want to add a predicate:
                _this.onMeshAddedObservable = scene.onNewMeshAddedObservable.add(function (mesh) {
                    if (shadowCasters_1.indexOf(mesh.name) >= 0) {
                        instance.hostInstance.addShadowCaster(mesh);
                    }
                });
                _this.onMeshRemovedObservable = scene.onMeshRemovedObservable.add(function (mesh) {
                    if (shadowCasters_1.indexOf(mesh.name) >= 0) {
                        instance.hostInstance.removeShadowCaster(mesh);
                    }
                });
                scene.meshes.forEach(function (mesh) {
                    if (shadowCasters_1.indexOf(mesh.name) >= 0) {
                        instance.hostInstance.addShadowCaster(mesh);
                    }
                });
            }
            else if (instance.customProps.shadowCastersExcluding) {
                if (!Array.isArray(instance.customProps.shadowCastersExcluding)) {
                    console.error('Shadow casters excluding must be an array (of strings).', instance.customProps.shadowCastersExcluding);
                }
                else {
                    var shadowCastersExcluding_1 = instance.customProps.shadowCastersExcluding;
                    // TODO: also need a listener for models or if we want to add a predicate:
                    _this.onMeshAddedObservable = scene.onNewMeshAddedObservable.add(function (mesh) {
                        if (shadowCastersExcluding_1.indexOf(mesh.name) === -1) {
                            instance.hostInstance.addShadowCaster(mesh);
                        }
                    });
                    _this.onMeshRemovedObservable = scene.onMeshRemovedObservable.add(function (mesh) {
                        if (shadowCastersExcluding_1.indexOf(mesh.name) === -1) {
                            instance.hostInstance.removeShadowCaster(mesh);
                        }
                    });
                    scene.meshes.forEach(function (mesh) {
                        if (shadowCastersExcluding_1.indexOf(mesh.name) === -1) {
                            instance.hostInstance.addShadowCaster(mesh);
                        }
                    });
                }
            }
            return result;
        };
        return _this;
    }
    BaseShadowGeneratorLifecycleListener.prototype.onUnmount = function () {
        if (this.onMeshAddedObservable !== null) {
            this.scene.onNewMeshAddedObservable.remove(this.onMeshAddedObservable);
            this.onMeshAddedObservable = null;
        }
        if (this.onMeshRemovedObservable !== null) {
            this.scene.onMeshRemovedObservable.remove(this.onMeshRemovedObservable);
            this.onMeshRemovedObservable = null;
        }
    };
    return BaseShadowGeneratorLifecycleListener;
}(DeferredCreationLifecycleListener));

var CascadedShadowGeneratorLifecycleListener = /** @class */ (function (_super) {
    __extends(CascadedShadowGeneratorLifecycleListener, _super);
    function CascadedShadowGeneratorLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createShadowGenerator = function (mapSize, light, useFullFloatFirst) {
            return new CascadedShadowGenerator$1(mapSize, light, useFullFloatFirst);
        };
        return _this;
    }
    Object.defineProperty(CascadedShadowGeneratorLifecycleListener.prototype, "generatorType", {
        get: function () {
            return 'CascadedShadowGenerator';
        },
        enumerable: false,
        configurable: true
    });
    return CascadedShadowGeneratorLifecycleListener;
}(BaseShadowGeneratorLifecycleListener));

/**
 * These have no constructor.  Are only created from the engine.
 */
var EngineViewLifecycleListener = /** @class */ (function (_super) {
    __extends(EngineViewLifecycleListener, _super);
    function EngineViewLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createInstance = function (instance, scene, props) {
            var _a;
            var canvas = (_a = props.canvas) !== null && _a !== void 0 ? _a : _this.scene.getEngine().getRenderingCanvas();
            if (canvas === null) {
                return null;
            }
            instance.hostInstance = scene.getEngine().registerView(canvas, props.camera);
            return instance.hostInstance;
        };
        return _this;
    }
    EngineViewLifecycleListener.prototype.onUnmount = function () {
        var canvas = this.scene.getEngine().getRenderingCanvas();
        if (canvas !== null) {
            this.scene.getEngine().unRegisterView(canvas);
        }
    };
    return EngineViewLifecycleListener;
}(DeferredCreationLifecycleListener));

var EnvironmentHelperLifecycleListener = /** @class */ (function (_super) {
    __extends(EnvironmentHelperLifecycleListener, _super);
    function EnvironmentHelperLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EnvironmentHelperLifecycleListener.prototype.onMount = function (instance) {
        if (instance.hostInstance === undefined) {
            console.error('Missing instance');
            return;
        }
        // for TypeScript people use <... setMainColor={[mainColor]} />
        // NOTE: this is missing in FiberEnvironmentHelperProps, so will fail in autocompletion as well as in TypeScript projects.
        if (this.props.mainColor) {
            instance.hostInstance.setMainColor(this.props.mainColor);
        }
        if (this.props.teleportEnvironmentGround) {
            console.error('need to enable teleportation to ground (also from VRExperienceHelper, so call order has no impact.');
        }
    };
    return EnvironmentHelperLifecycleListener;
}(BaseLifecycleListener));

var FallbackLifecycleListener = /** @class */ (function (_super) {
    __extends(FallbackLifecycleListener, _super);
    function FallbackLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return FallbackLifecycleListener;
}(BaseLifecycleListener));

var GizmoLifecycleListener = /** @class */ (function (_super) {
    __extends(GizmoLifecycleListener, _super);
    function GizmoLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GizmoLifecycleListener.prototype.onMount = function (instance) {
        var _a, _b;
        var gizmo = instance.hostInstance;
        var gizmoProps = instance.customProps;
        if (gizmoProps.skipUtilityLayerAttach !== true) {
            var tmp = instance.parent;
            var foundUtilityLayerRender = false;
            while (tmp !== null) {
                if (tmp.metadata && tmp.metadata.isUtilityLayerRenderer === true) {
                    gizmo.gizmoLayer = tmp.hostInstance;
                    foundUtilityLayerRender = true;
                    break;
                }
                tmp = tmp.parent;
            }
            if (foundUtilityLayerRender !== true) {
                console.warn('utility layer not found (if intentional use skipUtilityLayerAttach)');
            }
        }
        if (gizmoProps.skipAutoAttach !== true ||
            (gizmoProps.attachGizmoToMesh !== false && gizmoProps.attachGizmoToNode !== false)) {
            var searchType = gizmoProps.attachGizmoToMesh === undefined && gizmoProps.attachGizmoToNode === undefined
                ? null // default with no attach preference specified
                : gizmoProps.attachGizmoToMesh === true
                    ? 'mesh'
                    : gizmoProps.attachGizmoToNode === true
                        ? 'node'
                        : null;
            var tmp = instance.parent;
            while (tmp !== null) {
                // Note: LightGizmo expects attachedMesh when assigning light, so check Mesh first
                // https://forum.babylonjs.com/t/lightgizmo-attaching-a-node/23653/3
                if ((searchType === null || searchType === 'mesh') && ((_a = tmp.metadata) === null || _a === void 0 ? void 0 : _a.isMesh) === true) {
                    gizmo.attachedMesh = tmp.hostInstance;
                    break;
                }
                if ((searchType === null || searchType === 'node') && ((_b = tmp.metadata) === null || _b === void 0 ? void 0 : _b.isNode) === true) {
                    gizmo.attachedNode = tmp.hostInstance;
                    break;
                }
                tmp = tmp.parent;
            }
        }
    };
    return GizmoLifecycleListener;
}(BaseLifecycleListener));

var GizmoManagerLifecycleListener = /** @class */ (function (_super) {
    __extends(GizmoManagerLifecycleListener, _super);
    function GizmoManagerLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GizmoManagerLifecycleListener.prototype.onChildAdded = function (child, parent) {
        var gizmoManager = parent.hostInstance;
        // TODO: check usePointerToAttachGizmos?
        if (child.metadata && child.metadata.isGizmo !== true) {
            if (child.metadata.isNode === true) {
                gizmoManager.attachToNode(child.hostInstance);
            }
            else if (child.metadata.isMesh === true) {
                gizmoManager.attachToMesh(child.hostInstance);
            }
        }
    };
    return GizmoManagerLifecycleListener;
}(BaseLifecycleListener));

var RowOrColumnDefinitionPropsHandlers = /** @class */ (function () {
    function RowOrColumnDefinitionPropsHandlers() {
    }
    RowOrColumnDefinitionPropsHandlers.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var changedProps = [];
        checkPrimitiveDiff(oldProps.value, newProps.value, 'value', changedProps);
        checkPrimitiveDiff(oldProps.unit, newProps.unit, 'unit', changedProps);
        return changedProps.length === 0 ? null : changedProps;
    };
    return RowOrColumnDefinitionPropsHandlers;
}());
/**
 * Handles property updates.
 */
var RowOrColumnDefinitionPropsHandler = /** @class */ (function () {
    function RowOrColumnDefinitionPropsHandler() {
        this.propsHandlers = [new RowOrColumnDefinitionPropsHandlers()];
    }
    RowOrColumnDefinitionPropsHandler.prototype.getPropsHandlers = function () {
        return this.propsHandlers;
    };
    RowOrColumnDefinitionPropsHandler.prototype.addPropsHandler = function (propHandler) {
        this.propsHandlers.push(propHandler);
    };
    return RowOrColumnDefinitionPropsHandler;
}());

var GUI2DControlLifecycleListener = /** @class */ (function (_super) {
    __extends(GUI2DControlLifecycleListener, _super);
    function GUI2DControlLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GUI2DControlLifecycleListener.prototype.onMount = function (instance) {
        if (instance === undefined) {
            console.error('Missing instance');
            return;
        }
        if (instance.customProps.defaultKeyboard === true &&
            instance.hostInstance instanceof VirtualKeyboard$1) {
            // TODO: Generate from factory method.  VirtualKeyboard.CreateDefaultLayout()
            instance.hostInstance.addKeysRow(['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '\u2190']);
            instance.hostInstance.addKeysRow(['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p']);
            instance.hostInstance.addKeysRow([
                'a',
                's',
                'd',
                'f',
                'g',
                'h',
                'j',
                'k',
                'l',
                ';',
                "'",
                '\u21B5',
            ]);
            instance.hostInstance.addKeysRow(['\u21E7', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/']);
            instance.hostInstance.addKeysRow([' '], [{ width: '200px' }]);
        }
        if (instance.state && instance.state.added === true) {
            return;
        }
        var addedParent = null;
        var tmp = instance.parent;
        while (tmp) {
            if (tmp.metadata.isGUI2DControl) {
                if (tmp.state && tmp.state.added === true) {
                    addedParent = tmp;
                    break;
                }
            }
            tmp = tmp.parent;
        }
        if (addedParent) {
            this.addControls(addedParent);
        }
    };
    /**
     * BabylonJS won't re-add the same control twice, so it's a safe operation to add.
     *
     * @param instance contol to recursively add children to.
     */
    GUI2DControlLifecycleListener.prototype.addControls = function (instance) {
        var _this = this;
        instance.children.forEach(function (child) {
            if (child.metadata.isGUI2DControl === true) {
                if (instance.metadata.isGUI2DGrid === true) {
                    var _a = child.customProps, gridRow = _a.gridRow, gridColumn = _a.gridColumn;
                    instance.hostInstance.addControl(child.hostInstance, gridRow, gridColumn);
                }
                else {
                    instance.hostInstance.addControl(child.hostInstance);
                }
                child.state = { added: true };
            }
        });
        instance.children.forEach(function (child) {
            _this.addControls(child);
        });
    };
    return GUI2DControlLifecycleListener;
}(BaseLifecycleListener));

var GUI3DControlLifecycleListener = /** @class */ (function (_super) {
    __extends(GUI3DControlLifecycleListener, _super);
    function GUI3DControlLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GUI3DControlLifecycleListener.prototype.onMount = function (instance) {
        if (instance.state && instance.state.added === true) {
            return;
        }
        var addedParent = null;
        var tmp = instance.parent;
        while (tmp) {
            if (tmp.metadata.isGUI3DControl === true) {
                if (tmp.state && tmp.state.added === true) {
                    addedParent = tmp;
                    break;
                }
            }
            tmp = tmp.parent;
        }
        if (addedParent) {
            this.addControls(addedParent, addedParent);
        }
    };
    GUI3DControlLifecycleListener.prototype.addControls = function (instance, last3DGuiControl) {
        var _this = this;
        var last3d = instance.metadata.isGUI3DControl === true ? instance : last3DGuiControl;
        instance.children.forEach(function (child) {
            if (last3d.customProps.childrenAsContent === true) {
                last3d.hostInstance.content = child.hostInstance; // child.hostInstance will be GUI.Control (ie: 2D)
                child.state = { added: true, content: true };
            }
            else if (child.metadata.isGUI3DControl === true) {
                last3d.hostInstance.addControl(child.hostInstance);
                // NOTE: this must be called after .addControl(child.hostInstance).
                if (child.customProps.linkToTransformNodeByName) {
                    var toLinkTo = _this.scene.getMeshByName(child.customProps.linkToTransformNodeByName);
                    if (toLinkTo !== null) {
                        child.hostInstance.linkToTransformNode(toLinkTo);
                        // toLinkTo.computeWorldMatrix()
                    }
                    else {
                        console.error('linkToTransformNode cannot find Mesh:', instance.customProps.linkToTransformNodeByName, ' and does not have a scene listener for added meshes. Declare Mesh earlier or add an issue on github (TransformNode does not work).');
                    }
                }
                child.state = { added: true };
            }
        });
        if (instance.children.length > 0) {
            instance.children.forEach(function (child) {
                if (!child.state || child.state.content !== true) {
                    if (child.state &&
                        child.state.added === true &&
                        typeof child.customProps.onControlAdded === 'function') {
                        child.customProps.onControlAdded(child);
                    }
                    _this.addControls(child, last3d);
                }
            });
        }
    };
    return GUI3DControlLifecycleListener;
}(BaseLifecycleListener));

var GUI3DManagerLifecycleListener = /** @class */ (function (_super) {
    __extends(GUI3DManagerLifecycleListener, _super);
    function GUI3DManagerLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GUI3DManagerLifecycleListener.prototype.onMount = function (instance) {
        if (instance === undefined) {
            console.error('Missing instance');
            return;
        }
        this.addControls(instance, instance);
    };
    /**
     * We may have BoundComponents inbetween gui3d controls.
     */
    GUI3DManagerLifecycleListener.prototype.addControls = function (instance, last3DGuiControl) {
        var _this = this;
        // When there is a panel, it must be added before the children. Otherwise there is no UtilityLayer to attach to.
        // This project before 'react-reconciler' was added from parent up the tree.  'react-reconciler' wants to do the opposite.
        instance.children.forEach(function (child) {
            if (child.metadata.isGUI3DControl === true) {
                if ('childrenAsContent' in last3DGuiControl.customProps &&
                    last3DGuiControl.customProps.childrenAsContent === true) {
                    last3DGuiControl.hostInstance.content = child.hostInstance;
                    child.state = { added: true, content: true };
                }
                else {
                    last3DGuiControl.hostInstance.addControl(child.hostInstance);
                    child.state = { added: true };
                    // NOTE: this must be called after .addControl(child.hostInstance).
                    if ('linkToTransformNodeByName' in child.customProps &&
                        child.customProps.linkToTransformNodeByName) {
                        var toLinkTo = _this.scene.getMeshByName(child.customProps.linkToTransformNodeByName);
                        if (toLinkTo !== null) {
                            child.hostInstance.linkToTransformNode(toLinkTo);
                        }
                        else {
                            console.error('linkToTransformNode cannot find ', instance.customProps.linkToTransformNodeByName, ' and does not have a scene listener for added meshes.  Declare earlier or add an issue on github.');
                        }
                    }
                }
            }
            if (child.state &&
                child.state.added === true &&
                child.customProps.onControlAdded) {
                child.customProps.onControlAdded(child);
            }
            if (!child.state || child.state.content !== true) {
                var last3d = child.metadata.isGUI3DControl === true ? child : last3DGuiControl;
                _this.addControls(child, last3d);
            }
        });
        // Here we can now do a transform with an anchor point.
        // console.error('transform gui3dmanager anchor missing')
    };
    return GUI3DManagerLifecycleListener;
}(BaseLifecycleListener));

/**
 * Assign value to an object property
 *
 * @param value: What you are assigning
 * @param target: Target to assign value to
 * @param propertyPath Where to assign value to on target (path to assign.  ie: "baseTexture" or "mesh.material")
 *
 */
function assignProperty(value, target, propertyPath) {
    var propertyPaths = Array.isArray(propertyPath) ? propertyPath : [propertyPath];
    propertyPaths.forEach(function (propPath) {
        var propsList = propPath.split('.');
        propsList.forEach(function (prop, index) {
            // for assigning to arrays (ie: Texture to model -> meshes[1].material.albedoTexture)
            var arrayRegex = /(?<arrayName>.*)\[(?<arrayIndexString>\d+)\]$/;
            var match = prop.match(arrayRegex);
            if (match && match.groups) {
                var _a = match.groups, arrayName = _a.arrayName, arrayIndexString = _a.arrayIndexString;
                var arrayIndex = parseInt(arrayIndexString);
                var arrayProp = target[arrayName];
                if (arrayProp === undefined ||
                    !Array.isArray(arrayProp) ||
                    arrayIndex >= arrayProp.length) {
                    console.error("Array not found or missing index (skipping) for property assignment: '".concat(arrayName, "[").concat(arrayIndex, "]'"), target);
                }
                else {
                    if (index === propsList.length - 1) {
                        arrayProp[arrayIndex] = value;
                    }
                    else {
                        target = arrayProp[arrayIndex];
                    }
                }
            }
            else {
                if (target[prop] === undefined) {
                    // create property if it doesn't exist.
                    console.warn("Created property ".concat(prop, " on: (from ").concat(propsList, ")"), target);
                    target[prop] = {};
                }
                if (index === propsList.length - 1) {
                    target[prop] = value;
                }
                else {
                    target = target[prop];
                }
            }
        });
    });
}

var MaterialsLifecycleListener = /** @class */ (function (_super) {
    __extends(MaterialsLifecycleListener, _super);
    function MaterialsLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MaterialsLifecycleListener.prototype.onCreated = function (instance, scene) {
        if (instance.customProps.attachToMeshesByName) {
            if (!Array.isArray(instance.customProps.attachToMeshesByName)) {
                console.error('AttachToMeshesByName must be an array (of strings).', instance.customProps.attachToMeshesByName);
                return;
            }
            if (instance.hostInstance === undefined) {
                console.error('instance not assigned');
                return;
            }
            var meshNamesToAttachTo_1 = instance.customProps.attachToMeshesByName.slice(0);
            // TODO: also need a listener for models or if we want to add a predicate:
            scene.onNewMeshAddedObservable.add(function (mesh) {
                if (meshNamesToAttachTo_1.indexOf(mesh.name) >= 0) {
                    setTimeout(function () {
                        mesh.material = instance.hostInstance;
                    }, 0);
                }
            });
            scene.meshes.forEach(function (mesh) {
                if (meshNamesToAttachTo_1.indexOf(mesh.name) >= 0) {
                    mesh.material = instance.hostInstance;
                }
            });
        }
    };
    MaterialsLifecycleListener.prototype.onMount = function (instance) {
        if (instance === undefined) {
            console.error('Missing instance');
            return;
        }
        if (!instance.customProps.attachToMeshesByName) {
            var material = instance.hostInstance;
            var tmp = instance.parent;
            while (tmp !== null) {
                if (tmp.metadata && tmp.metadata.acceptsMaterials === true) {
                    if (instance.customProps.assignTo) {
                        assignProperty(material, tmp.hostInstance, instance.customProps.assignTo);
                    }
                    else {
                        tmp.hostInstance.material = material;
                    }
                    break;
                }
                tmp = tmp.parent;
            }
        }
    };
    return MaterialsLifecycleListener;
}(BaseLifecycleListener));

var NodeLifecycleListener = /** @class */ (function (_super) {
    __extends(NodeLifecycleListener, _super);
    function NodeLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeLifecycleListener.prototype.onParented = function (parent, child) {
        _super.prototype.onParented.call(this, parent, child);
        if (parent.metadata.isNode && child.metadata.isNode) {
            // TODO: consider add option for setParent(), which parents and maintains mesh pos/rot in world space
            // child.hostInstance.setParent(parent.hostInstance)
            child.hostInstance.parent = parent.hostInstance;
        }
    };
    return NodeLifecycleListener;
}(BaseLifecycleListener));

/**
 * There is a lot going on in the PhysicsImpostor constructor, so we delay instantiation so that we have a target
 * 'object' before creation.
 */
var PhysicsImpostorLifecycleListener = /** @class */ (function (_super) {
    __extends(PhysicsImpostorLifecycleListener, _super);
    function PhysicsImpostorLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createInstance = function (instance, scene, props) {
            if (!_this._parent) {
                return null;
            }
            // these should be set from the props handler.  TODO: test.
            var options = props._options; // constructor has a default { mass: 0 }
            instance.hostInstance = new PhysicsImpostor$1(_this._parent, props.type, options, _this.scene);
            instance.hostInstance.object = _this._parent;
            _this._parent.physicsImpostor = instance.hostInstance;
            // TODO: need to assign deferredCreationProps (@see ShadowGeneratorLifecycleListener).
            return instance.hostInstance;
        };
        return _this;
    }
    PhysicsImpostorLifecycleListener.prototype.onParented = function (parent, child) {
        _super.prototype.onParented.call(this, parent, child);
        // IPhysicsEnabledObject requires only position and rotationQuaternion
        if (parent.hostInstance.position === undefined ||
            parent.hostInstance.rotationQuaternion === undefined) {
            console.warn('PhysicsImpostor is parented to an element that does not appear to implement IPhysicsEnabledObject');
        }
        this._parent = parent.hostInstance;
    };
    return PhysicsImpostorLifecycleListener;
}(DeferredCreationLifecycleListener));

var ShadowGeneratorLifecycleListener = /** @class */ (function (_super) {
    __extends(ShadowGeneratorLifecycleListener, _super);
    function ShadowGeneratorLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createShadowGenerator = function (mapSize, light, useFullFloatFirst) {
            return new ShadowGenerator$1(mapSize, light, useFullFloatFirst);
        };
        return _this;
    }
    Object.defineProperty(ShadowGeneratorLifecycleListener.prototype, "generatorType", {
        get: function () {
            return 'ShadowGenerator';
        },
        enumerable: false,
        configurable: true
    });
    return ShadowGeneratorLifecycleListener;
}(BaseShadowGeneratorLifecycleListener));

// This does not work when declared component with 'lockedTargetMeshName' is before the mesh with that name.
// Need to wait for full commit mount of entire tree, so use in conjunction with LifecycleListner is best option.
var TargetPropsHandler = /** @class */ (function () {
    function TargetPropsHandler(scene) {
        this.scene = scene;
    }
    TargetPropsHandler.prototype.getPropertyUpdates = function (oldProps, newProps) {
        var propertyUpdates = [];
        if (!oldProps.lockedTargetMeshName ||
            oldProps.lockedTargetMeshName !== newProps.lockedTargetMeshName) {
            if (typeof newProps.lockedTargetMeshName === 'string') {
                propertyUpdates.push({
                    changeType: PropChangeType.Primitive,
                    propertyName: 'lockedTarget',
                    value: this.scene.getMeshByName(newProps.lockedTargetMeshName),
                });
            }
        }
        return propertyUpdates;
    };
    return TargetPropsHandler;
}());

var TexturesLifecycleListener = /** @class */ (function (_super) {
    __extends(TexturesLifecycleListener, _super);
    function TexturesLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TexturesLifecycleListener.prototype.onMount = function (instance) {
        var assignTo = instance.customProps.assignTo;
        var texture = instance.hostInstance;
        var tmp = instance.parent;
        while (tmp !== null) {
            if (tmp.metadata &&
                (tmp.metadata.isMaterial === true ||
                    tmp.metadata.className === 'Model' ||
                    tmp.metadata.isLayer === true)) {
                if (assignTo) {
                    assignProperty(texture, tmp.hostInstance, assignTo);
                }
                else {
                    if (tmp.metadata.isLayer === true) {
                        continue;
                    }
                    // maybe below case is more common, so let it default
                    tmp.hostInstance.diffuseTexture = texture;
                }
                break;
            }
            tmp = tmp.parent;
        }
    };
    return TexturesLifecycleListener;
}(BaseLifecycleListener));

var ViewportLifecycleListener = /** @class */ (function (_super) {
    __extends(ViewportLifecycleListener, _super);
    function ViewportLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ViewportLifecycleListener.prototype.onMount = function (instance) {
        if (instance === undefined) {
            console.error('Missing instance (for viewport)');
            return;
        }
        var viewport = instance.hostInstance;
        var tmp = instance.parent;
        while (tmp !== null) {
            if (tmp.metadata && tmp.metadata.isCamera === true) {
                if (instance.customProps.assignTo) {
                    assignProperty(viewport, tmp.hostInstance, instance.customProps.assignTo);
                }
                else {
                    tmp.hostInstance.viewport = viewport;
                }
                break;
            }
            tmp = tmp.parent;
        }
    };
    return ViewportLifecycleListener;
}(BaseLifecycleListener));

/**
 * This should be replaced entirely with XR version.
 */
var VRExperienceHelperLifecycleListener = /** @class */ (function (_super) {
    __extends(VRExperienceHelperLifecycleListener, _super);
    function VRExperienceHelperLifecycleListener() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VRExperienceHelperLifecycleListener.prototype.onMount = function (instance) {
        if (this.props.enableInteractions) {
            instance.hostInstance.enableInteractions();
        }
    };
    return VRExperienceHelperLifecycleListener;
}(BaseLifecycleListener));

// With respect to renderers there are two types of react components:

var CUSTOM_HOSTS = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AbstractMeshLifecycleListener: AbstractMeshLifecycleListener,
    ADTFullscreenUILifecycleListener: ADTFullscreenUILifecycleListener,
    AdvancedDynamicTextureLifecycleListener: AdvancedDynamicTextureLifecycleListener,
    BehaviorLifecycleListener: BehaviorLifecycleListener,
    CameraLifecycleListener: CameraLifecycleListener,
    CascadedShadowGeneratorLifecycleListener: CascadedShadowGeneratorLifecycleListener,
    EngineViewLifecycleListener: EngineViewLifecycleListener,
    EnvironmentHelperLifecycleListener: EnvironmentHelperLifecycleListener,
    FallbackLifecycleListener: FallbackLifecycleListener,
    GizmoLifecycleListener: GizmoLifecycleListener,
    GizmoManagerLifecycleListener: GizmoManagerLifecycleListener,
    GUI2DControlLifecycleListener: GUI2DControlLifecycleListener,
    GUI3DControlLifecycleListener: GUI3DControlLifecycleListener,
    GUI3DManagerLifecycleListener: GUI3DManagerLifecycleListener,
    MaterialsLifecycleListener: MaterialsLifecycleListener,
    NodeLifecycleListener: NodeLifecycleListener,
    PhysicsImpostorLifecycleListener: PhysicsImpostorLifecycleListener,
    ShadowGeneratorLifecycleListener: ShadowGeneratorLifecycleListener,
    TargetPropsHandler: TargetPropsHandler,
    TexturesLifecycleListener: TexturesLifecycleListener,
    ViewportLifecycleListener: ViewportLifecycleListener,
    VRExperienceHelperLifecycleListener: VRExperienceHelperLifecycleListener,
    RowOrColumnDefinitionPropsHandlers: RowOrColumnDefinitionPropsHandlers,
    RowOrColumnDefinitionPropsHandler: RowOrColumnDefinitionPropsHandler
});

/**
 * We delay instantiation and when parented add a column definition to parent "Grid".
 */
var ColumnDefinitionLifecycleListener = /** @class */ (function (_super) {
    __extends(ColumnDefinitionLifecycleListener, _super);
    function ColumnDefinitionLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createInstance = function (instance, scene, props) {
            if (!_this._grid) {
                return null;
            }
            _this._grid.addColumnDefinition(props.value, props.unit === ValueAndUnit.UNITMODE_PIXEL);
            instance.hostInstance = _this._grid.getColumnDefinition(_this._grid.columnCount - 1);
            return instance.hostInstance;
        };
        return _this;
    }
    ColumnDefinitionLifecycleListener.prototype.onParented = function (parent, child) {
        _super.prototype.onParented.call(this, parent, child);
        // TODO: search hierarchy for a grid, but it should always be parent.
        this._grid = parent.hostInstance;
    };
    return ColumnDefinitionLifecycleListener;
}(DeferredCreationLifecycleListener));
var ColumnDefinition = {
    hostElementName: 'columnDefinition',
    propHandlerInstance: new RowOrColumnDefinitionPropsHandler(),
    hostFactory: function (scene) { return null; },
    lifecycleListenerFactory: function (scene, props) {
        return new ColumnDefinitionLifecycleListener(scene, props);
    },
    createInfo: {
        creationType: 'Constructor',
        libraryLocation: 'ValueAndUnit',
        namespace: '@babylonjs/gui',
        parameters: [
        /* value and unit! */
        ],
    },
    // TODO: this should be "M"etadata
    metadata: {
        className: 'ColumnDefinition',
        delayCreation: true,
    },
};

/**
 * We delay instantiation and when parented add a row definition to parent "Grid".
 */
var RowDefinitionLifecycleListener = /** @class */ (function (_super) {
    __extends(RowDefinitionLifecycleListener, _super);
    function RowDefinitionLifecycleListener() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.createInstance = function (instance, scene, props) {
            if (!_this._grid) {
                return null;
            }
            _this._grid.addRowDefinition(props.value, props.unit === ValueAndUnit.UNITMODE_PIXEL);
            instance.hostInstance = _this._grid.getRowDefinition(_this._grid.rowCount - 1);
            return instance.hostInstance;
        };
        return _this;
    }
    RowDefinitionLifecycleListener.prototype.onParented = function (parent, child) {
        _super.prototype.onParented.call(this, parent, child);
        // TODO: search hierarchy for a grid, but it should always be parent.
        this._grid = parent.hostInstance;
    };
    return RowDefinitionLifecycleListener;
}(DeferredCreationLifecycleListener));
var RowDefinition = {
    hostElementName: 'rowDefinition',
    propHandlerInstance: new RowOrColumnDefinitionPropsHandler(),
    hostFactory: function (scene) { return null; },
    lifecycleListenerFactory: function (scene, props) {
        return new RowDefinitionLifecycleListener(scene, props);
    },
    createInfo: {
        creationType: 'Constructor',
        libraryLocation: 'ValueAndUnit',
        namespace: '@babylonjs/gui',
        parameters: [
        /* value and unit! */
        ],
    },
    // TODO: this should be "M"etadata
    metadata: {
        className: 'RowDefinition',
        delayCreation: true,
    },
};

var BABYLONEXT = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DynamicTerrain: DynamicTerrain$1
});

function createCreatedInstance(className, hostInstance, propsHandlers, metadata, customProps, lifecycleListener) {
    if (propsHandlers.isTargetable === true) {
        metadata.isTargetable = true;
    }
    return {
        children: [],
        customProps: customProps,
        hostInstance: hostInstance,
        lifecycleListener: lifecycleListener,
        metadata: metadata,
        observers: {},
        parent: null,
        propsHandlers: propsHandlers,
    };
}
/**
 * remove instance's children recursively
 *
 * @param parentInstance
 * @param child
 */
function removeChild(parentInstance, child) {
    if (child) {
        var hostInstance = child.hostInstance;
        if (child.lifecycleListener) {
            child.lifecycleListener.onUnmount();
        }
        if (child.metadata.isNode) {
            hostInstance.parent = null;
        }
        else if (child.metadata.isGUI3DControl === true) {
            console.error('3D remove control not implemented.');
        }
        if (parentInstance.metadata &&
            parentInstance.metadata.isGUI2DControl === true &&
            child.metadata.isGUI2DControl === true) {
            // NOTE: the if statement should be || and we may need to walk the tree to remove.
            parentInstance.hostInstance.removeControl(child.hostInstance);
        }
        if (child.children) {
            removeRecursive(child.children, child);
        }
        if (child.hostInstance &&
            child.customProps.disposeInstanceOnUnmount &&
            typeof child.hostInstance.dispose === 'function') {
            hostInstance.dispose(); // TODO: Consider adding metadata/descriptors as some dispose methods have optional args.
        }
        // fix: old version rootInstance.children was not cleaned, so the children array maybe huge over time
        parentInstance.children = parentInstance.children.filter(function (ci) { return ci !== child; });
        child.parent = null;
    }
}
/**
 * remove child recursive
 */
function removeRecursive(array, parent, clone) {
    if (clone === void 0) { clone = false; }
    if (array) {
        var target = clone ? __spreadArray([], array, true) : array;
        target.forEach(function (child) { return removeChild(parent, child); });
    }
}
function addChild(parent, child, childIndex) {
    if (parent) {
        if (!child) {
            console.error('undefined child', parent);
        }
        else {
            // doubly linking child to parent
            parent.children.push(child);
            child.parent = parent;
        }
    }
    if (child && child.lifecycleListener && child.lifecycleListener.onParented) {
        child.lifecycleListener.onParented(parent, child);
    }
    if (parent && parent.lifecycleListener && parent.lifecycleListener.onChildAdded) {
        parent.lifecycleListener.onChildAdded(child, parent);
    }
}
/**
 * Allows constructor arguments to register for dynamically registered property transforms (should exclude undefined).
 * TODO: include other types or add "PropsChangeType" to GeneratedParameters (would increase bundle size)
 *
 * @param type generated name (not same as PropChangeType)
 * @param value parameter value
 */
var getConstructorValue = function (type, value) {
    switch (type) {
        case 'BabylonjsCoreVector3': {
            var v3result = CustomPropsHandler.HandlePropsChange(PropChangeType.Vector3, undefined, value);
            return v3result.processed ? v3result.value : value;
        }
        case 'BabylonjsCoreColor3': {
            var c3result = CustomPropsHandler.HandlePropsChange(PropChangeType.Vector3, undefined, value);
            return c3result.processed ? c3result.value : value;
        }
        case 'BabylonjsCoreColor4': {
            var c4result = CustomPropsHandler.HandlePropsChange(PropChangeType.Color4, undefined, value);
            return c4result.processed ? c4result.value : value;
        }
        default:
            return value;
    }
};
var ReactBabylonJSHostConfig = {
    // This has the reconciler include in call chain ie: appendChild, removeChild
    get supportsMutation() {
        return true;
    },
    now: function () {
        return Date.now(); // TODO: use performance.now
    },
    // multiple renderers concurrently render using the same context objects. E.g. React DOM and React ART on the
    // same page. DOM is the primary renderer; ART is the secondary renderer.
    get isPrimaryRenderer() {
        return false;
    },
    get supportsPersistence() {
        return false;
    },
    // TODO: see if this will allow ie: improved HMR/fast refresh support.  Need to implement a lot of currently optional methods.
    get supportsHydration() {
        return false;
    },
    // enables refs to the Babylon hosted instance
    getPublicInstance: function (instance) {
        return instance === null || instance === void 0 ? void 0 : instance.hostInstance;
    },
    getRootHostContext: function (rootContainerInstance) {
        // this is the context you pass to your chilren, as parameter 'parentHostContext' from "root".
        // So, opportunity to share context here via HostConfig further up tree.
        return rootContainerInstance;
    },
    // this is the context you pass down to children.  without this root will not be available to attach to in appendChildToContainer.
    getChildHostContext: function (parentHostContext, type, rootContainerInstance) {
        return parentHostContext;
    },
    prepareUpdate: function (instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
        if (!instance || (instance.metadata && instance.metadata.customType === true)) {
            return null;
        }
        var updatePayload = [];
        // Only custom types will not have a fiber object to handle props changes
        instance.propsHandlers.getPropsHandlers().forEach(function (propHandler) {
            var handlerUpdates = propHandler.getPropertyUpdates(oldProps, newProps);
            if (handlerUpdates !== null) {
                updatePayload.push.apply(updatePayload, handlerUpdates);
            }
        });
        return updatePayload.length === 0 ? null : updatePayload;
    },
    clearContainer: function (container) {
        container.rootInstance.children.splice(0);
    },
    insertBefore: function (parentInstance, child, beforeChild) {
        if (parentInstance && beforeChild !== undefined) {
            parentInstance.children.indexOf(beforeChild);
        }
        addChild(parentInstance, child);
    },
    /**
     * This is called when something is dynamically added to root (not on initial appendChildToContainer)
     */
    insertInContainerBefore: function (container, child, beforeChild) {
        // Similar to appendChildToContainer, but indexed insertion
        if (child) {
            var index = container.rootInstance.children.indexOf(beforeChild);
            if (index >= 0) {
                container.rootInstance.children.splice(index, 0, child);
            }
            else {
                container.rootInstance.children.push(child);
            }
            // doubly link child to root.
            child.parent = container.rootInstance;
        }
        else {
            console.error('insertInContainerBefore. No child:', child);
        }
    },
    createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var _a, _b;
        // TODO: Make a registry like React Native host config or just build a map in /customHosts/index.ts.
        var customTypes = [];
        // TODO: Check source for difference between hostContext and rootContainerInstance.
        var scene = rootContainerInstance.scene;
        if (customTypes.indexOf(type) !== -1) {
            var metadata_1 = __assign({ className: type, customType: true }, props.metadata);
            var createdInstance = {
                children: [],
                customProps: {},
                hostInstance: null,
                lifecycleListener: new CUSTOM_HOSTS[type + 'Fiber'](scene, scene.getEngine(), props),
                metadata: metadata_1,
                observers: {},
                parent: null,
                propsHandlers: undefined,
            };
            // onCreated and other lifecycle hooks are not called for built-in host
            return createdInstance;
        }
        // some types (ie: button) are called 'babylonjs-button'.
        var underlyingClassName = intrinsicClassMap[type] || type;
        var classDefinition = GENERATED["Fiber".concat(underlyingClassName)];
        var dynamicRegisteredHost = undefined;
        if (classDefinition === undefined) {
            var ownDynamicHosts = {
                rowDefinition: RowDefinition,
                columnDefinition: ColumnDefinition,
            };
            if (underlyingClassName in ownDynamicHosts) {
                dynamicRegisteredHost = ownDynamicHosts[underlyingClassName];
            }
            else {
                dynamicRegisteredHost = HostRegistrationStore.GetRegisteredHost(type);
            }
        }
        if (classDefinition === undefined && dynamicRegisteredHost === undefined) {
            throw new Error("Cannot generate type '".concat(type, "/").concat(underlyingClassName, "' inside 'react-babylonjs' (ie: no DOM rendering on HTMLCanvas)"));
        }
        var metadata;
        var babylonObject = undefined;
        // TODO: define this type as an export.
        var customProps = {
            // Control3D
            childrenAsContent: props.childrenAsContent === true,
            // AdvancedDynamicTexture
            createForParentMesh: props.createForParentMesh === true,
            onControlAdded: typeof props.onControlAdded === 'function' ? props.onControlAdded : undefined,
            connectControlNames: props.connectControlNames,
            defaultKeyboard: props.defaultKeyboard === true,
            linkToTransformNodeByName: props.linkToTransformNodeByName,
            shadowCasters: props.shadowCasters,
            shadowCastersExcluding: props.shadowCastersExcluding,
            attachToMeshesByName: props.attachToMeshesByName,
            assignTo: props.assignTo,
            assignFrom: props.assignFrom,
            disposeInstanceOnUnmount: props.assignFrom === undefined,
            addIncludeOnlyChildren: props.addIncludeOnlyChildren === true,
            childMeshesNotTracked: props.childMeshesNotTracked === true,
            shadowCastChildren: props.shadowCastChildren,
            skipAutoAttach: props.skipAutoAttach,
            attachGizmoToMesh: props.attachGizmoToMesh,
            attachGizmoToNode: props.attachGizmoToNode,
            gridColumn: props.gridColumn,
            gridRow: props.gridRow,
        };
        if (customProps.assignFrom !== undefined) {
            // will be assigned once parented in lifecyclelistener
            metadata =
                dynamicRegisteredHost !== undefined
                    ? dynamicRegisteredHost.metadata
                    : classDefinition.Metadata;
        }
        else if (dynamicRegisteredHost !== undefined) {
            metadata = dynamicRegisteredHost.metadata;
            if (metadata.delayCreation !== true) {
                babylonObject = dynamicRegisteredHost.hostFactory(scene);
            }
        }
        else {
            var createInfoArgs = classDefinition.CreateInfo;
            metadata = classDefinition.Metadata;
            var generatedParameters = createInfoArgs.parameters;
            if (props.fromInstance !== undefined) {
                if (createInfoArgs.namespace.startsWith('@babylonjs/')) {
                    var clazz = babylonClassFactory(type);
                    // instanceof will check prototype and derived classes (ie: can assign Mesh instance to a Node)
                    if (props.fromInstance instanceof clazz) {
                        babylonObject = props.fromInstance;
                        customProps.disposeInstanceOnUnmount = props.disposeInstanceOnUnmount === true;
                    }
                    else {
                        // prevent assigning incorrect type.
                        console.error('fromInstance wrong type.', props.fromInstance, clazz);
                    }
                }
                else {
                    console.error('cannot generate non babylonjs using fromInstance');
                }
            }
            else {
                // console.log("generated params:", generatedParameters)
                var args = generatedParameters.map(function (generatedParameter) {
                    if (Array.isArray(generatedParameter.type)) {
                        // TODO: if all props are missing, warn if main prop (ie: options) is required.
                        var newParameter_1 = {};
                        generatedParameter.type.forEach(function (subParameter) {
                            var subPropValue = getConstructorValue(subParameter.type, props[subParameter.name]);
                            if (subPropValue === undefined &&
                                subParameter.optional === false &&
                                generatedParameter.optional === false) {
                                console.warn('Missing a required secondary property:', subParameter.name);
                            }
                            else {
                                newParameter_1[subParameter.name] = subPropValue;
                            }
                        });
                        return newParameter_1;
                    }
                    else {
                        var value = getConstructorValue(generatedParameter.type, props[generatedParameter.name]);
                        if (value === undefined) {
                            // NOTE: we removed the hosted Scene component, which needs (generatedParameter.type == "BabylonjsCoreEngine")
                            // SceneOrEngine type is Scene
                            if (generatedParameter.type.includes('BabylonjsCoreScene') ||
                                (generatedParameter.type === 'any' && generatedParameter.name === 'scene')) {
                                // MeshBuild.createSphere(name: string, options: {...}, scene: any)
                                // console.log('Assigning scene to:', type, generatedParameter)
                                value = scene;
                            }
                        }
                        if (value === undefined && generatedParameter.optional === false) {
                            console.warn("On ".concat(type, " you are missing a non-optional parameter '").concat(generatedParameter.name, "' of type '").concat(generatedParameter.type, "'"));
                        }
                        return value;
                    }
                });
                if (createInfoArgs.creationType === CreationType.FactoryMethod) {
                    // console.warn(`creating from Factory: ${createInfoArgs.libraryLocation}.${createInfoArgs.factoryMethod}(...args).  args:`, args);
                    babylonObject = (_a = babylonClassFactory(createInfoArgs.libraryLocation))[createInfoArgs.factoryMethod].apply(_a, args);
                }
                else {
                    if (metadata.delayCreation !== true) {
                        if (createInfoArgs.namespace.startsWith('@babylonjs/')) {
                            var clazz = babylonClassFactory(type);
                            if (clazz === undefined) {
                                throw new Error("Cannot generate '".concat(type, "' (react-babylonjs):"));
                            }
                            babylonObject = new (clazz.bind.apply(clazz, __spreadArray([void 0], args, false)))();
                        }
                        else if (createInfoArgs.namespace.startsWith('./extensions/')) {
                            var extClassName = intrinsicClassMap[type] || type;
                            babylonObject = new ((_b = BABYLONEXT[extClassName]).bind.apply(_b, __spreadArray([void 0], args, false)))();
                        }
                        else {
                            console.error('metadata defines (or does not) a namespace that is known', createInfoArgs.namespace);
                        }
                    }
                }
            }
        }
        // Developer accessible lifecycle phase.  ie: access propery/method exposed in props.
        if (typeof props.onCreated === 'function') {
            props.onCreated(babylonObject);
        }
        var fiberObject = dynamicRegisteredHost !== undefined
            ? dynamicRegisteredHost.propHandlerInstance
            : new GENERATED["Fiber".concat(underlyingClassName)]();
        // Consider these being dynamically attached to a list, much like PropsHandlers<T>
        var metadataLifecycleListenerName;
        if (metadata.isGizmo === true) {
            metadataLifecycleListenerName = 'Gizmo';
        }
        else if (metadata.isMaterial === true) {
            metadataLifecycleListenerName = 'Materials';
        }
        else if (metadata.isTexture === true) {
            // must be before .isGUI2DControl, since ADT/FullScreenUI declare both.
            metadataLifecycleListenerName = 'Textures';
        }
        else if (metadata.isGUI3DControl === true) {
            metadataLifecycleListenerName = 'GUI3DControl';
        }
        else if (metadata.isGUI2DControl === true) {
            metadataLifecycleListenerName = 'GUI2DControl';
        }
        else if (metadata.isCamera === true) {
            metadataLifecycleListenerName = 'Camera';
        }
        else if (metadata.isMesh === true) {
            metadataLifecycleListenerName = 'AbstractMesh';
        }
        else if (metadata.isNode === true) {
            metadataLifecycleListenerName = 'Node';
        }
        else if (metadata.isBehavior === true) {
            metadataLifecycleListenerName = 'Behavior';
        }
        var lifecycleListener;
        // here we dynamically assign listeners for specific types.
        // TODO: need to double-check because we are using 'camelCase'
        if (CUSTOM_HOSTS[underlyingClassName + 'LifecycleListener'] !== undefined) {
            lifecycleListener = new CUSTOM_HOSTS[underlyingClassName + 'LifecycleListener'](scene, props);
        }
        else if (metadataLifecycleListenerName !== undefined) {
            lifecycleListener = new CUSTOM_HOSTS[metadataLifecycleListenerName + 'LifecycleListener'](scene, props);
        }
        else if (dynamicRegisteredHost === null || dynamicRegisteredHost === void 0 ? void 0 : dynamicRegisteredHost.lifecycleListenerFactory) {
            lifecycleListener = dynamicRegisteredHost.lifecycleListenerFactory(scene, props);
        }
        else {
            lifecycleListener = new FallbackLifecycleListener(scene, props);
        }
        var createdReference = createCreatedInstance(underlyingClassName, babylonObject, fiberObject, metadata, customProps, lifecycleListener);
        if (lifecycleListener.onCreated) {
            lifecycleListener.onCreated(createdReference, scene);
        }
        // Here we dynamically attach known props handlers.  This is a better way to have mixins and dynamic props handling via composition (and registration).
        if (createdReference.metadata && createdReference.metadata.isTargetable === true) {
            fiberObject.addPropsHandler(new TargetPropsHandler(scene));
        }
        if (metadata.delayCreation !== true && customProps.assignFrom === undefined) {
            // console.log('applying inital props', createdReference, metadata);
            applyInitialPropsToCreatedInstance(createdReference, props);
        }
        else {
            createdReference.deferredCreationProps = props;
        }
        // TODO: make this an opt-in -- testing inspectable metadata (and our Custom Props, which we want to be more specific to Type):
        // TODO: use {} instead of NULL and use the late-binding from 'v3' branch (also for deferred creation/assignFrom).
        // fromInstance being called multiple times with same instance.
        if (createdReference.hostInstance && !('metadata-className' in createdReference.hostInstance)) {
            Object.defineProperty(createdReference.hostInstance, 'metadata-className', {
                get: function () {
                    return createdReference.metadata.className;
                },
                enumerable: true,
            });
        }
        if (createdReference.hostInstance &&
            !('__rb_createdInstance' in createdReference.hostInstance)) {
            Object.defineProperty(createdReference.hostInstance, '__rb_createdInstance', {
                get: function () {
                    return createdReference;
                },
                enumerable: true,
            });
        }
        if (babylonObject) {
            babylonObject.inspectableCustomProperties = [
                {
                    label: 'React class',
                    propertyName: 'metadata-className',
                    type: InspectableType.String,
                },
            ];
        }
        return createdReference;
    },
    // shouldDeprioritizeSubtree: (type: string, props: Props): boolean => {
    //   return false;
    // },
    hideInstance: function (instance) {
        /* empty */
    },
    unhideInstance: function (instance, props) {
        /* empty */
    },
    createTextInstance: function (text) {
        /* empty */
    },
    // scheduleDeferredCallback(callback: (deadline: RequestIdleCallbackDeadline) => void, opts?: RequestIdleCallbackOptions | undefined): any {
    //   return window.requestIdleCallback(callback, opts) // ReactDOMHostConfig has: unstable_scheduleCallback as scheduleDeferredCallback
    // },
    // cancelDeferredCallback(handle: any): void {
    //   return window.cancelIdleCallback(handle);
    // },
    scheduleTimeout: function (fn, delay) {
        return window.setTimeout(fn, delay);
    },
    cancelTimeout: function (id) {
        window.clearTimeout(id);
    },
    // https://github.com/facebook/react/blob/master/packages/react-dom/src/client/ReactDOMHostConfig.js#L288
    noTimeout: -1,
    // Called based on return value of: finalizeInitialChildren.  in-memory render tree created, but not yet attached.
    prepareForCommit: function (containerInfo) {
        return null;
    },
    preparePortalMount: function (containerInfo) {
        console.log('prepare portal mount', containerInfo); // this is the public instance...
    },
    // Called after the in-memory tree has been committed (ie: after attaching again to root element)
    resetAfterCommit: function (containerInfo) {
        /* empty */
    },
    appendInitialChild: function (parent, child) {
        // Here we are traversing downwards.  Beyond parent has not been initialized, but all children have been.
        addChild(parent, child);
    },
    // TODO: refactor with appendInitialChild
    appendChild: function (parent, child) {
        addChild(parent, child);
    },
    canHydrateInstance: function (instance, type, props) {
        // console.log("canHydrateInstance", instance, type, props)
        return null;
    },
    // The parent of this node has not yet been instantiated.  The reconciler will continue by calling:
    // createInstance → appendInitialChild → finalizeInitialChildren on the parent.
    // When that has reached the top of the recursion tree (root), then prepareForCommit() will be called.
    // NOTE: All children of this component, however, HAVE been initialized.
    finalizeInitialChildren: function () {
        return true; /* callCommitMountForThisInstance */
    },
    commitMount: function (instance, type, newProps, internalInstanceHandle) {
        if (instance && instance.lifecycleListener && instance.lifecycleListener.onMount) {
            instance.lifecycleListener.onMount(instance);
        }
    },
    // NOTE: only called if supportsMutation = true;
    // ReactDOM uses this for attaching child nodes to root DOM.  For us we want to link the all parts of tree together for tree crawling.
    // same implementation as insertInContainerBefore
    appendChildToContainer: function (container, child) {
        if (child) {
            if (container.rootInstance) {
                // doubly link child to root
                container.rootInstance.children.push(child);
                child.parent = container.rootInstance;
                // hostInstance is undefined when using "assignFrom".
                if (child.hostInstance === undefined && child.lifecycleListener) {
                    // From perspective of declarative syntax the "Scene" is the parent.
                    child.lifecycleListener.onParented(container.rootInstance, child);
                }
            }
            else {
                console.log('addend child with no root (createPortal only?)');
                addChild(container, child);
            }
        }
    },
    commitUpdate: function (instance, updatePayload, type /* old, new props and instance handle are extra ignored params */) {
        if (updatePayload !== null) {
            updatePayload.forEach(function (update) {
                if (instance) {
                    applyUpdateToInstance(instance, update);
                }
            });
        }
    },
    removeChildFromContainer: function (container, child) {
        /**
         * To fix two bugs when toggle meshes:
         * 1.  model's mesh can't be destroyed.
         * 2. `removeChildFromContainer()` only destroy babylon instance.
         * The model is rootAbstractMesh's and Parent's child.
         * `container.rootInstance.children` will be very large after few toggles.
         */
        if (child) {
            removeChild(container.rootInstance, child);
        }
    },
    removeChild: removeChild,
    // text-content nodes are not used.  treated as a leaf node.  children are not traversed.  calls methods like createTextInstance(...)
    shouldSetTextContent: function (type, props) {
        return false;
    },
};

var roots = new Map();
var ReconcilerSecondary = Reconciler(ReactBabylonJSHostConfig);
var ReconcilerPrimary = Reconciler(__assign(__assign({}, ReactBabylonJSHostConfig), { isPrimaryRenderer: true }));
/**
 * This is a work in progress in experimental state.
 */
function createPortal(children, containerInfo, key, usePrimary) {
    if (usePrimary === void 0) { usePrimary = false; }
    var reconciler = usePrimary === true ? ReconcilerPrimary : ReconcilerSecondary;
    var target = containerInfo;
    if ('__rb_createdInstance' in containerInfo) {
        // console.log('retargeting to ', containerInfo.__rb_createdInstance);
        target = containerInfo.__rb_createdInstance;
    }
    return reconciler.createPortal(children, target, null, key);
}
/*
 * Creates a reconciler instance using an internal pre-existing Reconciler instance.
 * So far the only option is if you want a primary renderer (non-default).
 */
function createReconciler(rendererOptions) {
    var reconciler = rendererOptions.usePrimary === true ? ReconcilerPrimary : ReconcilerSecondary;
    function render(element, container, callback, parentComponent) {
        var root = roots.get(container);
        if (!root) {
            // https://github.com/facebook/react/blob/master/packages/react-test-renderer/src/ReactTestRenderer.js#L449
            root = reconciler.createContainer(container, false /* isConcurrent */, false /* hydrate */);
            roots.set(container, root);
            reconciler.injectIntoDevTools({
                findFiberByHostInstance: reconciler.findFiberByHostInstance,
                bundleType: 0,
                version: version,
                rendererPackageName: 'react-babylonjs',
            });
        }
        reconciler.updateContainer(element, root, parentComponent, callback);
        return reconciler.getPublicRootInstance(root);
    }
    function unmount(container) {
        var root = roots.get(container);
        reconciler.updateContainer(null, root, null, function () {
            /* ignored */
        });
        roots.delete(container);
    }
    return {
        render: render,
        unmount: unmount,
    };
}

var updateScene = function (props, prevPropsRef, scene, propsHandler) {
    var prevProps = prevPropsRef.current;
    var updates = propsHandler.getPropertyUpdates(prevProps, props);
    if (updates !== null) {
        updates.forEach(function (propertyUpdate) {
            applyUpdateToInstance(scene, propertyUpdate);
        });
    }
    prevPropsRef.current = props;
};
var Scene = function (props, context) {
    var engine = useContext(EngineCanvasContext).engine;
    var propsHandler = useState(new FiberScenePropsHandler())[0];
    var _a = useState(false), sceneReady = _a[0], setSceneReady = _a[1];
    var _b = useState(null), scene = _b[0], setScene = _b[1];
    // TODO: make this strongly typed
    var reconcilerRef = useRef(null);
    var containerRef = useRef(null);
    var prevPropsRef = useRef({});
    // initialize babylon scene
    useEffect(function () {
        var scene = new Scene$2(engine, props.sceneOptions);
        // const onReadyObservable: Nullable<Observer<BabylonJSScene>> = scene.onReadyObservable.add(onSceneReady);
        var sceneIsReady = scene.isReady();
        if (sceneIsReady) {
            // scene.onReadyObservable.remove(onReadyObservable);
            setSceneReady(true); // this does not flow and cause a re-render
        }
        else {
            console.error('Scene is not ready. Report issue in react-babylonjs repo');
        }
        setScene(scene);
        // TODO: try to move the scene to parentComponent in updateContainer
        var container = {
            scene: scene,
            rootInstance: {
                children: [],
                customProps: {},
                hostInstance: scene,
                metadata: {
                    className: 'root',
                },
                observers: {},
                parent: null,
            },
        };
        updateScene(props, prevPropsRef, container.rootInstance, propsHandler);
        containerRef.current = container;
        var reconciler = createReconciler({});
        reconcilerRef.current = reconciler;
        var pointerDownObservable = scene.onPointerObservable.add(function (evt) {
            if (typeof props.onScenePointerDown === 'function') {
                props.onScenePointerDown(evt, scene);
            }
            if (evt && evt.pickInfo && evt.pickInfo.hit && evt.pickInfo.pickedMesh) {
                var mesh = evt.pickInfo.pickedMesh;
                if (typeof props.onMeshPicked === 'function') {
                    props.onMeshPicked(mesh, scene);
                }
            }
        }, PointerEventTypes.POINTERDOWN);
        // can only be assigned on init
        var pointerUpObservable = null;
        if (typeof props.onScenePointerUp === 'function') {
            pointerUpObservable = scene.onPointerObservable.add(function (evt) {
                props.onScenePointerUp(evt, scene);
            }, PointerEventTypes.POINTERUP);
        }
        // can only be assigned on init
        var pointerMoveObservable = null;
        if (typeof props.onScenePointerMove === 'function') {
            pointerMoveObservable = scene.onPointerObservable.add(function (evt) {
                props.onScenePointerMove(evt, scene);
            }, PointerEventTypes.POINTERMOVE);
        }
        if (typeof props.onSceneMount === 'function') {
            props.onSceneMount({
                scene: scene,
                canvas: scene.getEngine().getRenderingCanvas(),
            });
            // TODO: console.error if canvas is not attached. runRenderLoop() is expected to be part of onSceneMount().
        }
        // TODO: change enable physics to 'usePhysics' taking an object with a Vector3 and 'any'.
        // NOTE: must be enabled for updating container (cannot add impostors w/o physics enabled)
        if (Array.isArray(props.enablePhysics)) {
            scene.enablePhysics(props.enablePhysics[0], props.enablePhysics[1]);
        }
        var sceneGraph = (React.createElement(SceneContext.Provider, { value: {
                scene: scene,
                sceneReady: sceneIsReady,
            } }, props.children));
        reconciler.render(sceneGraph, container, function () {
            /* empty for now */
        }, null);
        return function () {
            if (pointerDownObservable) {
                scene.onPointerObservable.remove(pointerDownObservable);
            }
            if (pointerUpObservable) {
                scene.onPointerObservable.remove(pointerUpObservable);
            }
            if (pointerMoveObservable) {
                scene.onPointerObservable.remove(pointerMoveObservable);
            }
            if (scene.isDisposed === false) {
                scene.dispose();
            }
            // clear renderer element
            reconciler.render(null, containerRef.current, function () {
                /* empty */
            }, null);
            reconcilerRef.current = null;
            containerRef.current = null;
        };
    }, [
    /* no deps, so called only on un/mount */
    ]);
    // update babylon scene
    useEffect(function () {
        if (engine === null || scene === null || reconcilerRef.current === null) {
            return;
        }
        updateScene(props, prevPropsRef, containerRef.current.rootInstance, propsHandler);
        var sceneGraph = (React.createElement(SceneContext.Provider, { value: {
                scene: scene,
                sceneReady: sceneReady,
            } }, props.children));
        reconcilerRef.current.render(sceneGraph, containerRef.current, function () {
            /* ignored */
        }, null);
    });
    return null;
};
var Scene$1 = withEngineCanvasContext(Scene);

export { ADTForMesh, ADTForMeshTexture, ADTFullscreenUI, AbstractButton3D, AbstractMesh, AdvancedDynamicTexture, AnaglyphArcRotateCamera, AnaglyphFreeCamera, AnaglyphGamepadCamera, AnaglyphPostProcess, AnaglyphUniversalCamera, ArcFollowCamera, ArcRotateCamera, AssetManagerContext, AssetManagerContextProvider, AttachToBoxBehavior, AutoRotationBehavior, AxisDragGizmo, AxisScaleGizmo, BackgroundMaterial, BaseSixDofDragBehavior, BaseSlider, BaseTexture, BlackAndWhitePostProcess, BloomMergePostProcess, BlurPostProcess, BouncingBehavior, BoundingBoxGizmo, Box, Button, Button3D, Camera, CameraGizmo, Capsule, CascadedShadowGenerator, Checkbox, ChromaticAberrationPostProcess, CircleOfConfusionPostProcess, ColorCorrectionPostProcess, ColorGradingTexture, ColorPicker, Container, Container3D, ContentDisplay3D, Control, Control3D, ConvolutionPostProcess, CubeTexture, CustomProceduralTexture, CustomPropsHandler, Cylinder, CylinderPanel, DashedLines, Decal, DefaultBehavior, DefaultRenderingPipeline, DepthOfFieldBlurPostProcess, DepthOfFieldMergePostProcess, DetailMapConfiguration, DeviceOrientationCamera, DirectionalLight, Disc, DisplayGrid, DisplayPassPostProcess, DynamicTerrain, DynamicTexture, EffectLayer, Ellipse, ReactBabylonjsEngine as Engine, EngineCanvasContext, EngineView, EnvironmentHelper, EquiRectangularCubeTexture, ExtractHighlightsPostProcess, ExtrudePolygon, ExtrudeShape, ExtrudeShapeCustom, FadeInOutBehavior, FiberADTForMesh, FiberADTForMeshTexture, FiberADTFullscreenUI, FiberAbstractButton3D, FiberAbstractButton3DPropsHandler, FiberAbstractMesh, FiberAbstractMeshPropsHandler, FiberAdvancedDynamicTexture, FiberAdvancedDynamicTexturePropsHandler, FiberAnaglyphArcRotateCamera, FiberAnaglyphArcRotateCameraPropsHandler, FiberAnaglyphFreeCamera, FiberAnaglyphFreeCameraPropsHandler, FiberAnaglyphGamepadCamera, FiberAnaglyphGamepadCameraPropsHandler, FiberAnaglyphPostProcess, FiberAnaglyphPostProcessPropsHandler, FiberAnaglyphUniversalCamera, FiberAnaglyphUniversalCameraPropsHandler, FiberArcFollowCamera, FiberArcFollowCameraPropsHandler, FiberArcRotateCamera, FiberArcRotateCameraPropsHandler, FiberAttachToBoxBehavior, FiberAttachToBoxBehaviorPropsHandler, FiberAutoRotationBehavior, FiberAutoRotationBehaviorPropsHandler, FiberAxisDragGizmo, FiberAxisDragGizmoPropsHandler, FiberAxisScaleGizmo, FiberAxisScaleGizmoPropsHandler, FiberBackgroundMaterial, FiberBackgroundMaterialPropsHandler, FiberBaseSixDofDragBehavior, FiberBaseSixDofDragBehaviorPropsHandler, FiberBaseSlider, FiberBaseSliderPropsHandler, FiberBaseTexture, FiberBaseTexturePropsHandler, FiberBlackAndWhitePostProcess, FiberBlackAndWhitePostProcessPropsHandler, FiberBloomMergePostProcess, FiberBloomMergePostProcessPropsHandler, FiberBlurPostProcess, FiberBlurPostProcessPropsHandler, FiberBouncingBehavior, FiberBouncingBehaviorPropsHandler, FiberBoundingBoxGizmo, FiberBoundingBoxGizmoPropsHandler, FiberBox, FiberButton, FiberButton3D, FiberButton3DPropsHandler, FiberButtonPropsHandler, FiberCamera, FiberCameraGizmo, FiberCameraGizmoPropsHandler, FiberCameraPropsHandler, FiberCapsule, FiberCascadedShadowGenerator, FiberCascadedShadowGeneratorPropsHandler, FiberCheckbox, FiberCheckboxPropsHandler, FiberChromaticAberrationPostProcess, FiberChromaticAberrationPostProcessPropsHandler, FiberCircleOfConfusionPostProcess, FiberCircleOfConfusionPostProcessPropsHandler, FiberColorCorrectionPostProcess, FiberColorCorrectionPostProcessPropsHandler, FiberColorGradingTexture, FiberColorGradingTexturePropsHandler, FiberColorPicker, FiberColorPickerPropsHandler, FiberContainer, FiberContainer3D, FiberContainer3DPropsHandler, FiberContainerPropsHandler, FiberContentDisplay3D, FiberContentDisplay3DPropsHandler, FiberControl, FiberControl3D, FiberControl3DPropsHandler, FiberControlPropsHandler, FiberConvolutionPostProcess, FiberConvolutionPostProcessPropsHandler, FiberCubeTexture, FiberCubeTexturePropsHandler, FiberCustomProceduralTexture, FiberCustomProceduralTexturePropsHandler, FiberCylinder, FiberCylinderPanel, FiberCylinderPanelPropsHandler, FiberDashedLines, FiberDecal, FiberDefaultBehavior, FiberDefaultBehaviorPropsHandler, FiberDefaultRenderingPipeline, FiberDefaultRenderingPipelinePropsHandler, FiberDepthOfFieldBlurPostProcess, FiberDepthOfFieldBlurPostProcessPropsHandler, FiberDepthOfFieldMergePostProcess, FiberDepthOfFieldMergePostProcessPropsHandler, FiberDetailMapConfiguration, FiberDetailMapConfigurationPropsHandler, FiberDeviceOrientationCamera, FiberDeviceOrientationCameraPropsHandler, FiberDirectionalLight, FiberDirectionalLightPropsHandler, FiberDisc, FiberDisplayGrid, FiberDisplayGridPropsHandler, FiberDisplayPassPostProcess, FiberDisplayPassPostProcessPropsHandler, FiberDynamicTerrain, FiberDynamicTerrainPropsHandler, FiberDynamicTexture, FiberDynamicTexturePropsHandler, FiberEffectLayer, FiberEffectLayerPropsHandler, FiberEllipse, FiberEllipsePropsHandler, FiberEngineView, FiberEngineViewPropsHandler, FiberEnvironmentHelper, FiberEnvironmentHelperPropsHandler, FiberEquiRectangularCubeTexture, FiberEquiRectangularCubeTexturePropsHandler, FiberExtractHighlightsPostProcess, FiberExtractHighlightsPostProcessPropsHandler, FiberExtrudePolygon, FiberExtrudeShape, FiberExtrudeShapeCustom, FiberFadeInOutBehavior, FiberFadeInOutBehaviorPropsHandler, FiberFilterPostProcess, FiberFilterPostProcessPropsHandler, FiberFluentBackplateMaterial, FiberFluentBackplateMaterialPropsHandler, FiberFluentButtonMaterial, FiberFluentButtonMaterialPropsHandler, FiberFluentMaterial, FiberFluentMaterialPropsHandler, FiberFlyCamera, FiberFlyCameraPropsHandler, FiberFocusableButton, FiberFocusableButtonPropsHandler, FiberFollowBehavior, FiberFollowBehaviorPropsHandler, FiberFollowCamera, FiberFollowCameraPropsHandler, FiberFramingBehavior, FiberFramingBehaviorPropsHandler, FiberFreeCamera, FiberFreeCameraPropsHandler, FiberFxaaPostProcess, FiberFxaaPostProcessPropsHandler, FiberGUI3DManager, FiberGUI3DManagerPropsHandler, FiberGamepadCamera, FiberGamepadCameraPropsHandler, FiberGeodesic, FiberGizmo, FiberGizmoManager, FiberGizmoManagerPropsHandler, FiberGizmoPropsHandler, FiberGlowLayer, FiberGlowLayerPropsHandler, FiberGoldberg, FiberGoldbergMesh, FiberGoldbergMeshPropsHandler, FiberGrainPostProcess, FiberGrainPostProcessPropsHandler, FiberGrid, FiberGridPropsHandler, FiberGround, FiberGroundFromHeightMap, FiberGroundMesh, FiberGroundMeshPropsHandler, FiberHDRCubeTexture, FiberHDRCubeTexturePropsHandler, FiberHandConstraintBehavior, FiberHandConstraintBehaviorPropsHandler, FiberHandMenu, FiberHandMenuPropsHandler, FiberHandleMaterial, FiberHandleMaterialPropsHandler, FiberHemisphericLight, FiberHemisphericLightPropsHandler, FiberHighlightLayer, FiberHighlightLayerPropsHandler, FiberHighlightsPostProcess, FiberHighlightsPostProcessPropsHandler, FiberHolographicBackplate, FiberHolographicBackplatePropsHandler, FiberHolographicButton, FiberHolographicButtonPropsHandler, FiberHolographicSlate, FiberHolographicSlatePropsHandler, FiberHtmlElementTexture, FiberHtmlElementTexturePropsHandler, FiberIcoSphere, FiberImage, FiberImageBasedSlider, FiberImageBasedSliderPropsHandler, FiberImageProcessingConfiguration, FiberImageProcessingConfigurationPropsHandler, FiberImageProcessingPostProcess, FiberImageProcessingPostProcessPropsHandler, FiberImagePropsHandler, FiberImageScrollBar, FiberImageScrollBarPropsHandler, FiberInputPassword, FiberInputPasswordPropsHandler, FiberInputText, FiberInputTextPropsHandler, FiberInstancedLinesMesh, FiberInstancedLinesMeshPropsHandler, FiberInstancedMesh, FiberInstancedMeshPropsHandler, FiberLathe, FiberLayer, FiberLayerPropsHandler, FiberLensRenderingPipeline, FiberLensRenderingPipelinePropsHandler, FiberLight, FiberLightGizmo, FiberLightGizmoPropsHandler, FiberLightPropsHandler, FiberLine, FiberLinePropsHandler, FiberLineSystem, FiberLines, FiberLinesMesh, FiberLinesMeshPropsHandler, FiberMRDLBackplateMaterial, FiberMRDLBackplateMaterialPropsHandler, FiberMRDLSliderBarMaterial, FiberMRDLSliderBarMaterialPropsHandler, FiberMRDLSliderThumbMaterial, FiberMRDLSliderThumbMaterialPropsHandler, FiberMaterial, FiberMaterialPluginBase, FiberMaterialPluginBasePropsHandler, FiberMaterialPropsHandler, FiberMesh, FiberMeshButton3D, FiberMeshButton3DPropsHandler, FiberMeshPropsHandler, FiberMirrorTexture, FiberMirrorTexturePropsHandler, FiberMotionBlurPostProcess, FiberMotionBlurPostProcessPropsHandler, FiberMultiLine, FiberMultiLinePropsHandler, FiberMultiMaterial, FiberMultiMaterialPropsHandler, FiberMultiPointerScaleBehavior, FiberMultiPointerScaleBehaviorPropsHandler, FiberMultiRenderTarget, FiberMultiRenderTargetPropsHandler, FiberMultiviewRenderTarget, FiberMultiviewRenderTargetPropsHandler, FiberNearMenu, FiberNearMenuPropsHandler, FiberNode, FiberNodeMaterial, FiberNodeMaterialPropsHandler, FiberNodePropsHandler, FiberNoiseProceduralTexture, FiberNoiseProceduralTexturePropsHandler, FiberOcclusionMaterial, FiberOcclusionMaterialPropsHandler, FiberPBRAnisotropicConfiguration, FiberPBRAnisotropicConfigurationPropsHandler, FiberPBRBRDFConfiguration, FiberPBRBRDFConfigurationPropsHandler, FiberPBRBaseMaterial, FiberPBRBaseMaterialPropsHandler, FiberPBRBaseSimpleMaterial, FiberPBRBaseSimpleMaterialPropsHandler, FiberPBRClearCoatConfiguration, FiberPBRClearCoatConfigurationPropsHandler, FiberPBRMaterial, FiberPBRMaterialPropsHandler, FiberPBRMetallicRoughnessMaterial, FiberPBRMetallicRoughnessMaterialPropsHandler, FiberPBRSheenConfiguration, FiberPBRSheenConfigurationPropsHandler, FiberPBRSpecularGlossinessMaterial, FiberPBRSpecularGlossinessMaterialPropsHandler, FiberPBRSubSurfaceConfiguration, FiberPBRSubSurfaceConfigurationPropsHandler, FiberPassCubePostProcess, FiberPassCubePostProcessPropsHandler, FiberPassPostProcess, FiberPassPostProcessPropsHandler, FiberPhysicsImpostor, FiberPhysicsImpostorPropsHandler, FiberPlane, FiberPlaneDragGizmo, FiberPlaneDragGizmoPropsHandler, FiberPlanePanel, FiberPlanePanelPropsHandler, FiberPlaneRotationGizmo, FiberPlaneRotationGizmoPropsHandler, FiberPointLight, FiberPointLightPropsHandler, FiberPointerDragBehavior, FiberPointerDragBehaviorPropsHandler, FiberPointsCloudSystem, FiberPointsCloudSystemPropsHandler, FiberPolygon, FiberPolyhedron, FiberPositionGizmo, FiberPositionGizmoPropsHandler, FiberPostProcess, FiberPostProcessPropsHandler, FiberPostProcessRenderPipeline, FiberPostProcessRenderPipelinePropsHandler, FiberPrePassConfiguration, FiberPrePassConfigurationPropsHandler, FiberPrePassRenderTarget, FiberPrePassRenderTargetPropsHandler, FiberProceduralTexture, FiberProceduralTexturePropsHandler, FiberPushMaterial, FiberPushMaterialPropsHandler, FiberRadioButton, FiberRadioButtonPropsHandler, FiberRawCubeTexture, FiberRawCubeTexturePropsHandler, FiberRawTexture, FiberRawTexture2DArray, FiberRawTexture2DArrayPropsHandler, FiberRawTexture3D, FiberRawTexture3DPropsHandler, FiberRawTexturePropsHandler, FiberRectangle, FiberRectanglePropsHandler, FiberRefractionPostProcess, FiberRefractionPostProcessPropsHandler, FiberRefractionTexture, FiberRefractionTexturePropsHandler, FiberRenderTargetTexture, FiberRenderTargetTexturePropsHandler, FiberRibbon, FiberRotationGizmo, FiberRotationGizmoPropsHandler, FiberSSAO2RenderingPipeline, FiberSSAO2RenderingPipelinePropsHandler, FiberSSAORenderingPipeline, FiberSSAORenderingPipelinePropsHandler, FiberScaleGizmo, FiberScaleGizmoPropsHandler, FiberScatterPanel, FiberScatterPanelPropsHandler, FiberScenePropsHandler, FiberScreenSpaceCurvaturePostProcess, FiberScreenSpaceCurvaturePostProcessPropsHandler, FiberScreenSpaceReflectionPostProcess, FiberScreenSpaceReflectionPostProcessPropsHandler, FiberScrollBar, FiberScrollBarPropsHandler, FiberScrollViewer, FiberScrollViewerPropsHandler, FiberSelectionPanel, FiberSelectionPanelPropsHandler, FiberShaderMaterial, FiberShaderMaterialPropsHandler, FiberShadowGenerator, FiberShadowGeneratorPropsHandler, FiberShadowLight, FiberShadowLightPropsHandler, FiberSharpenPostProcess, FiberSharpenPostProcessPropsHandler, FiberSixDofDragBehavior, FiberSixDofDragBehaviorPropsHandler, FiberSlateGizmo, FiberSlateGizmoPropsHandler, FiberSlider, FiberSlider3D, FiberSlider3DPropsHandler, FiberSliderPropsHandler, FiberSphere, FiberSpherePanel, FiberSpherePanelPropsHandler, FiberSpotLight, FiberSpotLightPropsHandler, FiberStackPanel, FiberStackPanel3D, FiberStackPanel3DPropsHandler, FiberStackPanelPropsHandler, FiberStandardMaterial, FiberStandardMaterialPropsHandler, FiberStandardRenderingPipeline, FiberStandardRenderingPipelinePropsHandler, FiberStereoscopicArcRotateCamera, FiberStereoscopicArcRotateCameraPropsHandler, FiberStereoscopicFreeCamera, FiberStereoscopicFreeCameraPropsHandler, FiberStereoscopicGamepadCamera, FiberStereoscopicGamepadCameraPropsHandler, FiberStereoscopicInterlacePostProcess, FiberStereoscopicInterlacePostProcessI, FiberStereoscopicInterlacePostProcessIPropsHandler, FiberStereoscopicInterlacePostProcessPropsHandler, FiberStereoscopicScreenUniversalCamera, FiberStereoscopicScreenUniversalCameraPropsHandler, FiberStereoscopicUniversalCamera, FiberStereoscopicUniversalCameraPropsHandler, FiberSubSurfaceScatteringPostProcess, FiberSubSurfaceScatteringPostProcessPropsHandler, FiberSurfaceMagnetismBehavior, FiberSurfaceMagnetismBehaviorPropsHandler, FiberTargetCamera, FiberTargetCameraPropsHandler, FiberTextBlock, FiberTextBlockPropsHandler, FiberTexture, FiberTexturePropsHandler, FiberThinRenderTargetTexture, FiberThinRenderTargetTexturePropsHandler, FiberThinTexture, FiberThinTexturePropsHandler, FiberTiledBox, FiberTiledGround, FiberTiledPlane, FiberToggleButton, FiberToggleButtonPropsHandler, FiberTonemapPostProcess, FiberTonemapPostProcessPropsHandler, FiberTorus, FiberTorusKnot, FiberTouchButton3D, FiberTouchButton3DPropsHandler, FiberTouchCamera, FiberTouchCameraPropsHandler, FiberTouchHolographicButton, FiberTouchHolographicButtonPropsHandler, FiberTouchHolographicMenu, FiberTouchHolographicMenuPropsHandler, FiberTouchMeshButton3D, FiberTouchMeshButton3DPropsHandler, FiberTrailMesh, FiberTrailMeshPropsHandler, FiberTransformNode, FiberTransformNodePropsHandler, FiberTube, FiberUniversalCamera, FiberUniversalCameraPropsHandler, FiberUtilityLayerRenderer, FiberUtilityLayerRendererPropsHandler, FiberVRDeviceOrientationArcRotateCamera, FiberVRDeviceOrientationArcRotateCameraPropsHandler, FiberVRDeviceOrientationFreeCamera, FiberVRDeviceOrientationFreeCameraPropsHandler, FiberVRDeviceOrientationGamepadCamera, FiberVRDeviceOrientationGamepadCameraPropsHandler, FiberVRDistortionCorrectionPostProcess, FiberVRDistortionCorrectionPostProcessPropsHandler, FiberVRExperienceHelper, FiberVRExperienceHelperPropsHandler, FiberVRMultiviewToSingleviewPostProcess, FiberVRMultiviewToSingleviewPostProcessPropsHandler, FiberVideoTexture, FiberVideoTexturePropsHandler, FiberViewport, FiberViewportPropsHandler, FiberVirtualJoysticksCamera, FiberVirtualJoysticksCameraPropsHandler, FiberVirtualKeyboard, FiberVirtualKeyboardPropsHandler, FiberVolumeBasedPanel, FiberVolumeBasedPanelPropsHandler, FiberVolumetricLightScatteringPostProcess, FiberVolumetricLightScatteringPostProcessPropsHandler, FiberWebVRFreeCamera, FiberWebVRFreeCameraPropsHandler, FiberWebXRCamera, FiberWebXRCameraPropsHandler, Fiber_ScrollViewerWindow, Fiber_ScrollViewerWindowPropsHandler, FilterPostProcess, FluentBackplateMaterial, FluentButtonMaterial, FluentMaterial, FlyCamera, FocusableButton, FollowBehavior, FollowCamera, FramingBehavior, FreeCamera, FxaaPostProcess, GUI3DManager, GamepadCamera, Geodesic, Gizmo, GizmoManager, GlowLayer, Goldberg, GoldbergMesh, GrainPostProcess, Grid, Ground, GroundFromHeightMap, GroundMesh, HDRCubeTexture, HandConstraintBehavior, HandMenu, HandleMaterial, HemisphericLight, HighlightLayer, HighlightsPostProcess, HolographicBackplate, HolographicButton, HolographicSlate, HostRegistrationStore, Html, HtmlElementTexture, IcoSphere, Image, ImageBasedSlider, ImageProcessingConfiguration, ImageProcessingPostProcess, ImageScrollBar, InputPassword, InputText, InstancedLinesMesh, InstancedMesh, Lathe, Layer, LensRenderingPipeline, Light, LightGizmo, Line, LineSystem, Lines, LinesMesh, LoadedModel, LoaderStatus, MRDLBackplateMaterial, MRDLSliderBarMaterial, MRDLSliderThumbMaterial, Material, MaterialPluginBase, Mesh, MeshButton3D, MirrorTexture, Model, MotionBlurPostProcess, MultiLine, MultiMaterial, MultiPointerScaleBehavior, MultiRenderTarget, MultiviewRenderTarget, NearMenu, Node, NodeMaterial, NoiseProceduralTexture, OcclusionMaterial, PBRAnisotropicConfiguration, PBRBRDFConfiguration, PBRBaseMaterial, PBRBaseSimpleMaterial, PBRClearCoatConfiguration, PBRMaterial, PBRMetallicRoughnessMaterial, PBRSheenConfiguration, PBRSpecularGlossinessMaterial, PBRSubSurfaceConfiguration, PassCubePostProcess, PassPostProcess, PhysicsImpostor, Plane, PlaneDragGizmo, PlanePanel, PlaneRotationGizmo, PointLight, PointerDragBehavior, PointsCloudSystem, Polygon, Polyhedron, PositionGizmo, PostProcess, PostProcessRenderPipeline, PrePassConfiguration, PrePassRenderTarget, ProceduralTexture, PropChangeType, PushMaterial, RadioButton, RawCubeTexture, RawTexture, RawTexture2DArray, RawTexture3D, Rectangle, RefractionPostProcess, RefractionTexture, RenderTargetTexture, Ribbon, RotationGizmo, SSAO2RenderingPipeline, SSAORenderingPipeline, ScaleGizmo, ScatterPanel, Scene$1 as Scene, SceneContext, SceneLoaderContext, SceneLoaderContextProvider, ScreenSpaceCurvaturePostProcess, ScreenSpaceReflectionPostProcess, ScrollBar, ScrollViewer, SelectionPanel, ShaderMaterial, ShadowGenerator, ShadowLight, SharpenPostProcess, SixDofDragBehavior, Skybox, SlateGizmo, Slider, Slider3D, Sphere, SpherePanel, SpotLight, StackPanel, StackPanel3D, StandardMaterial, StandardRenderingPipeline, StereoscopicArcRotateCamera, StereoscopicFreeCamera, StereoscopicGamepadCamera, StereoscopicInterlacePostProcess, StereoscopicInterlacePostProcessI, StereoscopicScreenUniversalCamera, StereoscopicUniversalCamera, SubSurfaceScatteringPostProcess, SurfaceMagnetismBehavior, TargetCamera, TaskType, TextBlock, Texture, ThinRenderTargetTexture, ThinTexture, TiledBox, TiledGround, TiledPlane, ToggleButton, TonemapPostProcess, Torus, TorusKnot, TouchButton3D, TouchCamera, TouchHolographicButton, TouchHolographicMenu, TouchMeshButton3D, TrailMesh, TransformNode, Tube, UniversalCamera, UtilityLayerRenderer, VRDeviceOrientationArcRotateCamera, VRDeviceOrientationFreeCamera, VRDeviceOrientationGamepadCamera, VRDistortionCorrectionPostProcess, VRExperienceHelper, VRMultiviewToSingleviewPostProcess, VideoTexture, Viewport, VirtualJoysticksCamera, VirtualKeyboard, VolumeBasedPanel, VolumetricLightScatteringPostProcess, WebVRFreeCamera, WebXRCamera, _ScrollViewerWindow, applyInitialPropsToInstance, babylonClassFactory, checkColor3Diff, checkColor4Diff, checkControlDiff, checkFresnelParametersDiff, checkLambdaDiff, checkMethodDiff, checkNumericArrayDiff, checkObjectDiff, checkObservableDiff, checkPrimitiveDiff, checkQuaternionDiff, checkTextureDiff, checkVector3Diff, createPortal, createReconciler, intrinsicClassMap, roots, useAfterRender, useAssetManager, useBeforeRender, useCamera, useCanvas, useClick, useCustomPropsHandler, useEngine, useHover, useScene, useSceneLoader, withEngineCanvasContext };
